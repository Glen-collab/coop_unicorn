<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rainbow Unicorn Quest: Next Gen</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#000; }
canvas {
  display:block; margin:auto; position:absolute;
  top:50%; left:50%; transform:translate(-50%,-50%);
  image-rendering: pixelated; image-rendering: crisp-edges;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
"use strict";

// ============================================================
//  SECTION 1: CONFIG
// ============================================================

const CFG = {
  // Virtual resolution (internal render target)
  W: 480,
  H: 270,
  TILE: 20,
  // Level dimensions in tiles
  COLS: 200,
  ROWS: 14,  // 14 rows * 20px = 280, camera Y handles the 10px overflow

  // Physics
  GRAVITY: 0.35,
  MAX_FALL: 7,
  PLAYER_SPEED: 2.2,
  PLAYER_ACCEL: 0.25,
  PLAYER_DECEL: 0.18,
  JUMP_FORCE: -7.5,
  DOUBLE_JUMP_FORCE: -5.8,
  COYOTE_TIME: 0.08,
  JUMP_BUFFER: 0.1,

  // Camera
  CAM_LERP: 0.08,
  CAM_DEAD_X: 30,
  CAM_DEAD_Y: 20,
  CAM_LOOK_AHEAD: 40,
  SHAKE_DECAY: 0.88,

  // Collectibles / enemies
  STAR_COUNT: 15,
  FLY_COUNT: 10,
  STAR_FLOAT_AMP: 4,
  STAR_FLOAT_SPD: 2.5,
  FLY_BOB_AMP: 8,
  FLY_BOB_SPD: 3,
  FLY_PATROL_SPD: 0.8,

  // Colors
  SKY_TOP: "#1a0a3e",
  SKY_BOT: "#4a2080",
  GRASS_TOP: "#44cc44",
  GRASS_SIDE: "#2a8a2a",
  DIRT: "#8B6914",
  DIRT_DARK: "#6B4F10",

  // Level seed
  SEED: 77701,

  // Player sprite size
  PLAYER_W: 22,
  PLAYER_H: 36,
  PLAYER_DRAW_W: 45,
  PLAYER_DRAW_H: 60,

  // Sprite sheet config
  SPRITE_RUN_FRAMES: 9,
  SPRITE_RUN_FW: 165,  // frame width in sheet
  SPRITE_RUN_FH: 128,  // frame height in sheet
  SPRITE_IDLE_W: 128,
  SPRITE_IDLE_H: 128,
  SPRITE_FALL_W: 95,
  SPRITE_FALL_H: 128,
  SPRITE_HOOP_FRAMES: 6,
  SPRITE_HOOP_FW: 108,
  SPRITE_HOOP_FH: 128,
  SPRITE_GROW_WINGS_FRAMES: 3,
  SPRITE_GROW_WINGS_FW: 153,
  SPRITE_GROW_WINGS_FH: 128,
  SPRITE_JUMP_WINGS_FRAMES: 4,
  SPRITE_JUMP_WINGS_FW: 162,
  SPRITE_JUMP_WINGS_FH: 128,
  SPRITE_FLY_FRAMES: 5,
  SPRITE_FLY_FW: 64,
  SPRITE_FLY_FH: 64,
  SPRITE_JUMP_FRAMES: 7,
  SPRITE_JUMP_FW: 174,
  SPRITE_JUMP_FH: 128,
  SPRITE_STAND_POOP_FRAMES: 6,
  SPRITE_STAND_POOP_FW: 143,
  SPRITE_STAND_POOP_FH: 128,
  SPRITE_POOP_FRAMES: 4,
  SPRITE_POOP_FW: 104,
  SPRITE_POOP_FH: 64,
  SPRITE_GNOME_FRAMES: 5,
  SPRITE_GNOME_FW: 35,
  SPRITE_GNOME_FH: 64,
  SPRITE_RUN_WINGS_FRAMES: 7,
  SPRITE_RUN_WINGS_FW: 147,
  SPRITE_RUN_WINGS_FH: 128,
  SPRITE_STAND_POOP_WINGS_FRAMES: 6,
  SPRITE_STAND_POOP_WINGS_FW: 143,
  SPRITE_STAND_POOP_WINGS_FH: 128,
  SPRITE_IDLE_WINGS_W: 128,
  SPRITE_IDLE_WINGS_H: 128,
  SPRITE_BOSS_IDLE_FRAMES: 4,
  SPRITE_BOSS_IDLE_FW: 103,
  SPRITE_BOSS_IDLE_FH: 128,
  SPRITE_BOSS_ROAR_FRAMES: 4,
  SPRITE_BOSS_ROAR_FW: 103,
  SPRITE_BOSS_ROAR_FH: 128,
  SPRITE_BOSS_CHARGE_FRAMES: 10,
  SPRITE_BOSS_CHARGE_FW: 103,
  SPRITE_BOSS_CHARGE_FH: 128,
  SPRITE_BOSS_STUNNED_FRAMES: 3,
  SPRITE_BOSS_STUNNED_FW: 99,
  SPRITE_BOSS_STUNNED_FH: 128,
  SPRITE_MERMICORN_FRAMES: 5,
  SPRITE_MERMICORN_FW: 192,
  SPRITE_MERMICORN_FH: 128,
  SPRITE_MERMICORN_VICTORY_FRAMES: 3,
  SPRITE_MERMICORN_VICTORY_FW: 99,
  SPRITE_MERMICORN_VICTORY_FH: 128,
  SPRITE_SQUID_TAUNT_FRAMES: 3,
  SPRITE_SQUID_TAUNT_FW: 92,
  SPRITE_SQUID_TAUNT_FH: 128,
  SPRITE_SQUID_MOVE_FRAMES: 4,
  SPRITE_SQUID_MOVE_FW: 106,
  SPRITE_SQUID_MOVE_FH: 128,
  SPRITE_SQUID_HURT_FW: 102,
  SPRITE_SQUID_HURT_FH: 128,
  SPRITE_NARWHAL_FRAMES: 5,
  SPRITE_NARWHAL_FW: 117,
  SPRITE_NARWHAL_FH: 128,
  SPRITE_FISH_FRAMES: 4,
  SPRITE_FISH_FW: 164,
  SPRITE_FISH_FH: 128,
  SPRITE_JELLYFISH_FRAMES: 6,
  SPRITE_JELLYFISH_FW: 102,
  SPRITE_JELLYFISH_FH: 128,
  GNOME_COUNT: 6,
  GNOME_PATROL_SPD: 0.4,

  // Wing power-up
  TRIPLE_JUMP_FORCE: -4.8,
  WING_CRYSTAL_COUNT: 2,  // per level
  GROW_WINGS_DURATION: 0.6, // seconds for transformation anim

  // Flowers & Hay Bales
  DEAD_FLOWER_COUNT: 8,    // brown flowers per level
  BLACK_FLOWER_COUNT: 3,   // black flowers per level (spawn hay bales)
  FLOWERS_FOR_RAINBOW: 5,  // dead flowers needed for rainbow power
  FLOWERS_FOR_LIFE: 20,    // dead flowers needed for extra life

  // Level timer (Mario-style countdown)
  LEVEL_TIME: 300,         // normal level countdown
  BOSS_LEVEL_TIME: 400,    // boss level countdown
  TIME_TICK_SPEED: 2,      // ticks per real second (300 = 150 real seconds)
  TIME_WARNING: 100,       // flash red below this

  // Invincibility
  INV_TIME: 2.0,
  LIVES: 3,

  // Fish enemies (underwater)
  FISH_SPEED: 0.7,
  FISH_BOB_AMP: 3,
  FISH_BOB_SPD: 2,

  // Jellyfish enemies (underwater)
  JELLY_SPEED: 0.3,
  JELLY_BOB_AMP: 18,
  JELLY_BOB_SPD: 1.2,

  // Narwhal enemies (underwater)
  NARWHAL_SPD: 1.0,

  // Underwater physics (Mario-style sluggish swimming)
  UNDERWATER_GRAVITY: 0.10,
  UNDERWATER_MAX_FALL: 1.8,
  UNDERWATER_JUMP_FORCE: -3.0,
  UNDERWATER_SPEED: 0.9,         // very slow swim (Mario sluggish feel)
  UNDERWATER_ACCEL: 0.10,        // sluggish acceleration
  // Mermaid form (Frog Mario — fast and responsive)
  MERMAID_SPEED: 2.2,            // fast swimmer
  MERMAID_JUMP_FORCE: -4.5,      // strong kick
  MERMAID_ACCEL: 0.28,           // responsive controls

  // Mermaid transformation
  MERMAID_TRANSFORM_DURATION: 0.8,

  // Kittycorn sprites
  SPRITE_KITTYCORN_STAND_W: 130, SPRITE_KITTYCORN_STAND_H: 128,
  SPRITE_KITTYCORN_RUN_FRAMES: 7, SPRITE_KITTYCORN_RUN_FW: 132, SPRITE_KITTYCORN_RUN_FH: 128,
  SPRITE_KITTYCORN_JUMP_FRAMES: 4, SPRITE_KITTYCORN_JUMP_FW: 141, SPRITE_KITTYCORN_JUMP_FH: 128,
  SPRITE_KITTYCORN_STAND_POOP_W: 130, SPRITE_KITTYCORN_STAND_POOP_H: 128,
  SPRITE_KITTYCORN_CELEBRATE_FRAMES: 3, SPRITE_KITTYCORN_CELEBRATE_FW: 131, SPRITE_KITTYCORN_CELEBRATE_FH: 128,

  // Kittycorn transformation
  KITTYCORN_TRANSFORM_DURATION: 0.8,

  // Hawk (bird enemy) sprites
  SPRITE_HAWK_FRAMES: 5, SPRITE_HAWK_FW: 180, SPRITE_HAWK_FH: 160,

  // Hawk Boss sprites (1024x128 sheet, 8 frames at 128x128)
  SPRITE_HAWK_BOSS_FLY_FRAMES: 5,   // frames 0-4: flying/attack
  SPRITE_HAWK_BOSS_HURT_FRAMES: 3,  // frames 5-7: hit/stunned (big eyes)
  SPRITE_HAWK_BOSS_FW: 128,
  SPRITE_HAWK_BOSS_FH: 128,

  // Pixicorn sprites (768x128 sheet, 6 frames at 128x128)
  SPRITE_PIXICORN_FLY_FRAMES: 3,     // frames 0-2: flying in motion
  SPRITE_PIXICORN_HOVER_FRAMES: 2,   // frames 3-4: hovering still
  SPRITE_PIXICORN_VICTORY_FRAME: 5,  // frame 5: celebration pose
  SPRITE_PIXICORN_FW: 128,
  SPRITE_PIXICORN_FH: 128,

  // Pixicorn flight
  PIXICORN_TRANSFORM_DURATION: 0.8,
  PIXICORN_SPEED: 2.2,
  PIXICORN_ASCEND_SPEED: -2.0,
  PIXICORN_DESCEND_SPEED: 2.0,

  // Flower boss
  FLOWER_FIREBALL_SPEED: 2.5,
  FLOWER_FIREBALL_INTERVAL: 1.8,

  // Flower Boss sprites (512x128 sheet, 4 frames at 128x128)
  SPRITE_FLOWER_BOSS_FW: 128,
  SPRITE_FLOWER_BOSS_FH: 128,
  SPRITE_FLOWER_BOSS_FRAMES: 4,

  // Mousicorn sprites (1024x128, 8 frames at 128x128)
  SPRITE_MOUSICORN_RUN_FRAMES: 6,
  SPRITE_MOUSICORN_JUMP_FRAME: 7,
  SPRITE_MOUSICORN_STAND_FRAME: 0,
  SPRITE_MOUSICORN_POOP_FRAME: 6,
  SPRITE_MOUSICORN_FW: 128,
  SPRITE_MOUSICORN_FH: 128,
  MOUSICORN_TRANSFORM_DURATION: 0.8,
  MOUSICORN_SPEED: 2.8,

  // Rat boss
  RAT_CHARGE_SPEED_MULT: 3.0,
  RAT_JUMP_FORCE: -6.5,
  RAT_JUMP_INTERVAL: 3.0,
  RAT_CHARGE_INTERVAL: 2.0,

  // Rat King Boss sprites (1856x97 sheet, 8 frames at 232x97)
  SPRITE_RAT_BOSS_FW: 232,
  SPRITE_RAT_BOSS_FH: 97,
  SPRITE_RAT_BOSS_WALK_FRAMES: 3,    // frames 0-2: walk/taunt
  SPRITE_RAT_BOSS_HIT_FRAME: 3,      // frame 3: getting hit
  SPRITE_RAT_BOSS_CHARGE_START: 4,    // frames 4-6: charging
  SPRITE_RAT_BOSS_CHARGE_FRAMES: 3,
  SPRITE_RAT_BOSS_SHOOT_FRAME: 7,    // frame 7: standing fireball stance

  // Shadow Queen Boss sprites (1030x244 sheet, 5 frames at 206x244)
  SPRITE_SHADOW_BOSS_FW: 206,
  SPRITE_SHADOW_BOSS_FH: 244,
  SPRITE_SHADOW_BOSS_STAND_FRAMES: 2, // frames 0-1: standing/shooting
  SPRITE_SHADOW_BOSS_FLY_START: 2,    // frames 2-4: flying
  SPRITE_SHADOW_BOSS_FLY_FRAMES: 3,

  // Pharaoh Cat Boss sprites (768x128 sheet, 6 frames at 128x128)
  SPRITE_PHARAOH_BOSS_FW: 128,
  SPRITE_PHARAOH_BOSS_FH: 128,
  SPRITE_PHARAOH_BOSS_WALK_FRAMES: 2,   // frames 0-1: walking/prowling
  SPRITE_PHARAOH_BOSS_ROAR_FRAME: 2,    // frame 2: roaring/hissing (mouth open)
  SPRITE_PHARAOH_BOSS_CHARGE_FRAME: 3,  // frame 3: charging/pouncing
  SPRITE_PHARAOH_BOSS_SCRATCH_FRAME: 4, // frame 4: attack pose
  SPRITE_PHARAOH_BOSS_HISS_FRAME: 5,    // frame 5: hissing/shooting

  // Storm Dragon Boss sprites (384x128 sheet, 3 frames at 128x128)
  SPRITE_DRAGON_BOSS_FW: 128,
  SPRITE_DRAGON_BOSS_FH: 128,
  SPRITE_DRAGON_BOSS_FRAMES: 3,         // frames 0-2: flying poses
};

// ---- World / Level Definitions ----
// Each world has 4 levels. Level x-4 is always a boss fight.
// Structure supports 8 worlds (32 levels total).
const LEVEL_DEFS = [
  // === WORLD 1 ===
  {
    world: 1, level: 1, name: "1-1", title: "MEADOW VALLEY", seed: 77701, cols: 200,
    sky: ["#0a0020","#1a0a4e","#3a1870","#5a2890","#7040a8"],
    grassTop: "#55dd55", grassBot: "#38aa38", grassBlade: "#66ee66",
    dirt: "#8B6914", dirtDark: "#6B4F10",
    starCount: 15, flyCount: 10, gnomeCount: 6,
    wingCrystals: 2, deadFlowers: 8, blackFlowers: 3,
    isBoss: false, bgTheme: "meadow",
    terrain: { pit: 0.15, platform: 0.40, stairs: 0.55, twotier: 0.80 },
  },
  {
    world: 1, level: 2, name: "1-2", title: "CRYSTAL CAVES", seed: 88802, cols: 220,
    sky: ["#050510","#080818","#0a0a22","#0c0c2c","#0e0e36"],
    grassTop: "#667788", grassBot: "#556677", grassBlade: "#7799aa",
    dirt: "#3a3a55", dirtDark: "#2a2a44",
    starCount: 18, flyCount: 12, gnomeCount: 8,
    wingCrystals: 1, deadFlowers: 6, blackFlowers: 3,
    isBoss: false, bgTheme: "cave",
    terrain: { pit: 0.10, platform: 0.50, stairs: 0.65, twotier: 0.85 },
  },
  {
    world: 1, level: 3, name: "1-3", title: "ENCHANTED FOREST", seed: 99903, cols: 250,
    sky: ["#040d04","#081808","#0c2a0e","#103a12","#144a16"],
    grassTop: "#33bb44", grassBot: "#229933", grassBlade: "#44dd55",
    dirt: "#5a3a1a", dirtDark: "#4a2a10",
    starCount: 20, flyCount: 14, gnomeCount: 10,
    wingCrystals: 1, deadFlowers: 10, blackFlowers: 4,
    isBoss: false, bgTheme: "forest",
    terrain: { pit: 0.08, platform: 0.35, stairs: 0.45, twotier: 0.75 },
  },
  {
    world: 1, level: 4, name: "1-4", title: "CLOUD KINGDOM", seed: 11104, cols: 150,
    sky: ["#3366bb","#4477cc","#5588dd","#6699ee","#77aaff"],
    grassTop: "#ddeeff", grassBot: "#bbddee", grassBlade: null,
    dirt: "#aaccdd", dirtDark: "#99bbcc",
    starCount: 10, flyCount: 6, gnomeCount: 3,
    wingCrystals: 0, deadFlowers: 4, blackFlowers: 2,
    isBoss: true, bgTheme: "clouds",
    terrain: { pit: 0.25, platform: 0.60, stairs: 0.70, twotier: 0.85 },
  },
  // === WORLD 2: WILLIAMS LAKE ===
  {
    world: 2, level: 1, name: "2-1", title: "WILLIAMS LAKE", seed: 22201, cols: 200,
    sky: ["#2a4060","#3a5878","#5a7898","#7898b8","#98b8d8"],
    grassTop: "#6a9944", grassBot: "#4a7830", grassBlade: "#7aaa55",
    dirt: "#6a5028", dirtDark: "#4a3818",
    starCount: 15, flyCount: 8, gnomeCount: 6,
    fishCount: 0, jellyCount: 0,
    wingCrystals: 1, mermaidGems: 0, deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "lakeside",
    terrain: { pit: 0.18, platform: 0.42, stairs: 0.55, twotier: 0.78 },
    waterInPits: true, // show water in pit gaps
  },
  {
    world: 2, level: 2, name: "2-2", title: "PACKER BAY", seed: 33302, cols: 220,
    sky: ["#0a2a4a","#0e3a5e","#124a6e","#1a5a7e","#226a8e"],
    grassTop: "#d4a862", grassBot: "#b8924a", grassBlade: null,
    dirt: "#c49650", dirtDark: "#a47838",
    starCount: 18, flyCount: 0, gnomeCount: 0,
    fishCount: 14, jellyCount: 4, narwhalCount: 4,
    wingCrystals: 0, mermaidGems: 1, deadFlowers: 0, blackFlowers: 0,
    isUnderwater: true, isBoss: false, bgTheme: "shallow_water",
    terrain: { pit: 0.08, platform: 0.45, stairs: 0.60, twotier: 0.82 },
  },
  {
    world: 2, level: 3, name: "2-3", title: "THE DEEP", seed: 44403, cols: 250,
    sky: ["#040810","#061018","#081822","#0a2030","#0c2838"],
    grassTop: "#3a4a5a", grassBot: "#2a3a4a", grassBlade: null,
    dirt: "#2a3040", dirtDark: "#1a2030",
    starCount: 20, flyCount: 0, gnomeCount: 0,
    fishCount: 10, jellyCount: 10, narwhalCount: 6,
    wingCrystals: 0, mermaidGems: 1, deadFlowers: 0, blackFlowers: 0,
    isUnderwater: true, isBoss: false, bgTheme: "deep_water",
    terrain: { pit: 0.05, platform: 0.40, stairs: 0.50, twotier: 0.75 },
  },
  {
    world: 2, level: 4, name: "2-4", title: "KRAKEN'S LAIR", seed: 55504, cols: 160,
    sky: ["#0a0415","#10081e","#160c28","#1c1032","#22143c"],
    grassTop: "#4a3a5a", grassBot: "#3a2a4a", grassBlade: null,
    dirt: "#302040", dirtDark: "#201030",
    starCount: 10, flyCount: 0, gnomeCount: 0,
    fishCount: 6, jellyCount: 4, narwhalCount: 3,
    wingCrystals: 0, mermaidGems: 1, deadFlowers: 0, blackFlowers: 0,
    isUnderwater: true, isBoss: true, bgTheme: "boss_water",
    terrain: { pit: 0.12, platform: 0.55, stairs: 0.65, twotier: 0.82 },
  },
  // === WORLD 3: WHISKER WOODS (Treetop Kingdom) ===
  {
    world: 3, level: 1, name: "3-1", title: "WHISKER WOODS", seed: 33301, cols: 200,
    sky: ["#1a0a00","#3a1800","#6a3510","#a05820","#d08030"],
    grassTop: "#6a8a3a", grassBot: "#4a6a28", grassBlade: "#7a9a4a",
    dirt: "#5a3a1a", dirtDark: "#3a2510",
    starCount: 15, flyCount: 10, gnomeCount: 4, birdCount: 6,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "treetop",
    terrain: { pit: 0.22, platform: 0.50, stairs: 0.60, twotier: 0.82 },
  },
  {
    world: 3, level: 2, name: "3-2", title: "CANOPY RUN", seed: 44402, cols: 230,
    sky: ["#0a1a30","#1a3050","#2a5070","#4080a0","#60b0d0"],
    grassTop: "#5a7a30", grassBot: "#3a5a1a", grassBlade: "#6a8a40",
    dirt: "#4a3018", dirtDark: "#30200c",
    starCount: 18, flyCount: 8, gnomeCount: 0, birdCount: 10,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 1, mermaidGems: 0, deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "treetop_high",
    terrain: { pit: 0.28, platform: 0.55, stairs: 0.65, twotier: 0.85 },
  },
  {
    world: 3, level: 3, name: "3-3", title: "TIMBER FALLS", seed: 55503, cols: 260,
    sky: ["#0a0a10","#141420","#1e1e30","#282840","#323250"],
    grassTop: "#3a5a2a", grassBot: "#2a4018", grassBlade: "#4a6a3a",
    dirt: "#3a2818", dirtDark: "#281a0c",
    starCount: 20, flyCount: 6, gnomeCount: 0, birdCount: 14,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 1, mermaidGems: 0, deadFlowers: 10, blackFlowers: 4,
    isUnderwater: false, isBoss: false, bgTheme: "treetop_dark",
    terrain: { pit: 0.32, platform: 0.52, stairs: 0.62, twotier: 0.80 },
  },
  {
    world: 3, level: 4, name: "3-4", title: "HAWK'S PEAK", seed: 66604, cols: 160,
    sky: ["#1a0818","#2a1028","#3a1838","#4a2048","#5a2858"],
    grassTop: "#4a3a2a", grassBot: "#3a2a1a", grassBlade: null,
    dirt: "#2a1a10", dirtDark: "#1a0c08",
    starCount: 10, flyCount: 4, gnomeCount: 0, birdCount: 6,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, deadFlowers: 4, blackFlowers: 2,
    isUnderwater: false, isBoss: true, bgTheme: "treetop_boss",
    terrain: { pit: 0.20, platform: 0.55, stairs: 0.68, twotier: 0.85 },
  },
  // === WORLD 4: FAIRY FALLS ===
  {
    world: 4, level: 1, name: "4-1", title: "FAIRY FALLS", seed: 44101, cols: 200,
    sky: ["#2a1040","#4a2068","#6a3090","#8a50b0","#b080d0"],
    grassTop: "#44cc66", grassBot: "#2a9a44", grassBlade: "#66ee88",
    dirt: "#6a4a2a", dirtDark: "#4a3018",
    starCount: 15, flyCount: 10, gnomeCount: 6, birdCount: 4,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "fairy",
    terrain: { pit: 0.18, platform: 0.45, stairs: 0.58, twotier: 0.80 },
  },
  {
    world: 4, level: 2, name: "4-2", title: "MISTY HOLLOW", seed: 44202, cols: 230,
    sky: ["#1a0830","#301050","#4a2070","#6a4090","#8a60b0"],
    grassTop: "#3abb55", grassBot: "#288a3a", grassBlade: "#55dd77",
    dirt: "#5a3a20", dirtDark: "#3a2510",
    starCount: 18, flyCount: 8, gnomeCount: 4, birdCount: 8,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "fairy_mist",
    terrain: { pit: 0.15, platform: 0.48, stairs: 0.60, twotier: 0.82 },
  },
  {
    world: 4, level: 3, name: "4-3", title: "CRYSTAL CASCADE", seed: 44303, cols: 260,
    sky: ["#0a0818","#140c28","#1e1040","#281858","#322070"],
    grassTop: "#2a8a44", grassBot: "#1a6a30", grassBlade: "#3aaa55",
    dirt: "#3a2a18", dirtDark: "#2a1a0c",
    starCount: 20, flyCount: 6, gnomeCount: 2, birdCount: 12,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, deadFlowers: 10, blackFlowers: 4,
    isUnderwater: false, isBoss: false, bgTheme: "fairy_dark",
    terrain: { pit: 0.12, platform: 0.42, stairs: 0.55, twotier: 0.78 },
  },
  {
    world: 4, level: 4, name: "4-4", title: "BLOSSOM'S LAIR", seed: 44404, cols: 160,
    sky: ["#1a1008","#2a1810","#3a2818","#4a3820","#5a4828"],
    grassTop: "#3a7a30", grassBot: "#286a20", grassBlade: "#4a8a40",
    dirt: "#2a1a0c", dirtDark: "#1a0c04",
    starCount: 10, flyCount: 4, gnomeCount: 0, birdCount: 6,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, deadFlowers: 4, blackFlowers: 2,
    isUnderwater: false, isBoss: true, bgTheme: "fairy_boss",
    terrain: { pit: 0.15, platform: 0.50, stairs: 0.62, twotier: 0.82 },
  },
  // === WORLD 5: SEWER DEPTHS ===
  {
    world: 5, level: 1, name: "5-1", title: "SEWER ENTRANCE", seed: 55101, cols: 200,
    sky: ["#0a0a08","#141410","#1e1e18","#282820","#323228"],
    grassTop: "#5a5a50", grassBot: "#4a4a40", grassBlade: null,
    dirt: "#3a3a30", dirtDark: "#2a2a20",
    starCount: 15, flyCount: 10, gnomeCount: 6, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 1, deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "sewer",
    terrain: { pit: 0.15, platform: 0.42, stairs: 0.55, twotier: 0.78 },
    waterInPits: true,
  },
  {
    world: 5, level: 2, name: "5-2", title: "FLOODED TUNNELS", seed: 55202, cols: 220,
    sky: ["#080c08","#0c140c","#101c10","#142414","#182c18"],
    grassTop: "#4a5040", grassBot: "#3a4030", grassBlade: null,
    dirt: "#303828", dirtDark: "#202818",
    starCount: 18, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 12, jellyCount: 6, narwhalCount: 4,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 1, pixicornGems: 0, mousicornGems: 1, deadFlowers: 0, blackFlowers: 0,
    isUnderwater: true, isBoss: false, bgTheme: "sewer_flood",
    terrain: { pit: 0.08, platform: 0.45, stairs: 0.58, twotier: 0.80 },
  },
  {
    world: 5, level: 3, name: "5-3", title: "THE UNDERWORKS", seed: 55303, cols: 260,
    sky: ["#060606","#0c0c0a","#12120e","#181814","#1e1e18"],
    grassTop: "#484840", grassBot: "#383830", grassBlade: null,
    dirt: "#2e2e24", dirtDark: "#1e1e14",
    starCount: 20, flyCount: 6, gnomeCount: 4, birdCount: 8,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 1, deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "sewer_deep",
    terrain: { pit: 0.12, platform: 0.40, stairs: 0.52, twotier: 0.78 },
    waterInPits: true,
  },
  {
    world: 5, level: 4, name: "5-4", title: "RAT KING'S DEN", seed: 55404, cols: 160,
    sky: ["#0a0806","#140e0a","#1e140e","#281a12","#322016"],
    grassTop: "#4a4238", grassBot: "#3a3228", grassBlade: null,
    dirt: "#2a2218", dirtDark: "#1a1208",
    starCount: 10, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 6, jellyCount: 0, narwhalCount: 3,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0, deadFlowers: 0, blackFlowers: 0,
    isUnderwater: true, isBoss: true, bgTheme: "sewer_boss",
    terrain: { pit: 0.10, platform: 0.50, stairs: 0.62, twotier: 0.82 },
  },
  // === WORLD 6: AROUND THE WORLD ===
  {
    world: 6, level: 1, name: "6-1", title: "ENCHANTED SHORES", seed: 66101, cols: 260,
    // Base colors (forest start — overridden by zones)
    sky: ["#040d04","#081808","#0c2a0e","#103a12","#144a16"],
    grassTop: "#33bb44", grassBot: "#229933", grassBlade: "#44dd55",
    dirt: "#5a3a1a", dirtDark: "#4a2a10",
    starCount: 22, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 1, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "forest",
    terrain: { pit: 0.12, platform: 0.40, stairs: 0.55, twotier: 0.80 },
    zones: [
      {
        startCol: 0, bgTheme: "forest", isUnderwater: false,
        sky: ["#040d04","#081808","#0c2a0e","#103a12","#144a16"],
        grassTop: "#33bb44", grassBot: "#229933", grassBlade: "#44dd55",
        dirt: "#5a3a1a", dirtDark: "#4a2a10",
        terrain: { pit: 0.12, platform: 0.40, stairs: 0.55, twotier: 0.80 },
        flyCount: 8, gnomeCount: 4
      },
      {
        startCol: 100, bgTheme: "shallow_water", isUnderwater: true, wallEntry: true,
        sky: ["#0a2a4a","#0e3a5e","#124a6e","#1a5a7e","#226a8e"],
        grassTop: "#d4a862", grassBot: "#b8924a", grassBlade: null,
        dirt: "#8a7050", dirtDark: "#6a5040",
        terrain: { pit: 0.08, platform: 0.45, stairs: 0.60, twotier: 0.82 },
        fishCount: 10, jellyCount: 6, narwhalCount: 3
      }
    ],
  },
  {
    world: 6, level: 2, name: "6-2", title: "SKY & SAND", seed: 66202, cols: 280,
    sky: ["#040d04","#081808","#0c2a0e","#103a12","#144a16"],
    grassTop: "#33bb44", grassBot: "#229933", grassBlade: "#44dd55",
    dirt: "#5a3a1a", dirtDark: "#4a2a10",
    starCount: 25, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, mousicornGems: 0,
    deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "forest",
    terrain: { pit: 0.15, platform: 0.40, stairs: 0.55, twotier: 0.80 },
    zones: [
      {
        startCol: 0, bgTheme: "forest", isUnderwater: false,
        sky: ["#040d04","#081808","#0c2a0e","#103a12","#144a16"],
        grassTop: "#33bb44", grassBot: "#229933", grassBlade: "#44dd55",
        dirt: "#5a3a1a", dirtDark: "#4a2a10",
        terrain: { pit: 0.12, platform: 0.38, stairs: 0.52, twotier: 0.78 },
        flyCount: 4, gnomeCount: 4
      },
      {
        startCol: 55, bgTheme: "clouds", isUnderwater: false,
        sky: ["#3366bb","#4477cc","#5588dd","#6699ee","#77aaff"],
        grassTop: "#ddeeff", grassBot: "#bbddee", grassBlade: null,
        dirt: "#aaccdd", dirtDark: "#99bbcc",
        terrain: { pit: 0.25, platform: 0.60, stairs: 0.70, twotier: 0.85 },
        flyCount: 6, gnomeCount: 0
      },
      {
        startCol: 155, bgTheme: "desert", isUnderwater: false,
        sky: ["#1a2a60","#3a4a80","#6a6a40","#aa8a30","#cc9930"],
        grassTop: "#d4a862", grassBot: "#c4985a", grassBlade: null,
        dirt: "#b89050", dirtDark: "#987040",
        terrain: { pit: 0.10, platform: 0.42, stairs: 0.58, twotier: 0.80 },
        flyCount: 8, gnomeCount: 6, birdCount: 4
      }
    ],
  },
  {
    world: 6, level: 3, name: "6-3", title: "TOMB OF THE PHARAOH", seed: 66303, cols: 260,
    sky: ["#1a2a60","#3a4a80","#6a6a40","#aa8a30","#cc9930"],
    grassTop: "#d4a862", grassBot: "#c4985a", grassBlade: null,
    dirt: "#b89050", dirtDark: "#987040",
    starCount: 20, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 1,
    deadFlowers: 6, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "desert",
    terrain: { pit: 0.10, platform: 0.42, stairs: 0.56, twotier: 0.80 },
    zones: [
      {
        startCol: 0, bgTheme: "desert", isUnderwater: false,
        sky: ["#1a2a60","#3a4a80","#6a6a40","#aa8a30","#cc9930"],
        grassTop: "#d4a862", grassBot: "#c4985a", grassBlade: null,
        dirt: "#b89050", dirtDark: "#987040",
        terrain: { pit: 0.10, platform: 0.42, stairs: 0.56, twotier: 0.80 },
        flyCount: 6, gnomeCount: 4, birdCount: 4
      },
      {
        startCol: 75, bgTheme: "desert", isUnderwater: false,
        sky: ["#1a2a60","#3a4a80","#6a6a40","#aa8a30","#cc9930"],
        grassTop: "#c4985a", grassBot: "#b4884a", grassBlade: null,
        dirt: "#a88040", dirtDark: "#886030",
        terrain: { pit: 0.08, platform: 0.38, stairs: 0.52, twotier: 0.78 },
        flyCount: 2, gnomeCount: 2
      },
      {
        startCol: 105, bgTheme: "pyramid_interior", isUnderwater: false,
        formGate: { col: 103, form: "mousicorn", height: 240 },
        sky: ["#0a0806","#140e0a","#1a1410","#201a16","#28201c"],
        grassTop: "#8a8070", grassBot: "#6a6050", grassBlade: null,
        dirt: "#5a5040", dirtDark: "#4a4030",
        terrain: { pit: 0.08, platform: 0.45, stairs: 0.60, twotier: 0.82 },
        flyCount: 4, gnomeCount: 8
      }
    ],
  },
  {
    world: 6, level: 4, name: "6-4", title: "PHARAOH'S CAT", seed: 66604, cols: 160,
    sky: ["#1a1208","#28200e","#362e14","#443c1a","#524a20"],
    grassTop: "#9a8a60", grassBot: "#7a6a40", grassBlade: null,
    dirt: "#5a4a20", dirtDark: "#4a3a10",
    starCount: 10, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 0, kittycornGems: 1, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 0, blackFlowers: 0,
    isUnderwater: false, isBoss: true, bgTheme: "pyramid_boss",
    terrain: { pit: 0.08, platform: 0.45, stairs: 0.58, twotier: 0.80 },
  },
  // === WORLD 7: SKY KINGDOM ===
  {
    world: 7, level: 1, name: "7-1", title: "SKY KINGDOM", seed: 77101, cols: 220,
    sky: ["#1a3a7a","#2a5aaa","#4a7acc","#6a9aee","#8abafe"],
    grassTop: "#ddeeff", grassBot: "#bbddff", grassBlade: null,
    dirt: "#99bbdd", dirtDark: "#88aacc",
    starCount: 20, flyCount: 10, gnomeCount: 4, birdCount: 6,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 2, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, mousicornGems: 0,
    deadFlowers: 6, blackFlowers: 2,
    isUnderwater: false, isBoss: false, bgTheme: "sky_kingdom",
    terrain: { pit: 0.22, platform: 0.55, stairs: 0.68, twotier: 0.85 },
  },
  {
    world: 7, level: 2, name: "7-2", title: "STORM PEAKS", seed: 77202, cols: 240,
    sky: ["#0a0a1a","#141428","#1e1e3c","#282850","#323264"],
    grassTop: "#8888aa", grassBot: "#6a6a88", grassBlade: null,
    dirt: "#4a4a66", dirtDark: "#3a3a55",
    starCount: 22, flyCount: 14, gnomeCount: 6, birdCount: 8,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "storm_peaks",
    terrain: { pit: 0.20, platform: 0.50, stairs: 0.65, twotier: 0.82 },
  },
  {
    world: 7, level: 3, name: "7-3", title: "STAR BRIDGE", seed: 77303, cols: 260,
    sky: ["#020010","#060028","#0a0040","#100060","#180080"],
    grassTop: "#aabbee", grassBot: "#8899cc", grassBlade: "#bbccff",
    dirt: "#445588", dirtDark: "#334477",
    starCount: 25, flyCount: 16, gnomeCount: 8, birdCount: 10,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 1, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 10, blackFlowers: 4,
    isUnderwater: false, isBoss: false, bgTheme: "star_bridge",
    terrain: { pit: 0.18, platform: 0.48, stairs: 0.62, twotier: 0.80 },
  },
  {
    world: 7, level: 4, name: "7-4", title: "DRAGON'S ROOST", seed: 77404, cols: 160,
    sky: ["#0a0a2a","#1a1a4a","#2a2a6a","#3a3a8a","#4a4aaa"],
    grassTop: "#99aadd", grassBot: "#7788bb", grassBlade: null,
    dirt: "#556699", dirtDark: "#445588",
    starCount: 10, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 0, blackFlowers: 0,
    isUnderwater: false, isBoss: true, bgTheme: "sky_boss",
    terrain: { pit: 0.15, platform: 0.50, stairs: 0.65, twotier: 0.82 },
  },
  // === WORLD 8: RAINBOW LAND ===
  {
    world: 8, level: 1, name: "8-1", title: "RAINBOW ROAD", seed: 88101, cols: 230,
    sky: ["#1a0a30","#2a1a50","#3a2a70","#5040a0","#6a50c0"],
    grassTop: "#ff6688", grassBot: "#dd4466", grassBlade: "#ff88aa",
    dirt: "#884466", dirtDark: "#663344",
    starCount: 22, flyCount: 12, gnomeCount: 6, birdCount: 6,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 2, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, mousicornGems: 0,
    deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "rainbow_road",
    terrain: { pit: 0.18, platform: 0.48, stairs: 0.62, twotier: 0.82 },
  },
  {
    world: 8, level: 2, name: "8-2", title: "CRYSTAL PALACE", seed: 88202, cols: 240,
    sky: ["#0a0818","#140e2a","#1e1440","#281a58","#322070"],
    grassTop: "#aabbff", grassBot: "#8899dd", grassBlade: "#bbccff",
    dirt: "#5566aa", dirtDark: "#445599",
    starCount: 24, flyCount: 14, gnomeCount: 8, birdCount: 8,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 1, mermaidGems: 0, pixicornGems: 0, mousicornGems: 1,
    deadFlowers: 8, blackFlowers: 3,
    isUnderwater: false, isBoss: false, bgTheme: "crystal_palace",
    terrain: { pit: 0.12, platform: 0.45, stairs: 0.60, twotier: 0.80 },
  },
  {
    world: 8, level: 3, name: "8-3", title: "PRISMATIC FALLS", seed: 88303, cols: 270,
    sky: ["#100828","#1a1040","#2a1858","#3a2070","#4a2888"],
    grassTop: "#ee88ff", grassBot: "#cc66dd", grassBlade: "#ff99ff",
    dirt: "#6644aa", dirtDark: "#553399",
    starCount: 28, flyCount: 18, gnomeCount: 10, birdCount: 10,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 1, mousicornGems: 0,
    deadFlowers: 12, blackFlowers: 5,
    isUnderwater: false, isBoss: false, bgTheme: "prismatic_falls",
    terrain: { pit: 0.15, platform: 0.45, stairs: 0.58, twotier: 0.78 },
  },
  {
    world: 8, level: 4, name: "8-4", title: "SHADOW QUEEN'S THRONE", seed: 88404, cols: 170,
    sky: ["#050008","#0a0010","#100020","#180030","#200040"],
    grassTop: "#8866aa", grassBot: "#664488", grassBlade: null,
    dirt: "#443366", dirtDark: "#332255",
    starCount: 12, flyCount: 0, gnomeCount: 0, birdCount: 0,
    fishCount: 0, jellyCount: 0, narwhalCount: 0,
    wingCrystals: 1, kittycornGems: 0, mermaidGems: 0, pixicornGems: 0, mousicornGems: 0,
    deadFlowers: 0, blackFlowers: 0,
    isUnderwater: false, isBoss: true, bgTheme: "rainbow_boss",
    terrain: { pit: 0.10, platform: 0.50, stairs: 0.65, twotier: 0.82 },
  },
];

// --- World Save Codes ---
// Shown when you beat a world boss. Enter on title screen to start at that world.
const WORLD_CODES = {
  // World 1 is always the start — no code needed
  "SWIM":   { world: 2, levelIndex: 4, label: "World 2: Williams Lake" },
  "TREE":   { world: 3, levelIndex: 8, label: "World 3: Whisker Woods" },
  "WIND":   { world: 4, levelIndex: 12, label: "World 4: Fairy Falls" },
  "ROCK":   { world: 5, levelIndex: 16, label: "World 5: Sewer Depths" },
  "SAND":   { world: 6, levelIndex: 20, label: "World 6: Around the World" },
  "STAR":   { world: 7, levelIndex: 24, label: "World 7: Sky Kingdom" },
  "MOON":   { world: 8, levelIndex: 28, label: "World 8: Rainbow Land" },
};

// Reverse lookup: world number → code (for showing on world complete)
const WORLD_CODE_BY_NUM = {};
for (const [code, info] of Object.entries(WORLD_CODES)) {
  WORLD_CODE_BY_NUM[info.world] = code;
}

// --- Sprite Loader ---
const SPRITES = {
  run: null,       // sprite sheet: 8 frames of gallop cycle
  idle: null,      // single frame: standing pose
  fall: null,      // single frame: airborne/jump pose
  hoopClear: null,  // sprite sheet: 6 frames of hoop clear celebration
  growWings: null,  // sprite sheet: 3 frames of wing transformation
  jumpWings: null,  // sprite sheet: 4 frames of winged jump/flight
  fly: null,         // sprite sheet: 5 frames of fly wing flap
  jump: null,        // sprite sheet: 7 frames of jump arc (no wings)
  standPoop: null,   // sprite sheet: 6 frames of standing poop animation
  poop: null,        // sprite sheet: 4 frames of poop projectile
  gnome: null,       // sprite sheet: 5 frames of gnome walk cycle
  runWings: null,    // sprite sheet: 7 frames of winged run cycle
  standPoopWings: null, // sprite sheet: 4 frames of winged standing poop
  idleWings: null,   // single frame: standing with wings
  bossIdle: null,    // sprite sheet: 4 frames of boss idle/taunt
  bossRoar: null,    // sprite sheet: 4 frames of boss roar
  bossCharge: null,  // sprite sheet: 10 frames of boss charge/run
  bossStunned: null, // sprite sheet: 3 frames of boss stunned
  mermicorn: null,   // sprite sheet: 5 frames of mermicorn swim cycle
  mermicornVictory: null, // sprite sheet: 3 frames of mermicorn hoop celebration
  squidTaunt: null,  // sprite sheet: 3 frames of squid boss idle/taunt
  squidMove: null,   // sprite sheet: 4 frames of squid boss movement
  squidHurt: null,   // single frame: squid boss stunned
  narwhal: null,     // sprite sheet: 5 frames of narwhal swim (enemy, unused currently)
  fishSprite: null,  // sprite sheet: 4 frames of fish swim
  jellyfishSprite: null, // sprite sheet: 6 frames of jellyfish pulse
  kittycornStand: null,  // single frame: kittycorn standing pose
  kittycornRun: null,    // sprite sheet: 7 frames of kittycorn gallop
  kittycornJump: null,   // sprite sheet: 4 frames of kittycorn airborne
  kittycornStandPoop: null, // single frame: kittycorn standing poop
  kittycornCelebrate: null, // sprite sheet: 3 frames of kittycorn hoop celebration
  hawk: null,            // sprite sheet: 5 frames of hawk flight
  hawkBoss: null,        // sprite sheet: 8 frames of hawk boss (5 fly + 3 hurt)
  pixicorn: null,        // sprite sheet: 6 frames of pixicorn (3 fly + 2 hover + 1 victory)
  mousicorn: null,       // sprite sheet: 8 frames of mousicorn (6 run + 1 poop + 1 jump)
};
let spritesLoaded = false;
let spritesTotal = 0;
let spritesCount = 0;

function loadSprite(key, src) {
  spritesTotal++;
  const img = new Image();
  img.onload = () => {
    SPRITES[key] = img;
    spritesCount++;
    if (spritesCount >= spritesTotal) spritesLoaded = true;
  };
  img.onerror = () => {
    console.warn("Failed to load sprite:", src, "- using procedural fallback");
    spritesCount++;
    if (spritesCount >= spritesTotal) spritesLoaded = true;
  };
  img.src = src;
}

// Kick off loading immediately
loadSprite("run",  "sprites/unicorn_run.png");
loadSprite("idle", "sprites/unicorn_idle.png");
loadSprite("fall", "sprites/unicorn_fall.png");
loadSprite("hoopClear", "sprites/unicorn_hoop_clear.png");
loadSprite("growWings", "sprites/unicorn_grow_wings.png");
loadSprite("jumpWings", "sprites/unicorn_jump_wings.png");
loadSprite("fly", "sprites/fly.png");
loadSprite("jump", "sprites/unicorn_jump.png");
loadSprite("standPoop", "sprites/unicorn_stand_poop.png");
loadSprite("poop", "sprites/poop.png");
loadSprite("gnome", "sprites/gnome.png");
loadSprite("runWings", "sprites/unicorn_run_wings.png");
loadSprite("standPoopWings", "sprites/unicorn_stand_poop_wings.png");
loadSprite("idleWings", "sprites/unicorn_idle_wings.png");
loadSprite("bossIdle", "sprites/boss_idle_taunt.png");
loadSprite("bossRoar", "sprites/boss_roar.png");
loadSprite("bossCharge", "sprites/boss_charge.png");
loadSprite("bossStunned", "sprites/boss_stunned.png");
loadSprite("mermicorn", "sprites/unicorn_mermicorn.png");
loadSprite("mermicornVictory", "sprites/mermicorn_victory.png");
loadSprite("squidTaunt", "sprites/squid_taunt.png");
loadSprite("squidMove", "sprites/squid_move.png");
loadSprite("squidHurt", "sprites/squid_hurt.png");
loadSprite("narwhal", "sprites/narwhal.png");
loadSprite("fishSprite", "sprites/fish_sprite.png");
loadSprite("jellyfishSprite", "sprites/jellyfish_sprite.png");
loadSprite("kittycornStand", "sprites/kittycorn_stand.png");
loadSprite("kittycornRun", "sprites/kittycorn_run.png");
loadSprite("kittycornJump", "sprites/kittycorn_jump.png");
loadSprite("kittycornStandPoop", "sprites/kittycorn_stand_poop.png");
loadSprite("kittycornCelebrate", "sprites/kittycorn_celebrate.png");
loadSprite("hawk", "sprites/hawk.png");
loadSprite("hawkBoss", "sprites/hawk_boss.png");
loadSprite("pixicorn", "sprites/Pixicorn.png");
loadSprite("mousicorn", "sprites/mousicorn.png");
loadSprite("ratKingBoss", "sprites/rat_king_boss.png");
loadSprite("flowerBoss", "sprites/flowerboss.png");
loadSprite("shadowQueenBoss", "sprites/shadow_queen_boss.png");
loadSprite("pharaohCatBoss", "sprites/pharoah_cat_boss.png");
loadSprite("dragonBoss", "sprites/dragon_boss.png");

// Tile types
const TILE_EMPTY = 0;
const TILE_GRASS = 1;  // top of ground (has grass visual)
const TILE_DIRT  = 2;  // solid dirt below grass

// Game states
const STATE_TITLE    = 0;
const STATE_PLAYING  = 1;
const STATE_DYING    = 2;
const STATE_COMPLETE = 3;
const STATE_LEVEL_INTRO = 4;
const STATE_CODE_ENTRY = 5;
const STATE_PAUSED = 6;

// ============================================================
//  SECTION 2: CORE ENGINE
// ============================================================

// --- Seeded RNG ---
class SeededRNG {
  constructor(seed) { this.s = seed; }
  next() {
    this.s = (this.s * 16807 + 0) % 2147483647;
    return (this.s - 1) / 2147483646;
  }
  nextInt(min, max) { return min + Math.floor(this.next() * (max - min + 1)); }
  nextFloat(min, max) { return min + this.next() * (max - min); }
}

// --- Input Manager ---
class InputManager {
  constructor() {
    this.keys = {};       // keyboard state (keydown/keyup event-driven)
    this._gpKeys = {};    // gamepad state (rebuilt from scratch each frame)
    this._combined = {};  // merged keyboard+gamepad (rebuilt each update)
    this.justPressed = {};
    this._prev = {};
    this.lastLetter = ""; // for code entry (A-Z)
    // Gamepad state
    this.gamepadIndex = null;
    this.anyGamepadPressed = false;
    // Konami Code state
    this._konamiSeq = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","KeyB","KeyA","Enter"];
    this._konamiIndex = 0;
    this._konamiDone = false;
    this.konamiJustCompleted = false;

    window.addEventListener("keydown", e => {
      e.preventDefault();
      this.keys[e.code] = true;
      // Capture letter keys for code entry
      if (e.code.startsWith("Key") && e.code.length === 4) {
        this.lastLetter = e.code[3]; // "KeyA" → "A"
      }
      if (e.code === "Backspace") this.lastLetter = "BACKSPACE";
      if (e.code === "Escape") this.lastLetter = "ESCAPE";
    });
    window.addEventListener("keyup", e => {
      e.preventDefault();
      this.keys[e.code] = false;
    });
    window.addEventListener("gamepadconnected", e => {
      this.gamepadIndex = e.gamepad.index;
    });
    window.addEventListener("gamepaddisconnected", e => {
      if (this.gamepadIndex === e.gamepad.index) this.gamepadIndex = null;
    });
  }
  pollGamepad() {
    // Rebuild gamepad state from scratch each frame (no stale keys)
    this._gpKeys = {};
    this.anyGamepadPressed = false;
    if (this.gamepadIndex === null) return;
    const gp = navigator.getGamepads()[this.gamepadIndex];
    if (!gp) return;
    // D-pad via axes (axes[0] = horizontal, axes[1] = vertical)
    const ax0 = gp.axes[0] || 0;
    const ax1 = gp.axes[1] || 0;
    if (ax0 < -0.5) this._gpKeys["ArrowLeft"]  = true;
    if (ax0 > 0.5)  this._gpKeys["ArrowRight"] = true;
    if (ax1 < -0.5) this._gpKeys["ArrowUp"]    = true;
    if (ax1 > 0.5)  this._gpKeys["ArrowDown"]  = true;
    // D-pad via standard buttons 12-15 (override if pressed)
    if (gp.buttons.length > 15) {
      if (gp.buttons[12].pressed) this._gpKeys["ArrowUp"]    = true;
      if (gp.buttons[13].pressed) this._gpKeys["ArrowDown"]  = true;
      if (gp.buttons[14].pressed) this._gpKeys["ArrowLeft"]  = true;
      if (gp.buttons[15].pressed) this._gpKeys["ArrowRight"] = true;
    }
    // Face buttons — NES USB: buttons[0]=B, buttons[1]=A
    // Some controllers with "standard" mapping swap A/B
    const aBtn = gp.mapping === "standard" ? 0 : 1;
    const bBtn = gp.mapping === "standard" ? 1 : 0;
    const aBtnPressed = gp.buttons[aBtn] && gp.buttons[aBtn].pressed;
    const bBtnPressed = gp.buttons[bBtn] && gp.buttons[bBtn].pressed;
    // A → Jump (Space)
    if (aBtnPressed) this._gpKeys["Space"] = true;
    // B → Poop when Down held (KeyP), otherwise Shoot (ShiftLeft)
    if (this._gpKeys["ArrowDown"] && bBtnPressed) {
      this._gpKeys["KeyP"] = true;
    } else if (bBtnPressed) {
      this._gpKeys["ShiftLeft"] = true;
    }
    // Raw face buttons for menus/konami (don't conflict with gameplay keys)
    if (aBtnPressed) this._gpKeys["_gpA"] = true;
    if (bBtnPressed) this._gpKeys["_gpB"] = true;
    // Select → Code entry (KeyC)
    if (gp.buttons[8] && gp.buttons[8].pressed) this._gpKeys["KeyC"] = true;
    // Start → Enter
    if (gp.buttons[9] && gp.buttons[9].pressed) this._gpKeys["Enter"] = true;
    // Track any button press for audio init
    for (let i = 0; i < gp.buttons.length; i++) {
      if (gp.buttons[i].pressed) { this.anyGamepadPressed = true; break; }
    }
  }
  update() {
    this.pollGamepad();
    this.konamiJustCompleted = false;
    // Merge keyboard + gamepad into combined state
    const combined = {};
    for (const k in this.keys) if (this.keys[k]) combined[k] = true;
    for (const k in this._gpKeys) if (this._gpKeys[k]) combined[k] = true;
    // Compute just-pressed from combined vs previous combined
    for (const k in combined) {
      this.justPressed[k] = combined[k] && !this._prev[k];
    }
    // Clear stale justPressed for keys no longer in combined
    for (const k in this._prev) {
      if (!combined[k]) this.justPressed[k] = false;
    }
    // Konami code detection (on just-pressed directional/button inputs)
    // Accepts gamepad A/B (_gpA/_gpB) as alternatives to KeyA/KeyB
    if (!this._konamiDone) {
      const expected = this._konamiSeq[this._konamiIndex];
      const konamiMatch = (k, exp) => {
        if (k === exp) return true;
        if (exp === "KeyA" && k === "_gpA") return true;
        if (exp === "KeyB" && k === "_gpB") return true;
        return false;
      };
      for (const k in this.justPressed) {
        if (!this.justPressed[k]) continue;
        if (konamiMatch(k, expected)) {
          this._konamiIndex++;
          if (this._konamiIndex >= this._konamiSeq.length) {
            this._konamiDone = true;
            this.konamiJustCompleted = true;
          }
          break;
        }
        // Wrong input — only reset if it's a konami-relevant key
        if (this._konamiSeq.indexOf(k) !== -1) {
          this._konamiIndex = (k === this._konamiSeq[0]) ? 1 : 0;
        }
      }
    }
    this._combined = combined;
    this._prev = Object.assign({}, combined);
  }
  consumeLetter() {
    const l = this.lastLetter;
    this.lastLetter = "";
    return l;
  }
  held(code) { return !!this._combined[code]; }
  pressed(code) { return !!this.justPressed[code]; }
  get left() { return this.held("ArrowLeft") || this.held("KeyA"); }
  get right() { return this.held("ArrowRight") || this.held("KeyD"); }
  get jump() { return this.pressed("Space") || this.pressed("ArrowUp") || this.pressed("KeyW"); }
  get jumpHeld() { return this.held("Space") || this.held("ArrowUp") || this.held("KeyW"); }
  get down() { return this.held("ArrowDown") || this.held("KeyS"); }
  get enter() { return this.pressed("Enter") || this.pressed("Space"); }
  get poop() { return this.held("KeyP") || this.held("ShiftRight") || this.held("KeyX"); }
  get shoot() { return this.pressed("KeyF") || this.pressed("ShiftLeft"); }
}

// --- Audio Manager (WebAudio API) ---
class AudioManager {
  constructor() {
    this.ctx = null;
    this.masterGain = null;
    this.sfxGain = null;
    this.musicGain = null;
    this.initialized = false;
    this.buffers = {};       // name → AudioBuffer cache
    this._currentMusic = null; // { source, gain, name }
    this._musicFading = null;  // outgoing track during crossfade
    this._preloaded = false;
  }
  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = 0.4;
      this.masterGain.connect(this.ctx.destination);
      this.sfxGain = this.ctx.createGain();
      this.sfxGain.gain.value = 0.6;
      this.sfxGain.connect(this.masterGain);
      this.musicGain = this.ctx.createGain();
      this.musicGain.gain.value = 0.35;
      this.musicGain.connect(this.masterGain);
      this.initialized = true;
      this.preloadAll();
    } catch(e) { console.warn("WebAudio unavailable:", e); }
  }
  preloadAll() {
    if (this._preloaded) return;
    this._preloaded = true;
    const files = [
      "jump.wav","triple_jump.wav","star_collect.wav","hoop_clear.wav",
      "shrink.wav","shrink_2.wav","shrink_3.wav",
      "poop.wav","poop_2.wav","grow_big.wav","extra_life.wav",
      "death.wav","fall_death.wav","flower_bloom.wav","rainbow_shot.wav",
      "level_complete.wav","title_screen.wav",
      "game_complete.mp3","music_boss.mp3","music_boss_alt.mp3",
      "music_world1.mp3","music_world2.mp3","music_world2_alt.mp3",
      "music_world3.mp3","music_world4.mp3","music_world5.mp3",
      "music_world6.mp3","music_world6_alt.mp3",
      "music_world7.mp3","music_world8.mp3","music_world8_alt.mp3"
    ];
    for (const f of files) {
      const name = f.replace(/\.(wav|mp3)$/, "");
      fetch("sounds/" + f).then(r => r.arrayBuffer()).then(buf => {
        return this.ctx.decodeAudioData(buf);
      }).then(decoded => {
        this.buffers[name] = decoded;
      }).catch(() => {});
    }
  }
  playSample(name, vol) {
    if (!this.initialized || !this.buffers[name]) return;
    const src = this.ctx.createBufferSource();
    src.buffer = this.buffers[name];
    const gain = this.ctx.createGain();
    gain.gain.value = vol !== undefined ? vol : 1.0;
    src.connect(gain);
    gain.connect(this.sfxGain);
    src.start(0);
  }
  playMusic(name, loop) {
    if (!this.initialized) return;
    // No-op if same track already playing
    if (this._currentMusic && this._currentMusic.name === name) return;
    // If buffer not loaded yet, defer
    if (!this.buffers[name]) {
      this._pendingMusic = { name: name, loop: !!loop };
      return;
    }
    // Crossfade out old track
    if (this._currentMusic) {
      const old = this._currentMusic;
      old.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
      setTimeout(() => { try { old.source.stop(); } catch(e){} }, 600);
      this._currentMusic = null;
    }
    // Start new track
    const src = this.ctx.createBufferSource();
    src.buffer = this.buffers[name];
    src.loop = !!loop;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(1.0, this.ctx.currentTime + 0.5);
    src.connect(gain);
    gain.connect(this.musicGain);
    src.start(0);
    this._currentMusic = { source: src, gain: gain, name: name };
    this._pendingMusic = null;
  }
  stopMusic(fadeTime) {
    if (!this._currentMusic) return;
    const fade = fadeTime !== undefined ? fadeTime : 0.5;
    const old = this._currentMusic;
    old.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + fade);
    setTimeout(() => { try { old.source.stop(); } catch(e){} }, (fade + 0.1) * 1000);
    this._currentMusic = null;
  }
  checkPendingMusic() {
    if (this._pendingMusic && this.buffers[this._pendingMusic.name]) {
      this.playMusic(this._pendingMusic.name, this._pendingMusic.loop);
    }
  }
  getMusicForLevel(def) {
    if (def.isBoss) {
      // Alternate boss music for worlds 5+
      return def.world >= 5 ? "music_boss_alt" : "music_boss";
    }
    switch (def.world) {
      case 1: return "music_world1";
      case 2: return def.level >= 3 ? "music_world2_alt" : "music_world2";
      case 3: return "music_world3";
      case 4: return "music_world4";
      case 5: return "music_world5";
      case 6: return def.level >= 3 ? "music_world6_alt" : "music_world6";
      case 7: return "music_world7";
      case 8: return def.level >= 3 ? "music_world8_alt" : "music_world8";
      default: return "music_world1";
    }
  }
  // Play an oscillator-based SFX (fallback / subtle sounds)
  playSFX(type, freq, duration, freqEnd, vol) {
    if (!this.initialized) return;
    const ctx = this.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type || "square";
    osc.frequency.setValueAtTime(freq, ctx.currentTime);
    if (freqEnd) osc.frequency.linearRampToValueAtTime(freqEnd, ctx.currentTime + duration);
    gain.gain.setValueAtTime(vol || 0.3, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.sfxGain);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + duration);
  }
  // --- SFX methods (WAV-first + oscillator fallback) ---
  jumpSound() {
    if (this.buffers["jump"]) { this.playSample("jump", 0.7); }
    else { this.playSFX("square", 300, 0.15, 600, 0.25); }
  }
  doubleJumpSound() {
    if (this.buffers["triple_jump"]) { this.playSample("triple_jump", 0.7); }
    else { this.playSFX("square", 400, 0.18, 800, 0.2); }
  }
  collectSound() {
    if (this.buffers["star_collect"]) { this.playSample("star_collect", 0.8); }
    else {
      this.playSFX("sine", 800, 0.08, 1200, 0.3);
      setTimeout(() => this.playSFX("sine", 1200, 0.12, 1600, 0.25), 80);
    }
  }
  hurtSound() {
    if (this.buffers["shrink"]) {
      const picks = ["shrink","shrink_2","shrink_3"].filter(n => this.buffers[n]);
      if (picks.length > 0) { this.playSample(picks[Math.floor(Math.random() * picks.length)], 0.8); return; }
    }
    this.playSFX("sawtooth", 200, 0.3, 80, 0.3);
  }
  hoopSound() {
    if (this.buffers["hoop_clear"]) { this.playSample("hoop_clear", 0.9); }
    else {
      this.playSFX("sine", 523, 0.12, 523, 0.3);
      setTimeout(() => this.playSFX("sine", 659, 0.12, 659, 0.3), 120);
      setTimeout(() => this.playSFX("sine", 784, 0.12, 784, 0.3), 240);
      setTimeout(() => this.playSFX("sine", 1047, 0.25, 1047, 0.35), 360);
    }
  }
  landSound() { this.playSFX("triangle", 100, 0.1, 60, 0.15); }
  menuSelect() { this.playSFX("square", 600, 0.08, 900, 0.2); }
  // --- New SFX methods ---
  poopSound() { this.playSample("poop", 0.7); }
  growBigSound() { this.playSample("grow_big", 0.9); }
  extraLifeSound() { this.playSample("extra_life", 1.0); }
  deathSound() { this.playSample("death", 0.9); }
  fallDeathSound() { this.playSample("fall_death", 0.9); }
  flowerBloomSound() { this.playSample("flower_bloom", 0.8); }
  rainbowShotSound() { this.playSample("rainbow_shot", 0.7); }
  levelCompleteSound() { this.playSample("level_complete", 1.0); }
  // --- Per-form poop sounds (synthesized) ---
  mermaidPoopSound() {
    if (!this.initialized) return;
    // Bubbly underwater — 4 staggered sine pops
    for (let i = 0; i < 4; i++) {
      setTimeout(() => {
        this.playSFX("sine", 400 + Math.random() * 200, 0.08, 200 + Math.random() * 100, 0.2);
      }, i * 60);
    }
  }
  kittycornPoopSound() {
    if (!this.initialized) return;
    // Cute squeaky — 3 high triangle chirps
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        this.playSFX("triangle", 1200 + i * 200, 0.06, 1800 + i * 200, 0.2);
      }, i * 70);
    }
  }
  pixicornPoopSound() {
    if (!this.initialized) return;
    // Sparkly arpeggio — 5 ascending sine notes
    const notes = [523, 659, 784, 988, 1175];
    for (let i = 0; i < notes.length; i++) {
      setTimeout(() => {
        this.playSFX("sine", notes[i], 0.1, notes[i] * 1.05, 0.2);
      }, i * 50);
    }
  }
  mousicornPoopSound() {
    if (!this.initialized) return;
    // Tiny squeak — 2 very high square chirps
    this.playSFX("square", 2400, 0.04, 3200, 0.15);
    setTimeout(() => this.playSFX("square", 2800, 0.05, 3600, 0.15), 60);
  }
  // Form-aware poop dispatcher
  formPoopSound(player) {
    if (player.isMermaid) { this.mermaidPoopSound(); }
    else if (player.isKittycorn) { this.kittycornPoopSound(); }
    else if (player.isPixicorn) { this.pixicornPoopSound(); }
    else if (player.isMouseicorn) { this.mousicornPoopSound(); }
    else { this.poopSound(); }
  }
}

// --- Camera ---
class Camera {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.targetX = 0;
    this.targetY = 0;
    this.shakeX = 0;
    this.shakeY = 0;
    this.shakeMag = 0;
    this.deadZoneX = CFG.CAM_DEAD_X;
    this.deadZoneY = CFG.CAM_DEAD_Y;
    this.maxX = 0;
    this.maxY = 0;
  }
  setBounds(levelW, levelH) {
    this.maxX = Math.max(0, levelW - CFG.W);
    this.maxY = Math.max(0, levelH - CFG.H);
  }
  follow(px, py, facing, dt) {
    // Target with look-ahead
    const lookAhead = facing * CFG.CAM_LOOK_AHEAD;
    const desiredX = px - CFG.W * 0.4 + lookAhead;
    const desiredY = py - CFG.H * 0.5;

    // Dead zone: only move target when player exceeds dead zone
    const dx = desiredX - this.targetX;
    const dy = desiredY - this.targetY;
    if (Math.abs(dx) > this.deadZoneX) {
      this.targetX += (dx - Math.sign(dx) * this.deadZoneX);
    }
    if (Math.abs(dy) > this.deadZoneY) {
      this.targetY += (dy - Math.sign(dy) * this.deadZoneY);
    }

    // Smooth lerp
    this.x += (this.targetX - this.x) * CFG.CAM_LERP;
    this.y += (this.targetY - this.y) * CFG.CAM_LERP;

    // Clamp
    this.x = Math.max(0, Math.min(this.x, this.maxX));
    this.y = Math.max(0, Math.min(this.y, this.maxY));

    // Shake
    if (this.shakeMag > 0.5) {
      this.shakeX = (Math.random() - 0.5) * this.shakeMag;
      this.shakeY = (Math.random() - 0.5) * this.shakeMag;
      this.shakeMag *= CFG.SHAKE_DECAY;
    } else {
      this.shakeX = 0;
      this.shakeY = 0;
      this.shakeMag = 0;
    }
  }
  shake(magnitude) {
    this.shakeMag = Math.max(this.shakeMag, magnitude);
  }
  get scrollX() { return Math.round(this.x + this.shakeX); }
  get scrollY() { return Math.round(this.y + this.shakeY); }
}

// --- Particle System ---
const PARTICLE_DUST    = 0;
const PARTICLE_SPARKLE = 1;
const PARTICLE_TEXT    = 2;
const PARTICLE_BURST   = 3;

class Particle {
  constructor() { this.alive = false; }
}

class ParticleSystem {
  constructor(maxParticles) {
    this.pool = [];
    for (let i = 0; i < maxParticles; i++) this.pool.push(new Particle());
  }
  emit(type, x, y, opts) {
    const p = this.pool.find(p => !p.alive);
    if (!p) return;
    p.alive = true;
    p.type = type;
    p.x = x; p.y = y;
    p.vx = opts.vx || 0;
    p.vy = opts.vy || 0;
    p.life = opts.life || 0.5;
    p.maxLife = p.life;
    p.size = opts.size || 3;
    p.color = opts.color || "#fff";
    p.text = opts.text || "";
    p.gravity = opts.gravity || 0;
    p.friction = opts.friction || 1;
    p.shrink = opts.shrink !== undefined ? opts.shrink : true;
    p.alpha = 1;
    return p;
  }
  // Emit a preset burst
  dustBurst(x, y, count) {
    for (let i = 0; i < count; i++) {
      this.emit(PARTICLE_DUST, x + (Math.random()-0.5)*10, y, {
        vx: (Math.random()-0.5) * 2,
        vy: -Math.random() * 2 - 0.5,
        life: 0.3 + Math.random() * 0.2,
        size: 2 + Math.random() * 2,
        color: "#c8b090",
        gravity: 0.05,
        friction: 0.97,
      });
    }
  }
  sparkleBurst(x, y, count) {
    const colors = ["#ffff44","#ffaa00","#ffffff","#ff88ff","#88ffff"];
    for (let i = 0; i < count; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = Math.random() * 3 + 1;
      this.emit(PARTICLE_SPARKLE, x, y, {
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd,
        life: 0.4 + Math.random() * 0.3,
        size: 2 + Math.random() * 2,
        color: colors[Math.floor(Math.random() * colors.length)],
        gravity: -0.02,
        friction: 0.96,
      });
    }
  }
  impactBurst(x, y, count, color) {
    for (let i = 0; i < count; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = Math.random() * 4 + 1;
      this.emit(PARTICLE_BURST, x, y, {
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd,
        life: 0.2 + Math.random() * 0.2,
        size: 2 + Math.random() * 3,
        color: color || "#ff4444",
        gravity: 0.1,
        friction: 0.94,
      });
    }
  }
  floatingText(x, y, text, color) {
    this.emit(PARTICLE_TEXT, x, y, {
      vx: 0, vy: -1.5,
      life: 0.8,
      color: color || "#ffff44",
      text: text,
      gravity: 0,
      friction: 0.98,
    });
  }
  update(dt) {
    for (const p of this.pool) {
      if (!p.alive) continue;
      p.life -= dt;
      if (p.life <= 0) { p.alive = false; continue; }
      p.vy += p.gravity;
      p.vx *= p.friction;
      p.vy *= p.friction;
      p.x += p.vx;
      p.y += p.vy;
      p.alpha = Math.min(1, p.life / (p.maxLife * 0.3));
      if (p.shrink) p.size *= 0.995;
    }
  }
  draw(ctx, camX, camY) {
    for (const p of this.pool) {
      if (!p.alive) continue;
      const sx = p.x - camX;
      const sy = p.y - camY;
      if (sx < -20 || sx > CFG.W+20 || sy < -20 || sy > CFG.H+20) continue;

      ctx.globalAlpha = p.alpha;
      if (p.type === PARTICLE_TEXT) {
        ctx.font = "bold 10px monospace";
        ctx.fillStyle = p.color;
        ctx.textAlign = "center";
        ctx.fillText(p.text, sx, sy);
      } else if (p.type === PARTICLE_SPARKLE) {
        // Diamond shape
        ctx.fillStyle = p.color;
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(Math.PI/4);
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        ctx.restore();
      } else {
        // Dust or burst - circle
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(sx, sy, p.size, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }
}

// ============================================================
//  SECTION 3: ENTITIES
// ============================================================

// --- Base Entity ---
class Entity {
  constructor(x, y, w, h) {
    this.x = x; this.y = y;
    this.w = w; this.h = h;
    this.vx = 0; this.vy = 0;
    this.alive = true;
  }
  get cx() { return this.x + this.w/2; }
  get cy() { return this.y + this.h/2; }
  get left() { return this.x; }
  get right() { return this.x + this.w; }
  get top() { return this.y; }
  get bottom() { return this.y + this.h; }
  overlaps(other) {
    return this.right > other.left && this.left < other.right &&
           this.bottom > other.top && this.top < other.bottom;
  }
  overlapsPad(other, px, py) {
    return this.right-px > other.left && this.left+px < other.right &&
           this.bottom-py > other.top && this.top+py < other.bottom;
  }
}

// --- Player ---
class Player extends Entity {
  constructor(x, y) {
    super(x, y, CFG.PLAYER_W, CFG.PLAYER_H);
    this.facing = 1;
    this.onGround = false;
    this.wasOnGround = false;
    this.canDoubleJump = false;
    this.canTripleJump = false;
    this.hasWings = false;
    this.growWingsTimer = 0;  // > 0 means transformation is playing
    this.coyoteTimer = 0;
    this.jumpBufferTimer = 0;
    this.speedX = 0; // smoothed horizontal speed
    this.animState = "idle"; // idle, run, jump, fall, growWings, hoopClear
    this.animFrame = 0;
    this.animTimer = 0;
    this.invTimer = 0;
    this.stars = 0;
    this.lives = CFG.LIVES;
    this.landImpact = 0; // for squash/stretch and shake
    this.squash = 0;
    this.runDust = 0;
    this.poopTimer = 0;        // > 0 = pooping animation playing
    this.poopCooldown = 0;     // prevents poop spam
    this.isStandPooping = false; // true = standing poop (detailed), false = quick poop
    this.jumpType = "first";   // "first", "double", "triple" - for frame selection
    this.flowersRevived = 0;    // total flowers (toward 1UP at 20)
    this.flowersForRainbow = 0; // flowers toward next rainbow (resets on damage)
    this.isBig = false;         // hay bale power-up (like Mario mushroom)
    this.hasRainbow = false;    // rainbow horn shooter (5 flowers)
    this.shootCooldown = 0;     // cooldown between rainbow shots
    this.isMermaid = false;     // mermaid form (frog mario style)
    this.mermaidTransformTimer = 0; // > 0 = transformation anim playing
    this.isKittycorn = false;  // kittycorn form (boosted double jump)
    this.kittycornTransformTimer = 0; // > 0 = transformation anim playing
    this.isPixicorn = false;
    this.pixicornTransformTimer = 0;
    this.isMouseicorn = false;
    this.mousicornTransformTimer = 0;
    this.isUnderwater = false;  // set by level — modifies physics
    this._deathType = null;     // "fall" or "contact" — for death sound selection
  }
  collectWings(audio, particles) {
    this.hasWings = true;
    this.canTripleJump = true;
    this.growWingsTimer = CFG.GROW_WINGS_DURATION;
    this.animState = "growWings";
    this.animFrame = 0;
    this.animTimer = 0;
    audio.collectSound();
    particles.sparkleBurst(this.cx, this.cy, 15);
    particles.floatingText(this.cx, this.cy - 20, "WINGS!", "#cc88ff");
  }
  collectMermaid(particles, audio) {
    this.isMermaid = true;
    this.mermaidTransformTimer = CFG.MERMAID_TRANSFORM_DURATION;
    this.animState = "mermaidTransform";
    this.animFrame = 0;
    this.animTimer = 0;
    audio.collectSound();
    particles.sparkleBurst(this.cx, this.cy, 20);
    particles.floatingText(this.cx, this.cy - 20, "MERMICORN!", "#ff44aa");
    // Rainbow sparkle burst
    const rc = ["#ff0044","#ff8800","#ffdd00","#00dd44","#0088ff","#8844ff"];
    for (let i = 0; i < 12; i++) {
      particles.emit(0, this.cx, this.cy, {
        vx: (Math.random()-0.5) * 3, vy: (Math.random()-0.5) * 3,
        life: 0.6, size: 3, color: rc[i % rc.length], gravity: -0.02, friction: 0.95
      });
    }
  }
  collectKittycorn(particles, audio) {
    this.isPixicorn = false;
    this.isMouseicorn = false;
    this.isKittycorn = true;
    this.kittycornTransformTimer = CFG.KITTYCORN_TRANSFORM_DURATION;
    this.animState = "kittycornTransform";
    this.animFrame = 0;
    this.animTimer = 0;
    audio.collectSound();
    particles.sparkleBurst(this.cx, this.cy, 20);
    particles.floatingText(this.cx, this.cy - 20, "KITTYCORN!", "#ff88cc");
    const rc = ["#ff88cc","#ffaadd","#ff44aa","#cc66ff","#ff66bb","#ffccee"];
    for (let i = 0; i < 12; i++) {
      particles.emit(0, this.cx, this.cy, {
        vx: (Math.random()-0.5) * 3, vy: (Math.random()-0.5) * 3,
        life: 0.6, size: 3, color: rc[i % rc.length], gravity: -0.02, friction: 0.95
      });
    }
  }
  collectPixicorn(particles, audio) {
    this.isKittycorn = false;
    this.isMouseicorn = false;
    this.isPixicorn = true;
    this.pixicornTransformTimer = CFG.PIXICORN_TRANSFORM_DURATION;
    this.animState = "pixicornTransform";
    this.animFrame = 0;
    this.animTimer = 0;
    audio.collectSound();
    particles.sparkleBurst(this.cx, this.cy, 20);
    particles.floatingText(this.cx, this.cy - 20, "PIXICORN!", "#cc88ff");
    const rc = ["#cc88ff","#aa66dd","#8844bb","#bb66ee","#dd88ff","#9955cc"];
    for (let i = 0; i < 12; i++) {
      particles.emit(0, this.cx, this.cy, {
        vx: (Math.random()-0.5) * 3, vy: (Math.random()-0.5) * 3,
        life: 0.6, size: 3, color: rc[i % rc.length], gravity: -0.02, friction: 0.95
      });
    }
  }
  collectMouseicorn(particles, audio) {
    this.isKittycorn = false;
    this.isPixicorn = false;
    this.isMouseicorn = true;
    this.mousicornTransformTimer = CFG.MOUSICORN_TRANSFORM_DURATION;
    this.animState = "mousicornTransform";
    this.animFrame = 0;
    this.animTimer = 0;
    audio.collectSound();
    particles.sparkleBurst(this.cx, this.cy, 20);
    particles.floatingText(this.cx, this.cy - 20, "MOUSICORN!", "#aa8866");
    const rc = ["#aa8866","#cc9977","#886644","#bbaa88","#997755","#ddbb99"];
    for (let i = 0; i < 12; i++) {
      particles.emit(0, this.cx, this.cy, {
        vx: (Math.random()-0.5) * 3, vy: (Math.random()-0.5) * 3,
        life: 0.6, size: 3, color: rc[i % rc.length], gravity: -0.02, friction: 0.95
      });
    }
  }
  update(dt, level, input, audio, particles, camera) {
    const prevVY = this.vy;
    this.wasOnGround = this.onGround;

    // Grow wings transformation (freezes player briefly)
    if (this.growWingsTimer > 0) {
      this.growWingsTimer -= dt;
      this.animTimer += dt;
      // Advance through 3 grow_wings frames
      const frameDur = CFG.GROW_WINGS_DURATION / CFG.SPRITE_GROW_WINGS_FRAMES;
      this.animFrame = Math.min(CFG.SPRITE_GROW_WINGS_FRAMES - 1,
        Math.floor(this.animTimer / frameDur));
      if (this.growWingsTimer <= 0) {
        this.animState = "idle";
        this.animFrame = 0;
        this.animTimer = 0;
      }
      return; // freeze player during transformation
    }

    // Mermaid transformation (freezes player briefly)
    if (this.mermaidTransformTimer > 0) {
      this.mermaidTransformTimer -= dt;
      this.animTimer += dt;
      if (this.mermaidTransformTimer <= 0) {
        this.animState = "idle";
        this.animFrame = 0;
        this.animTimer = 0;
      }
      return; // freeze player during transformation
    }

    // Kittycorn transformation (freezes player briefly)
    if (this.kittycornTransformTimer > 0) {
      this.kittycornTransformTimer -= dt;
      this.animTimer += dt;
      if (this.kittycornTransformTimer <= 0) {
        this.animState = "idle";
        this.animFrame = 0;
        this.animTimer = 0;
      }
      return; // freeze player during transformation
    }

    // Pixicorn transformation (freezes player briefly)
    if (this.pixicornTransformTimer > 0) {
      this.pixicornTransformTimer -= dt;
      this.animTimer += dt;
      if (this.pixicornTransformTimer <= 0) {
        this.animState = "idle";
        this.animFrame = 0;
        this.animTimer = 0;
      }
      return; // freeze player during transformation
    }

    // Mousicorn transformation (freezes player briefly)
    if (this.mousicornTransformTimer > 0) {
      this.mousicornTransformTimer -= dt;
      this.animTimer += dt;
      if (this.mousicornTransformTimer <= 0) {
        this.animState = "idle";
        this.animFrame = 0;
        this.animTimer = 0;
      }
      return; // freeze player during transformation
    }

    // Dynamic hitbox: big = full, small = 75%, kittycorn = 50% (like Mario small/big)
    const isKittySmall = (this.isKittycorn && !this.isUnderwater);
    const isSmall = !this.isBig && !this.isMermaid && !this.isKittycorn && !this.isPixicorn && !this.isMouseicorn;
    const sizeMult = isKittySmall ? 0.5 : (isSmall ? 0.75 : 1.0);
    const targetW = Math.floor(CFG.PLAYER_W * sizeMult);
    const targetH = Math.floor(CFG.PLAYER_H * sizeMult);
    if (this.h !== targetH) {
      // Keep bottom anchored when hitbox changes size
      const oldBottom = this.y + this.h;
      this.h = targetH;
      this.y = oldBottom - this.h;
    }
    this.w = targetW;

    // Underwater physics adjustments (Mario-style sluggish / Frog Mario mermaid)
    const underwater = this.isUnderwater;
    const maxSpeed = underwater
      ? (this.isMermaid ? CFG.MERMAID_SPEED : CFG.UNDERWATER_SPEED)
      : (this.isMouseicorn ? CFG.MOUSICORN_SPEED : (this.isPixicorn ? CFG.PIXICORN_SPEED : (this.isKittycorn ? CFG.PLAYER_SPEED * 1.1 : CFG.PLAYER_SPEED)));
    const accel = underwater
      ? (this.isMermaid ? CFG.MERMAID_ACCEL : CFG.UNDERWATER_ACCEL)
      : CFG.PLAYER_ACCEL;
    const decel = underwater ? CFG.PLAYER_DECEL * 0.4 : CFG.PLAYER_DECEL;

    // Horizontal movement
    let moveDir = 0;
    if (input.left) moveDir = -1;
    if (input.right) moveDir = 1;

    if (moveDir !== 0) {
      this.speedX += moveDir * accel;
      this.speedX = Math.max(-maxSpeed, Math.min(maxSpeed, this.speedX));
      this.facing = moveDir;
    } else {
      // Decelerate
      if (this.speedX > 0) {
        this.speedX = Math.max(0, this.speedX - decel);
      } else if (this.speedX < 0) {
        this.speedX = Math.min(0, this.speedX + decel);
      }
    }
    this.vx = this.speedX;

    // Pixicorn free flight (on land only — underwater uses normal swim)
    if (this.isPixicorn && !underwater) {
      if (input.jumpHeld) this.vy = CFG.PIXICORN_ASCEND_SPEED;
      else if (input.down) this.vy = CFG.PIXICORN_DESCEND_SPEED;
      else { this.vy *= 0.8; if (Math.abs(this.vy) < 0.1) this.vy = 0; }
    }

    // Coyote time
    if (this.onGround) {
      this.coyoteTimer = CFG.COYOTE_TIME;
      this.canDoubleJump = this.hasWings && !underwater;   // wings disabled underwater
      this.canTripleJump = this.hasWings && !underwater;   // wings disabled underwater
    } else {
      this.coyoteTimer -= dt;
    }

    // Jump buffer
    if (input.jump) {
      this.jumpBufferTimer = CFG.JUMP_BUFFER;
    } else {
      this.jumpBufferTimer -= dt;
    }

    // Jump forces (modified for underwater + mermaid)
    const jumpForce = underwater
      ? (this.isMermaid ? CFG.MERMAID_JUMP_FORCE : CFG.UNDERWATER_JUMP_FORCE)
      : CFG.JUMP_FORCE;
    const baseDblJump = this.isKittycorn ? CFG.DOUBLE_JUMP_FORCE * 1.3 : CFG.DOUBLE_JUMP_FORCE;
    const dblJumpForce = underwater ? jumpForce * 0.85 : baseDblJump;

    // Jump (skip for pixicorn — uses free flight instead)
    if (this.isPixicorn && !underwater) {
      // Pixicorn doesn't use normal jump mechanics on land
    } else if (this.jumpBufferTimer > 0 && this.coyoteTimer > 0) {
      this.vy = jumpForce;
      this.onGround = false;
      this.coyoteTimer = 0;
      this.jumpBufferTimer = 0;
      this.jumpType = "first";
      audio.jumpSound();
      if (underwater) {
        // Bubble particles on swim kick off ground
        particles.emit(0, this.cx, this.bottom, {
          vx: (Math.random()-0.5) * 1, vy: 0.5,
          life: 0.5, size: 2, color: "rgba(150,200,255,0.6)", gravity: -0.08, friction: 0.97
        });
      }
    } else if (underwater && input.jump && !this.onGround) {
      // Underwater swim kicks — everyone can kick, mermaid is much stronger
      const kickMult = this.isMermaid ? 0.75 : 0.50;
      this.vy = jumpForce * kickMult;
      audio.jumpSound();
      particles.emit(0, this.cx, this.bottom, {
        vx: (Math.random()-0.5) * 1, vy: 0.5,
        life: 0.4, size: this.isMermaid ? 3 : 2,
        color: this.isMermaid ? "rgba(100,220,255,0.6)" : "rgba(150,200,255,0.4)",
        gravity: -0.06, friction: 0.97
      });
    } else if (input.jump && !this.onGround && this.canDoubleJump) {
      // Double jump (wings — land only, disabled underwater)
      this.vy = dblJumpForce;
      this.canDoubleJump = false;
      this.jumpType = "double";
      audio.doubleJumpSound();
      particles.sparkleBurst(this.cx, this.cy, 6);
    } else if (input.jump && !this.onGround && !this.canDoubleJump && this.canTripleJump) {
      // Triple jump (wings — land only, disabled underwater)
      this.vy = CFG.TRIPLE_JUMP_FORCE;
      this.canTripleJump = false;
      this.jumpType = "triple";
      audio.doubleJumpSound();
      particles.sparkleBurst(this.cx, this.cy, 10);
      particles.floatingText(this.cx, this.cy - 15, "WING BOOST!", "#cc88ff");
    }

    // Variable jump height — release jump button early for short hop
    if (!input.jumpHeld && this.vy < -2) {
      this.vy *= underwater ? 0.6 : 0.4;  // less cut underwater for floatier feel
    }

    // Poop (on land) / Fart bubbles (underwater)
    if (this.poopCooldown > 0) this.poopCooldown -= dt;
    if (input.poop && this.poopCooldown <= 0 && this.poopTimer <= 0) {
      if (underwater) {
        // Underwater fart: 3-4 rising bubbles (cosmetic only, no damage)
        this.poopCooldown = 0.8;
        audio.jumpSound(); // bubbly sound placeholder
        const bubbleCount = 3 + Math.floor(Math.random() * 2);
        for (let i = 0; i < bubbleCount; i++) {
          const bSize = 2 + i * 1.5; // smaller to larger
          const delay = i * 0.08;
          particles.emit(0,
            this.cx - this.facing * 10 + (Math.random()-0.5) * 6,
            this.bottom - 6,
            {
              vx: -this.facing * (0.3 + Math.random() * 0.3),
              vy: -(0.8 + i * 0.3 + Math.random() * 0.4),
              life: 0.8 + i * 0.15,
              size: bSize,
              color: `rgba(150,210,255,${0.5 - i * 0.08})`,
              gravity: -0.06, // floats up
              friction: 0.97
            }
          );
        }
        particles.floatingText(this.cx, this.cy - 10, "~blub~", "#88ccff");
      } else {
        this.isStandPooping = this.onGround && Math.abs(this.speedX) < 0.3;
        this.poopTimer = this.isStandPooping ? 0.6 : 0.15;
        this.poopCooldown = 1.0;
        this.animFrame = 0;
        this.animTimer = 0;
        if (!this.isStandPooping) {
          // Running/jumping poop: spawn big poop immediately
          this._spawnPoop = true;
        }
        // Standing poop: animation only, no projectile (the animation shows it)
      }
    }
    if (this.poopTimer > 0) {
      this.poopTimer -= dt;
      this.animTimer += dt;
      if (this.isStandPooping) {
        const maxFrames = this.hasWings ? CFG.SPRITE_STAND_POOP_WINGS_FRAMES : CFG.SPRITE_STAND_POOP_FRAMES;
        const frameDur = 0.6 / maxFrames;
        this.animFrame = Math.min(maxFrames - 1, Math.floor(this.animTimer / frameDur));
        // Leave a poop pile on the ground when animation finishes
        if (this.poopTimer <= 0) {
          this._spawnStandPoop = true;
        }
      }
    }

    // Rainbow shoot
    if (this.shootCooldown > 0) this.shootCooldown -= dt;
    if (input.shoot && this.hasRainbow && this.shootCooldown <= 0) {
      this.shootCooldown = 0.3;
      this._spawnRainbow = true;
    }

    // Gravity (reduced underwater for floaty swimming, floatier for kittycorn while rising, zero for pixicorn flight)
    let grav = underwater ? CFG.UNDERWATER_GRAVITY : CFG.GRAVITY;
    if (this.isPixicorn && !underwater) grav = 0;
    else if (this.isKittycorn && !underwater && this.vy < 0) grav *= 0.85;
    const maxFall = underwater ? CFG.UNDERWATER_MAX_FALL : CFG.MAX_FALL;
    this.vy += grav;
    if (this.vy > maxFall) this.vy = maxFall;

    // Move and collide
    this.moveAndCollide(level);

    // Clamp Y for pixicorn free flight (stay within level bounds)
    if (this.isPixicorn && !underwater) {
      if (this.y < 0) { this.y = 0; this.vy = 0; }
      if (this.bottom > level.height - this.h) { this.y = level.height - this.h * 2; this.vy = 0; }
    }

    // Landing detection
    if (this.onGround && !this.wasOnGround) {
      this.landImpact = Math.abs(prevVY);
      if (this.landImpact > 2) {
        particles.dustBurst(this.cx, this.bottom, Math.min(8, Math.floor(this.landImpact)));
        audio.landSound();
        if (this.landImpact > 5) {
          camera.shake(this.landImpact * 0.8);
        }
      }
      this.squash = Math.min(0.3, this.landImpact * 0.04);
    }

    // Squash/stretch decay
    if (this.squash > 0) {
      this.squash *= 0.85;
      if (this.squash < 0.01) this.squash = 0;
    }

    // Running dust
    if (this.onGround && Math.abs(this.speedX) > 1.5) {
      this.runDust += dt;
      if (this.runDust > 0.08) {
        this.runDust = 0;
        particles.emit(PARTICLE_DUST, this.cx + (Math.random()-0.5)*6, this.bottom, {
          vx: -this.facing * 0.5, vy: -Math.random()*0.5,
          life: 0.2, size: 1.5, color: "#a08060", gravity: 0.02, friction: 0.95
        });
      }
    }

    // Invincibility timer
    if (this.invTimer > 0) this.invTimer -= dt;

    // Animation state
    this.updateAnim(dt);

    // Death by falling off level
    if (this.y > level.height + 40) {
      this.lives--;
      this._deathType = "fall";
      this.die();
    }
  }
  moveAndCollide(level) {
    // Horizontal
    this.x += this.vx;
    if (this.vx > 0) {
      if (level.solidAt(this.right, this.top+2) || level.solidAt(this.right, this.bottom-2)) {
        this.x = Math.floor(this.right / CFG.TILE) * CFG.TILE - this.w;
        this.speedX = 0;
      }
    } else if (this.vx < 0) {
      if (level.solidAt(this.left, this.top+2) || level.solidAt(this.left, this.bottom-2)) {
        this.x = Math.floor(this.left / CFG.TILE) * CFG.TILE + CFG.TILE;
        this.speedX = 0;
      }
    }
    // Clamp to level bounds horizontally
    if (this.x < 0) { this.x = 0; this.speedX = 0; }
    if (this.right > level.width) { this.x = level.width - this.w; this.speedX = 0; }

    // Vertical
    this.y += this.vy;
    this.onGround = false;
    if (this.vy > 0) {
      // Falling - check bottom edge
      if (level.solidAt(this.left+2, this.bottom) || level.solidAt(this.right-2, this.bottom) ||
          level.solidAt(this.cx, this.bottom)) {
        this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
        this.vy = 0;
        this.onGround = true;
      }
    } else if (this.vy < 0) {
      // Rising - check top edge
      if (level.solidAt(this.left+2, this.top) || level.solidAt(this.right-2, this.top)) {
        this.y = Math.floor(this.top / CFG.TILE) * CFG.TILE + CFG.TILE;
        this.vy = 0;
      }
    }
  }
  updateAnim(dt) {
    // Poop animation takes priority (but not over growWings/hoopClear)
    if (this.poopTimer > 0 && this.isStandPooping && this.animState !== "growWings" && this.animState !== "hoopClear") {
      this.animState = "standPoop";
      return;
    }
    if (!this.onGround) {
      this.animState = this.vy < 0 ? "jump" : "fall";
    } else if (Math.abs(this.speedX) > 0.3) {
      this.animState = "run";
    } else {
      this.animState = "idle";
    }
    this.animTimer += dt;
    if (this.animState === "run") {
      if (this.animTimer > 0.08) {
        this.animTimer = 0;
        this.animFrame = (this.animFrame + 1) % CFG.SPRITE_RUN_FRAMES;
      }
    } else if (this.animState === "idle") {
      this.animFrame = 0;
    }
  }
  hurt(particles, audio) {
    if (this.invTimer > 0) return;
    audio.hurtSound();
    particles.impactBurst(this.cx, this.cy, 10, "#ff6666");

    if (this.isMermaid || this.isKittycorn || this.isPixicorn || this.isMouseicorn) {
      // Tier 1: Lose form + rainbow + wings, keep big as safety buffer
      if (this.isMermaid) {
        this.isMermaid = false;
        particles.floatingText(this.cx, this.cy - 15, "MERMAID LOST!", "#44ddee");
      } else if (this.isMouseicorn) {
        this.isMouseicorn = false;
        particles.floatingText(this.cx, this.cy - 15, "MOUSICORN LOST!", "#aa8866");
      } else if (this.isPixicorn) {
        this.isPixicorn = false;
        particles.floatingText(this.cx, this.cy - 15, "PIXICORN LOST!", "#cc88ff");
      } else {
        this.isKittycorn = false;
        particles.floatingText(this.cx, this.cy - 15, "KITTY LOST!", "#ff88cc");
      }
      this.hasRainbow = false;
      this.hasWings = false;
      this.canTripleJump = false;
      this.canDoubleJump = false;
      this.flowersForRainbow = 0;
      this.isBig = true;
      this.invTimer = 1.5;
    } else if (this.isBig) {
      // Tier 2: Shrink to small, strip all power-ups
      this.isBig = false;
      this.hasRainbow = false;
      this.hasWings = false;
      this.canTripleJump = false;
      this.canDoubleJump = false;
      this.flowersForRainbow = 0;
      this.invTimer = 0.8;
      particles.floatingText(this.cx, this.cy - 15, "SHRINK!", "#daa520");
    } else {
      // Tier 3: Small + hit = death
      this.lives--;
      this._deathType = "contact";
      this.die();
    }
  }
  die() {
    this.alive = false;
    // Death strips all power-ups (like Mario)
    this.isBig = false;
    this.hasWings = false;
    this.hasRainbow = false;
    this.canTripleJump = false;
    this.canDoubleJump = false;
    this.isMermaid = false;
    this.isKittycorn = false;
    this.isPixicorn = false;
    this.isMouseicorn = false;
  }
  reset(x, y) {
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.speedX = 0;
    this.onGround = false;
    this.alive = true;
    this.invTimer = 1.0;
    this.facing = 1;
    this.coyoteTimer = 0;
    this.jumpBufferTimer = 0;
    this.canDoubleJump = this.hasWings;
    this.canTripleJump = this.hasWings;
    this.growWingsTimer = 0;
    this.squash = 0;
    this.animState = "idle";
    this.animFrame = 0;
    this.animTimer = 0;
    this.poopTimer = 0;
    this.poopCooldown = 0;
    this.isStandPooping = false;
    this.jumpType = "first";
    this.shootCooldown = 0;
    this._spawnPoop = false;
    this._spawnStandPoop = false;
    this._spawnRainbow = false;
    this.mermaidTransformTimer = 0;
    this.pixicornTransformTimer = 0;
    this.mousicornTransformTimer = 0;
    this._deathType = null;
  }
}

// --- Star (Collectible) ---
class Star extends Entity {
  constructor(x, y) {
    super(x, y, 14, 14);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.glowPhase = Math.random() * Math.PI * 2;
    this.collected = false;
    this.collectTimer = 0;
  }
  update(dt, gt) {
    if (this.collected) {
      this.collectTimer -= dt;
      if (this.collectTimer <= 0) this.alive = false;
      return;
    }
    this.y = this.baseY + Math.sin(gt * CFG.STAR_FLOAT_SPD + this.phase) * CFG.STAR_FLOAT_AMP;
    this.glowPhase += dt * 4;
  }
  collect() {
    this.collected = true;
    this.collectTimer = 0.3;
  }
}

// --- Fly (Enemy) ---
class Fly extends Entity {
  constructor(x, y, patrolDist) {
    super(x, y, 18, 14);
    this.startX = x;
    this.endX = x + patrolDist;
    this.dir = 1;
    this.phase = Math.random() * Math.PI * 2;
    this.wingPhase = 0;
    this.baseY = y;
    this.speed = CFG.FLY_PATROL_SPD;
  }
  update(dt, gt) {
    this.x += this.dir * this.speed;
    if (this.x >= this.endX) { this.x = this.endX; this.dir = -1; }
    if (this.x <= this.startX) { this.x = this.startX; this.dir = 1; }
    this.y = this.baseY + Math.sin(gt * CFG.FLY_BOB_SPD + this.phase) * CFG.FLY_BOB_AMP;
    this.wingPhase += dt * 30;
  }
}

// --- Gnome (Ground Enemy) ---
class Gnome extends Entity {
  constructor(x, y, patrolDist) {
    super(x, y, 14, 28);
    this.startX = x;
    this.endX = x + patrolDist;
    this.dir = 1;
    this.speed = CFG.GNOME_PATROL_SPD;
    this.animTimer = 0;
    this.animFrame = 0;
  }
  update(dt, gt) {
    this.x += this.dir * this.speed;
    if (this.x >= this.endX) { this.x = this.endX; this.dir = -1; }
    if (this.x <= this.startX) { this.x = this.startX; this.dir = 1; }
    this.animTimer += dt;
    if (this.animTimer > 0.12) {
      this.animTimer = 0;
      this.animFrame = (this.animFrame + 1) % CFG.SPRITE_GNOME_FRAMES;
    }
  }
}

// --- Wing Crystal (Power-up) ---
class WingCrystal extends Entity {
  constructor(x, y) {
    super(x, y, 16, 16);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.collected = false;
  }
  update(dt, gt) {
    if (this.collected) return;
    this.y = this.baseY + Math.sin(gt * 2.5 + this.phase) * 5;
  }
}

// --- Hoop (Goal) ---
class Hoop extends Entity {
  constructor(x, y) {
    super(x, y, 20, 60);
    this.pulsePhase = 0;
  }
  update(dt, gt) {
    this.pulsePhase = gt;
  }
}

// --- Poop (Projectile/Dropped) ---
class Poop extends Entity {
  constructor(x, y, vx, vy) {
    super(x, y, 18, 18);
    this.vx = vx;
    this.vy = vy;
    this.landed = false;
    this.landedTimer = 0;
    this.animTimer = 0;
    this.fadeTime = 6.0; // disappear after landing
  }
  update(dt, level) {
    this.animTimer += dt;
    if (this.landed) {
      this.landedTimer += dt;
      if (this.landedTimer > this.fadeTime) this.alive = false;
      return;
    }
    // Gravity
    this.vy += CFG.GRAVITY * 0.8;
    if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
    this.x += this.vx;
    this.y += this.vy;
    // Check ground collision
    if (level.solidAt(this.cx, this.bottom)) {
      this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
      this.vy = 0;
      this.vx = 0;
      this.landed = true;
    }
    // Off screen
    if (this.y > level.height + 40) this.alive = false;
  }
}

// --- Dead Flower (brown, poop to revive) ---
class DeadFlower extends Entity {
  constructor(x, y) {
    super(x, y, 14, 16);
    this.revived = false;
    this.reviveTimer = 0; // animation timer when revived
  }
  update(dt, gt) {
    if (this.revived) {
      this.reviveTimer += dt;
    }
  }
}

// --- Black Flower (poop to spawn hay bale) ---
class BlackFlower extends Entity {
  constructor(x, y) {
    super(x, y, 14, 16);
    this.used = false;
    this.spawnHayBale = false; // flag for Game to read
  }
  update(dt, gt) {}
}

// --- Hay Bale (collect to grow big, like Mario mushroom) ---
class HayBale extends Entity {
  constructor(x, y) {
    super(x, y, 16, 14);
    this.vy = -3; // pop up from flower
    this.vx = 1;  // move right like mushroom
    this.onGround = false;
    this.bobTimer = 0;
  }
  update(dt, level) {
    this.bobTimer += dt;
    // Gravity
    this.vy += CFG.GRAVITY * 0.7;
    if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
    this.y += this.vy;
    this.x += this.vx;
    // Ground collision
    if (level.solidAt(this.cx, this.bottom)) {
      this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
      this.vy = 0;
      this.onGround = true;
    }
    // Wall collision - reverse direction
    if (level.solidAt(this.right + 2, this.cy) || level.solidAt(this.left - 2, this.cy)) {
      this.vx = -this.vx;
    }
    // Off screen
    if (this.y > level.height + 40) this.alive = false;
  }
}

// --- Rainbow Bolt (horn shooter projectile) ---
class RainbowBolt extends Entity {
  constructor(x, y, facing) {
    super(x, y, 16, 8);
    this.vx = facing * 5;
    this.vy = 0;
    this.facing = facing;
    this.timer = 0;
    this.lifeSpan = 2.0; // disappears after 2 seconds
  }
  update(dt, level) {
    this.timer += dt;
    this.x += this.vx;
    this.vy += 0.02; // very slight arc
    this.y += this.vy;
    // Die on hitting a wall
    if (level.solidAt(this.cx, this.cy)) {
      this.alive = false;
    }
    // Die after lifespan or off screen
    if (this.timer > this.lifeSpan || this.x < -20 || this.x > level.width + 20) {
      this.alive = false;
    }
  }
}

// --- Boss (Gnome King - stomp or shoot 3 times to defeat) ---
class Boss extends Entity {
  constructor(x, y) {
    super(x, y, 40, 50);
    this.hp = 3;
    this.maxHp = 3;
    this.invTimer = 0;
    this.dir = -1;
    this.speed = 1.0;
    this.baseSpeed = 1.0;
    this.phase = "patrol"; // patrol, charge, stunned, defeated
    this.chargeTimer = 0;
    this.stunTimer = 0;
    this.patrolTimer = 0;
    this.arenaLeft = 0;
    this.arenaRight = 0;
    this.onGround = false;
    this.jumpTimer = 0;
    this.animTimer = 0;
    this.defeated = false;
    this.defeatTimer = 0;
    // Hawk-specific properties
    this.flyHeight = 0;       // set after arena is known
    this.swoopTargetX = 0;
    this.swoopTargetY = 0;
    this.swoopVX = 0;
    this.swoopVY = 0;
    this.riseTimer = 0;       // timer for rising back to cruise altitude after stun
    this.bossType = "gnome";  // default, overwritten after construction
    // Flower-specific properties
    this.fireballTimer = 0;
    this.flowerPhase = 0;
    this.wantsToShoot = false;
    // Pharaoh cat specific
    this.pounceTargetX = 0;
    this.pounceTargetY = 0;
    this.scratchCount = 0;
    this.scratchTimer = 0;
    this.hissTimer = 0;
    this.catPhase = "patrol"; // patrol, pounce, scratch, hiss
    // Storm dragon specific
    this.dragonPhase = "fly"; // fly, dive, breathe, rise
    this.breathTimer = 0;
    this.breathCount = 0;
    this.diveTimer = 0;
    this.wingAngle = 0;
    // Shadow queen specific
    this.queenPhase = "float"; // float, dash, nova, teleport
    this.novaTimer = 0;
    this.novaCount = 0;
    this.dashTimer = 0;
    this.teleportTimer = 0;
    this.queenGlow = 0;
  }
  setArena(left, right) {
    this.arenaLeft = left;
    this.arenaRight = right;
  }
  hit(particles, audio) {
    if (this.invTimer > 0 || this.defeated) return false;
    this.hp--;
    this.invTimer = 1.5;
    this.stunTimer = 1.0;
    this.phase = "stunned";
    this.speed = 0;
    audio.hurtSound();
    particles.impactBurst(this.cx, this.cy, 15, "#ff4444");
    particles.floatingText(this.cx, this.cy - 30, this.hp > 0 ? "HIT! " + this.hp + " LEFT" : "K.O.!", "#ff4444");
    if (this.hp <= 0) {
      this.defeated = true;
      this.defeatTimer = 0;
      this.phase = "defeated";
    } else {
      this.baseSpeed += 0.4;
    }
    return true;
  }
  update(dt, level, playerX, playerY) {
    if (this.defeated) {
      this.defeatTimer += dt;
      return;
    }
    this.animTimer += dt;
    if (this.invTimer > 0) this.invTimer -= dt;

    // Hawk boss — flying behavior (no gravity except when stunned)
    if (this.bossType === "hawk") {
      // Set flyHeight on first update if not set
      if (this.flyHeight === 0) {
        this.flyHeight = this.arenaLeft ? (level.rows - 7) * CFG.TILE : this.y;
      }

      if (this.phase === "stunned") {
        // Fall with gravity when stunned
        this.vy += CFG.GRAVITY;
        if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
        this.y += this.vy;
        if (level.solidAt(this.cx, this.bottom)) {
          this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
          this.vy = 0;
        }
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) {
          this.phase = "rise";
          this.riseTimer = 0;
          this.speed = this.baseSpeed;
        }
        return;
      }

      if (this.phase === "rise") {
        // Fly back up to cruising altitude
        this.riseTimer += dt;
        const targetY = this.flyHeight;
        this.vy = -2.5;
        this.y += this.vy;
        this.x += this.dir * this.speed * 0.5;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        if (this.y <= targetY || this.riseTimer > 2.0) {
          this.y = targetY;
          this.vy = 0;
          this.phase = "fly";
          this.patrolTimer = 0;
        }
        return;
      }

      if (this.phase === "fly" || this.phase === "patrol") {
        this.phase = "fly"; // normalize
        // Cruise back and forth with sinusoidal bobbing
        this.x += this.dir * this.speed;
        this.y = this.flyHeight + Math.sin(this.animTimer * 2.0) * 8;
        this.vy = 0;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        this.patrolTimer += dt;
        // Swoop at player periodically
        if (this.patrolTimer > 2.5) {
          this.phase = "swoop";
          this.chargeTimer = 0;
          // Target the player's position
          this.swoopTargetX = playerX || this.cx;
          this.swoopTargetY = (playerY || (level.rows - 3) * CFG.TILE);
          const dx = this.swoopTargetX - this.cx;
          const dy = this.swoopTargetY - this.cy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const swoopSpeed = this.baseSpeed * 2.5;
          this.swoopVX = (dx / dist) * swoopSpeed;
          this.swoopVY = (dy / dist) * swoopSpeed;
          this.dir = dx > 0 ? 1 : -1;
        }
        return;
      }

      if (this.phase === "swoop" || this.phase === "charge") {
        this.phase = "swoop"; // normalize
        // Dive toward target position
        this.x += this.swoopVX;
        this.y += this.swoopVY;
        this.vy = 0;
        this.chargeTimer += dt;
        // Clamp to arena bounds
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // End swoop after reaching depth or timer expires
        const groundY = (level.rows - 3) * CFG.TILE;
        if (this.chargeTimer > 1.5 || this.y >= groundY) {
          this.phase = "rise";
          this.riseTimer = 0;
          this.vy = 0;
        }
        return;
      }

      return; // hawk handled
    }

    // Flower boss — stationary, shoots fireballs
    if (this.bossType === "flower") {
      this.flowerPhase += dt;
      this.fireballTimer += dt;
      if (this.phase === "stunned") {
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) { this.phase = "patrol"; this.speed = 0; }
        return;
      }
      // Shoot fireballs periodically (faster after hits)
      const interval = CFG.FLOWER_FIREBALL_INTERVAL - (this.maxHp - this.hp) * 0.3;
      if (this.fireballTimer >= interval && this.phase !== "stunned") {
        this.fireballTimer = 0;
        this.phase = "charge";
        this.chargeTimer = 0;
        this.wantsToShoot = true;
      }
      if (this.phase === "charge") {
        this.chargeTimer += dt;
        if (this.chargeTimer > 0.3) { this.phase = "patrol"; this.chargeTimer = 0; }
      }
      return;
    }

    // Rat boss — gravity-based scurrier (underwater: reduced gravity for swim/lunge)
    if (this.bossType === "rat") {
      const ratGrav = level && level.levelDef && level.levelDef.isUnderwater
        ? CFG.UNDERWATER_GRAVITY * 2.5 : CFG.GRAVITY;
      const ratMaxFall = level && level.levelDef && level.levelDef.isUnderwater
        ? CFG.UNDERWATER_MAX_FALL * 1.5 : CFG.MAX_FALL;

      this.vy += ratGrav;
      if (this.vy > ratMaxFall) this.vy = ratMaxFall;
      this.y += this.vy;
      this.onGround = false;
      if (level.solidAt(this.cx, this.bottom)) {
        this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
        this.vy = 0;
        this.onGround = true;
      }

      if (this.phase === "stunned") {
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) {
          this.phase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
        }
        return;
      }

      // Speed up intervals after hits
      const hitBonus = (this.maxHp - this.hp) * 0.4;
      const chargeInterval = Math.max(0.8, CFG.RAT_CHARGE_INTERVAL - hitBonus);
      const jumpInterval = Math.max(1.2, CFG.RAT_JUMP_INTERVAL - hitBonus);

      if (this.phase === "patrol") {
        this.x += this.dir * this.speed;
        this.patrolTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // Charge at player periodically
        if (this.patrolTimer > chargeInterval) {
          this.phase = "charge";
          this.chargeTimer = 0;
          this.dir = playerX > this.cx ? 1 : -1;
          this.speed = this.baseSpeed * CFG.RAT_CHARGE_SPEED_MULT;
        }
        // Jump occasionally
        this.jumpTimer += dt;
        if (this.jumpTimer > jumpInterval && this.onGround) {
          this.vy = CFG.RAT_JUMP_FORCE;
          this.jumpTimer = 0;
        }
      }

      if (this.phase === "charge") {
        this.x += this.dir * this.speed;
        this.chargeTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // Jump during charge (higher!)
        this.jumpTimer += dt;
        if (this.jumpTimer > jumpInterval * 0.6 && this.onGround) {
          this.vy = CFG.RAT_JUMP_FORCE * 1.2;
          this.jumpTimer = 0;
        }
        if (this.chargeTimer > 1.5) {
          this.phase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
        }
      }
      return; // rat handled
    }

    // Storm Dragon boss — flying with fire breath
    if (this.bossType === "storm_dragon") {
      if (this.flyHeight === 0) {
        this.flyHeight = this.arenaLeft ? (level.rows - 7) * CFG.TILE : this.y;
      }
      this.wingAngle += dt * 4;

      if (this.phase === "stunned") {
        this.vy += CFG.GRAVITY;
        if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
        this.y += this.vy;
        if (level.solidAt(this.cx, this.bottom)) {
          this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
          this.vy = 0;
        }
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) {
          this.phase = "rise";
          this.dragonPhase = "rise";
          this.riseTimer = 0;
          this.speed = this.baseSpeed;
        }
        return;
      }

      const hitBonus = (this.maxHp - this.hp) * 0.4;

      if (this.dragonPhase === "rise") {
        this.riseTimer += dt;
        this.vy = -2.8;
        this.y += this.vy;
        this.x += this.dir * this.speed * 0.5;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        if (this.y <= this.flyHeight || this.riseTimer > 2.0) {
          this.y = this.flyHeight;
          this.vy = 0;
          this.phase = "fly";
          this.dragonPhase = "fly";
          this.patrolTimer = 0;
        }
        return;
      }

      if (this.dragonPhase === "fly") {
        this.phase = "fly";
        this.x += this.dir * this.speed * 1.2;
        this.y = this.flyHeight + Math.sin(this.animTimer * 1.8) * 10;
        this.vy = 0;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        this.patrolTimer += dt;
        const actionInterval = Math.max(1.5, 2.8 - hitBonus);
        if (this.patrolTimer > actionInterval) {
          // Alternate between dive and breathe
          if (this.breathCount % 2 === 0) {
            this.dragonPhase = "dive";
            this.phase = "swoop";
            this.chargeTimer = 0;
            this.swoopTargetX = playerX || this.cx;
            this.swoopTargetY = (playerY || (level.rows - 3) * CFG.TILE);
            const dx = this.swoopTargetX - this.cx;
            const dy = this.swoopTargetY - this.cy;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const swoopSpeed = this.baseSpeed * 2.8;
            this.swoopVX = (dx / dist) * swoopSpeed;
            this.swoopVY = (dy / dist) * swoopSpeed;
            this.dir = dx > 0 ? 1 : -1;
          } else {
            this.dragonPhase = "breathe";
            this.phase = "charge";
            this.breathTimer = 0;
            this.dir = playerX > this.cx ? 1 : -1;
            this.wantsToShoot = true;
          }
          this.breathCount++;
        }
        return;
      }

      if (this.dragonPhase === "dive") {
        this.x += this.swoopVX;
        this.y += this.swoopVY;
        this.vy = 0;
        this.chargeTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        const groundY = (level.rows - 3) * CFG.TILE;
        if (this.chargeTimer > 1.5 || this.y >= groundY) {
          this.dragonPhase = "rise";
          this.phase = "rise";
          this.riseTimer = 0;
          this.vy = 0;
        }
        return;
      }

      if (this.dragonPhase === "breathe") {
        this.breathTimer += dt;
        this.y = this.flyHeight + Math.sin(this.animTimer * 3) * 4;
        const shootInterval = Math.max(0.3, 0.6 - hitBonus * 0.1);
        if (this.wantsToShoot) {
          this.wantsToShoot = false;
          this.fireballTimer = 0;
        }
        this.fireballTimer += dt;
        if (this.fireballTimer >= shootInterval) {
          this.fireballTimer = 0;
          this.wantsToShoot = true;
        }
        if (this.breathTimer > 2.0) {
          this.dragonPhase = "fly";
          this.phase = "fly";
          this.patrolTimer = 0;
          this.wantsToShoot = false;
        }
        return;
      }
      return; // storm_dragon handled
    }

    // Shadow Queen boss — teleporting magic user
    if (this.bossType === "shadow_queen") {
      this.queenGlow += dt;

      // Floating hover (no gravity)
      if (this.phase === "stunned") {
        this.vy += CFG.GRAVITY * 0.5;
        if (this.vy > 3) this.vy = 3;
        this.y += this.vy;
        if (level.solidAt(this.cx, this.bottom)) {
          this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
          this.vy = 0;
        }
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) {
          this.phase = "patrol";
          this.queenPhase = "float";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
          // Rise back up
          this.vy = -3;
        }
        return;
      }

      const hitBonus = (this.maxHp - this.hp) * 0.5;
      // Float at a fixed height
      if (this.flyHeight === 0) {
        this.flyHeight = this.arenaLeft ? (level.rows - 6) * CFG.TILE : this.y;
      }

      if (this.queenPhase === "float") {
        this.phase = "patrol";
        this.x += this.dir * this.speed * 0.8;
        this.y = this.flyHeight + Math.sin(this.animTimer * 2.5) * 6;
        this.vy = 0;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        this.patrolTimer += dt;
        const actionInterval = Math.max(1.2, 2.2 - hitBonus);
        if (this.patrolTimer > actionInterval) {
          // Cycle through attacks
          const attack = this.novaCount % 3;
          if (attack === 0) {
            // Dash toward player
            this.queenPhase = "dash";
            this.phase = "charge";
            this.dashTimer = 0;
            this.dir = playerX > this.cx ? 1 : -1;
            this.speed = this.baseSpeed * 3.5;
          } else if (attack === 1) {
            // Nova burst — shoot many fireballs
            this.queenPhase = "nova";
            this.phase = "charge";
            this.novaTimer = 0;
            this.wantsToShoot = true;
          } else {
            // Teleport behind player
            this.queenPhase = "teleport";
            this.teleportTimer = 0;
            this.swoopTargetX = playerX + (playerX > this.cx ? -60 : 60);
          }
          this.novaCount++;
        }
        return;
      }

      if (this.queenPhase === "dash") {
        this.dashTimer += dt;
        this.x += this.dir * this.speed;
        this.y = this.flyHeight + Math.sin(this.animTimer * 6) * 3;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        if (this.dashTimer > 1.0) {
          this.queenPhase = "float";
          this.phase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
        }
        return;
      }

      if (this.queenPhase === "nova") {
        this.novaTimer += dt;
        this.y = this.flyHeight + Math.sin(this.animTimer * 4) * 2;
        const shootInterval = Math.max(0.25, 0.5 - hitBonus * 0.1);
        if (this.wantsToShoot) {
          this.wantsToShoot = false;
          this.fireballTimer = 0;
        }
        this.fireballTimer += dt;
        if (this.fireballTimer >= shootInterval) {
          this.fireballTimer = 0;
          this.wantsToShoot = true;
        }
        if (this.novaTimer > 2.0) {
          this.queenPhase = "float";
          this.phase = "patrol";
          this.patrolTimer = 0;
          this.wantsToShoot = false;
        }
        return;
      }

      if (this.queenPhase === "teleport") {
        this.teleportTimer += dt;
        // Fade out, reposition, fade in
        if (this.teleportTimer < 0.3) {
          // fading out (handled in draw)
        } else if (this.teleportTimer < 0.5) {
          // Reposition
          const targetX = Math.max(this.arenaLeft, Math.min(this.arenaRight - this.w, this.swoopTargetX));
          this.x = targetX;
          this.dir = playerX > this.cx ? 1 : -1;
        }
        if (this.teleportTimer > 0.8) {
          this.queenPhase = "float";
          this.phase = "patrol";
          this.patrolTimer = 0;
          this.speed = this.baseSpeed;
        }
        return;
      }
      return; // shadow_queen handled
    }

    // Pharaoh's Cat boss — ground-based pouncer
    if (this.bossType === "pharaoh_cat") {
      this.vy += CFG.GRAVITY;
      if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
      this.y += this.vy;
      this.onGround = false;
      if (level.solidAt(this.cx, this.bottom)) {
        this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
        this.vy = 0;
        this.onGround = true;
      }

      if (this.phase === "stunned") {
        this.stunTimer -= dt;
        if (this.stunTimer <= 0) {
          this.phase = "patrol";
          this.catPhase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
        }
        return;
      }

      const hitBonus = (this.maxHp - this.hp) * 0.5;

      if (this.catPhase === "patrol") {
        this.x += this.dir * this.speed;
        this.patrolTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // Pounce at player periodically
        const pounceInterval = Math.max(1.2, 2.5 - hitBonus);
        if (this.patrolTimer > pounceInterval) {
          this.catPhase = "pounce";
          this.phase = "charge";
          this.chargeTimer = 0;
          this.dir = playerX > this.cx ? 1 : -1;
          this.pounceTargetX = playerX;
          this.pounceTargetY = playerY;
          // Leap arc toward player
          this.vy = -7.0;
          this.speed = this.baseSpeed * 3.0;
        }
      }

      if (this.catPhase === "pounce") {
        this.x += this.dir * this.speed;
        this.chargeTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // Land and transition to scratch
        if (this.onGround && this.chargeTimer > 0.3) {
          this.catPhase = "scratch";
          this.phase = "charge";
          this.scratchCount = 0;
          this.scratchTimer = 0;
          this.speed = this.baseSpeed * 2.0;
          this.dir = playerX > this.cx ? 1 : -1;
        }
        if (this.chargeTimer > 2.0) {
          this.catPhase = "patrol";
          this.phase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
        }
      }

      if (this.catPhase === "scratch") {
        this.x += this.dir * this.speed * 0.5;
        this.scratchTimer += dt;
        if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
        if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
        // 3 quick swipes
        if (this.scratchTimer > 0.25) {
          this.scratchCount++;
          this.scratchTimer = 0;
          if (this.scratchCount >= 3) {
            this.catPhase = "hiss";
            this.hissTimer = 0;
            this.wantsToShoot = true;
          }
        }
      }

      if (this.catPhase === "hiss") {
        this.hissTimer += dt;
        this.speed = 0;
        // Shoot sound-wave projectile
        if (this.wantsToShoot) {
          this.wantsToShoot = false;
          this.fireballTimer = 0;
        }
        this.fireballTimer += dt;
        const shootInterval = Math.max(0.4, 0.8 - hitBonus * 0.15);
        if (this.fireballTimer >= shootInterval) {
          this.fireballTimer = 0;
          this.wantsToShoot = true;
        }
        if (this.hissTimer > 1.8) {
          this.catPhase = "patrol";
          this.phase = "patrol";
          this.speed = this.baseSpeed;
          this.patrolTimer = 0;
          this.wantsToShoot = false;
        }
      }
      return; // pharaoh_cat handled
    }

    // --- Ground bosses (gnome/squid) below ---

    // Gravity
    this.vy += CFG.GRAVITY;
    if (this.vy > CFG.MAX_FALL) this.vy = CFG.MAX_FALL;
    this.y += this.vy;
    this.onGround = false;
    if (level.solidAt(this.cx, this.bottom)) {
      this.y = Math.floor(this.bottom / CFG.TILE) * CFG.TILE - this.h;
      this.vy = 0;
      this.onGround = true;
    }

    if (this.phase === "stunned") {
      this.stunTimer -= dt;
      if (this.stunTimer <= 0) {
        this.phase = "patrol";
        this.speed = this.baseSpeed;
        this.patrolTimer = 0;
      }
      return;
    }

    if (this.phase === "patrol") {
      this.x += this.dir * this.speed;
      this.patrolTimer += dt;
      if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
      if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
      // Charge at player periodically
      if (this.patrolTimer > 2.5) {
        this.phase = "charge";
        this.chargeTimer = 0;
        this.dir = playerX > this.cx ? 1 : -1;
        this.speed = this.baseSpeed * 2.5;
      }
      // Jump occasionally
      this.jumpTimer += dt;
      if (this.jumpTimer > 2.0 && this.onGround) {
        this.vy = -5.5;
        this.jumpTimer = 0;
      }
    }

    if (this.phase === "charge") {
      this.x += this.dir * this.speed;
      this.chargeTimer += dt;
      if (this.x <= this.arenaLeft) { this.x = this.arenaLeft; this.dir = 1; }
      if (this.right >= this.arenaRight) { this.x = this.arenaRight - this.w; this.dir = -1; }
      if (this.chargeTimer > 1.5) {
        this.phase = "patrol";
        this.speed = this.baseSpeed;
        this.patrolTimer = 0;
      }
    }
  }
}

// --- Fish (Underwater Enemy) ---
class Fish extends Entity {
  constructor(x, y, patrolDist) {
    super(x, y, 20, 12);
    this.startX = x;
    this.endX = x + patrolDist;
    this.dir = 1;
    this.phase = Math.random() * Math.PI * 2;
    this.baseY = y;
    this.speed = CFG.FISH_SPEED + Math.random() * 0.6;
    this.tailPhase = 0;
    // Random fish color
    const fishTypes = ["#ff6644","#44aaff","#ffaa22","#66dd44","#ff44aa"];
    this.color = fishTypes[Math.floor(Math.random() * fishTypes.length)];
  }
  update(dt, gt) {
    this.x += this.dir * this.speed;
    if (this.x >= this.endX) { this.x = this.endX; this.dir = -1; }
    if (this.x <= this.startX) { this.x = this.startX; this.dir = 1; }
    this.y = this.baseY + Math.sin(gt * CFG.FISH_BOB_SPD + this.phase) * CFG.FISH_BOB_AMP;
    this.tailPhase += dt * 15;
  }
}

// --- Jellyfish (Underwater Enemy — slow, bobs vertically) ---
class Jellyfish extends Entity {
  constructor(x, y) {
    super(x, y, 16, 20);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.pulsePhase = 0;
    // Random jellyfish color
    const jellyTypes = ["#ff66cc","#66ccff","#cc88ff","#88ffcc"];
    this.color = jellyTypes[Math.floor(Math.random() * jellyTypes.length)];
    this.sizeScale = Math.random() < 0.5 ? 1.0 : 1.35;
  }
  update(dt, gt) {
    this.y = this.baseY + Math.sin(gt * CFG.JELLY_BOB_SPD + this.phase) * CFG.JELLY_BOB_AMP;
    this.pulsePhase += dt * 4;
  }
}

// --- Narwhal (Underwater Enemy — patrols horizontally, charges at player) ---
class Narwhal extends Entity {
  constructor(x, y, patrolDist) {
    super(x, y, 22, 18);
    this.startX = x;
    this.endX = x + patrolDist;
    this.dir = 1;
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.speed = 0.5 + Math.random() * 0.3;
    this.animTimer = 0;
    this.animFrame = 0;
  }
  update(dt, gt) {
    this.x += this.dir * this.speed;
    if (this.x >= this.endX) { this.x = this.endX; this.dir = -1; }
    if (this.x <= this.startX) { this.x = this.startX; this.dir = 1; }
    this.y = this.baseY + Math.sin(gt * 1.8 + this.phase) * 8;
    this.animTimer += dt;
    if (this.animTimer > 0.15) {
      this.animTimer = 0;
      this.animFrame = (this.animFrame + 1) % CFG.SPRITE_NARWHAL_FRAMES;
    }
  }
}

// --- Mermaid Gem (Transformation Power-up) ---
class MermaidGem extends Entity {
  constructor(x, y) {
    super(x, y, 16, 16);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.collected = false;
  }
  update(dt, gt) {
    if (this.collected) return;
    this.y = this.baseY + Math.sin(gt * 2.5 + this.phase) * 5;
  }
}

// --- Bird (Treetop Enemy — swooping patrol) ---
class Bird extends Entity {
  constructor(x, y, patrolDist) {
    super(x, y, 20, 16);
    this.startX = x;
    this.endX = x + patrolDist;
    this.dir = 1;
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.speed = 1.0 + Math.random() * 0.4;
    this.wingPhase = Math.random() * Math.PI * 2;
    this.animFrame = 0;
    this.animTimer = 0;
  }
  update(dt, gt) {
    this.x += this.dir * this.speed;
    if (this.x >= this.endX) { this.x = this.endX; this.dir = -1; }
    if (this.x <= this.startX) { this.x = this.startX; this.dir = 1; }
    this.y = this.baseY + Math.sin(gt * 1.2 + this.phase) * 20;
    this.wingPhase += dt * 12;
    this.animTimer += dt;
    if (this.animTimer > 0.12) {
      this.animTimer = 0;
      this.animFrame = (this.animFrame + 1) % CFG.SPRITE_HAWK_FRAMES;
    }
  }
}

// --- Kittycorn Gem (Transformation Power-up for World 3) ---
class KittycornGem extends Entity {
  constructor(x, y) {
    super(x, y, 16, 16);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.collected = false;
  }
  update(dt, gt) {
    if (this.collected) return;
    this.y = this.baseY + Math.sin(gt * 2.5 + this.phase) * 5;
  }
}

// --- Pixicorn Gem (Transformation Power-up) ---
class PixicornGem extends Entity {
  constructor(x, y) {
    super(x, y, 16, 16);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.collected = false;
  }
  update(dt, gt) {
    if (this.collected) return;
    this.y = this.baseY + Math.sin(gt * 2.5 + this.phase) * 5;
  }
}

// --- Mousicorn Gem (Transformation Power-up) ---
class MousicornGem extends Entity {
  constructor(x, y) {
    super(x, y, 16, 16);
    this.baseY = y;
    this.phase = Math.random() * Math.PI * 2;
    this.collected = false;
  }
  update(dt, gt) {
    if (this.collected) return;
    this.y = this.baseY + Math.sin(gt * 2.5 + this.phase) * 5;
  }
}

// --- Form Gate (Transformation-locked barrier) ---
class FormGate extends Entity {
  constructor(x, y, requiredForm, gateHeight) {
    super(x, y, 20, gateHeight || 80);
    this.requiredForm = requiredForm; // "mousicorn", "kittycorn", "mermaid", "pixicorn"
    this.opened = false;
    this.openTimer = 0;
    this.openDuration = 0.8;
  }
  update(dt) {
    if (this.opened) {
      this.openTimer = Math.min(this.openTimer + dt, this.openDuration);
    }
  }
  isOpen() {
    return this.openTimer >= this.openDuration;
  }
}

// --- Fireball (Flower Boss Projectile) ---
class Fireball extends Entity {
  constructor(x, y, vx, vy) {
    super(x, y, 10, 10);
    this.vx = vx;
    this.vy = vy;
    this.lifetime = 4.0;
    this.animTimer = 0;
  }
  update(dt) {
    this.x += this.vx;
    this.y += this.vy;
    this.lifetime -= dt;
    this.animTimer += dt;
    if (this.lifetime <= 0) this.alive = false;
  }
}

// ============================================================
//  SECTION 4: RENDERING
// ============================================================

class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    // Buffer canvas at virtual resolution
    this.buf = document.createElement("canvas");
    this.buf.width = CFG.W;
    this.buf.height = CFG.H;
    this.bctx = this.buf.getContext("2d");
    this.resize();
    window.addEventListener("resize", () => this.resize());
  }
  resize() {
    const scale = Math.min(
      window.innerWidth / CFG.W,
      window.innerHeight / CFG.H
    );
    const w = Math.floor(CFG.W * scale);
    const h = Math.floor(CFG.H * scale);
    this.canvas.width = w;
    this.canvas.height = h;
    this.ctx.imageSmoothingEnabled = false;
    this.scale = scale;
  }
  begin() {
    this.bctx.clearRect(0, 0, CFG.W, CFG.H);
  }
  end() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.drawImage(this.buf, 0, 0, this.canvas.width, this.canvas.height);
  }
  get c() { return this.bctx; }
}

// --- Parallax Background (supports multiple themes) ---
class ParallaxBackground {
  constructor(levelDef) {
    this.layers = [];
    this.build(levelDef || LEVEL_DEFS[0]);
  }
  addLayer(speed, builder) {
    const canvas = document.createElement("canvas");
    canvas.width = CFG.W * 2;
    canvas.height = CFG.H;
    builder(canvas.getContext("2d"), canvas.width, canvas.height);
    this.layers.push({ canvas, speed });
  }
  build(def) {
    this.layers = [];
    const theme = def.bgTheme;
    // Sky (shared across themes)
    this.addLayer(0.02, (c,w,h) => this.buildSky(c,w,h,def.sky,theme));
    if (theme === "cave") {
      this.addLayer(0.05, (c,w,h) => this.buildCaveFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildCaveMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildCaveNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildCaveFloor(c,w,h));
    } else if (theme === "forest") {
      this.addLayer(0.05, (c,w,h) => this.buildForestFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildForestMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildForestNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildForestFloor(c,w,h));
    } else if (theme === "clouds") {
      this.addLayer(0.05, (c,w,h) => this.buildCloudsFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildCloudsMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildCloudsNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildCloudsWisp(c,w,h));
    } else if (theme === "lakeside") {
      this.addLayer(0.05, (c,w,h) => this.buildLakeFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildLakeMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildLakeNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildLakeShore(c,w,h));
    } else if (theme === "shallow_water") {
      this.addLayer(0.05, (c,w,h) => this.buildShallowFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildShallowMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildShallowNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildShallowFloor(c,w,h));
    } else if (theme === "deep_water") {
      this.addLayer(0.05, (c,w,h) => this.buildDeepFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildDeepMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildDeepNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildDeepFloor(c,w,h));
    } else if (theme === "boss_water") {
      this.addLayer(0.05, (c,w,h) => this.buildBossWaterFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildBossWaterMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildBossWaterNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildBossWaterFloor(c,w,h));
    } else if (theme === "treetop") {
      this.addLayer(0.05, (c,w,h) => this.buildTreetopFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildTreetopMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildTreetopNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildTreetopFloor(c,w,h));
    } else if (theme === "treetop_high") {
      this.addLayer(0.05, (c,w,h) => this.buildTreetopHighFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildTreetopHighMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildTreetopHighNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildTreetopHighFloor(c,w,h));
    } else if (theme === "treetop_dark") {
      this.addLayer(0.05, (c,w,h) => this.buildTreetopDarkFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildTreetopDarkMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildTreetopDarkNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildTreetopDarkFloor(c,w,h));
    } else if (theme === "treetop_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildTreetopBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildTreetopBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildTreetopBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildTreetopBossFloor(c,w,h));
    } else if (theme === "fairy") {
      this.addLayer(0.05, (c,w,h) => this.buildFairyFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildFairyMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildFairyNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildFairyFloor(c,w,h));
    } else if (theme === "fairy_mist") {
      this.addLayer(0.05, (c,w,h) => this.buildFairyMistFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildFairyMistMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildFairyMistNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildFairyMistFloor(c,w,h));
    } else if (theme === "fairy_dark") {
      this.addLayer(0.05, (c,w,h) => this.buildFairyDarkFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildFairyDarkMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildFairyDarkNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildFairyDarkFloor(c,w,h));
    } else if (theme === "fairy_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildFairyBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildFairyBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildFairyBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildFairyBossFloor(c,w,h));
    } else if (theme === "sewer") {
      this.addLayer(0.05, (c,w,h) => this.buildSewerFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSewerMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSewerNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSewerFloor(c,w,h));
    } else if (theme === "sewer_flood") {
      this.addLayer(0.05, (c,w,h) => this.buildSewerFloodFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSewerFloodMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSewerFloodNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSewerFloodFloor(c,w,h));
    } else if (theme === "sewer_deep") {
      this.addLayer(0.05, (c,w,h) => this.buildSewerDeepFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSewerDeepMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSewerDeepNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSewerDeepFloor(c,w,h));
    } else if (theme === "sewer_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildSewerBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSewerBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSewerBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSewerBossFloor(c,w,h));
    } else if (theme === "desert") {
      this.addLayer(0.05, (c,w,h) => this.buildDesertFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildDesertMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildDesertNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildDesertFloor(c,w,h));
    } else if (theme === "pyramid_interior") {
      this.addLayer(0.05, (c,w,h) => this.buildPyramidFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildPyramidMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildPyramidNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildPyramidFloor(c,w,h));
    } else if (theme === "pyramid_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildPyramidBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildPyramidBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildPyramidBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildPyramidBossFloor(c,w,h));
    } else if (theme === "sky_kingdom") {
      this.addLayer(0.05, (c,w,h) => this.buildSkyKingdomFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSkyKingdomMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSkyKingdomNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSkyKingdomFloor(c,w,h));
    } else if (theme === "storm_peaks") {
      this.addLayer(0.05, (c,w,h) => this.buildStormPeaksFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildStormPeaksMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildStormPeaksNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildStormPeaksFloor(c,w,h));
    } else if (theme === "star_bridge") {
      this.addLayer(0.05, (c,w,h) => this.buildStarBridgeFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildStarBridgeMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildStarBridgeNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildStarBridgeFloor(c,w,h));
    } else if (theme === "sky_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildSkyBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildSkyBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildSkyBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildSkyBossFloor(c,w,h));
    } else if (theme === "rainbow_road") {
      this.addLayer(0.05, (c,w,h) => this.buildRainbowRoadFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildRainbowRoadMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildRainbowRoadNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildRainbowRoadFloor(c,w,h));
    } else if (theme === "crystal_palace") {
      this.addLayer(0.05, (c,w,h) => this.buildCrystalPalaceFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildCrystalPalaceMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildCrystalPalaceNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildCrystalPalaceFloor(c,w,h));
    } else if (theme === "prismatic_falls") {
      this.addLayer(0.05, (c,w,h) => this.buildPrismaticFallsFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildPrismaticFallsMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildPrismaticFallsNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildPrismaticFallsFloor(c,w,h));
    } else if (theme === "rainbow_boss") {
      this.addLayer(0.05, (c,w,h) => this.buildRainbowBossFar(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildRainbowBossMid(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildRainbowBossNear(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildRainbowBossFloor(c,w,h));
    } else { // meadow (default)
      this.addLayer(0.05, (c,w,h) => this.buildFarMountains(c,w,h));
      this.addLayer(0.12, (c,w,h) => this.buildNearMountains(c,w,h));
      this.addLayer(0.25, (c,w,h) => this.buildHills(c,w,h));
      this.addLayer(0.4,  (c,w,h) => this.buildBushes(c,w,h));
    }
  }
  buildSky(ctx, w, h, colors, theme) {
    const grd = ctx.createLinearGradient(0, 0, 0, h);
    for (let i = 0; i < colors.length; i++) {
      grd.addColorStop(i / (colors.length - 1), colors[i]);
    }
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, w, h);
    const isWater = theme === "shallow_water" || theme === "deep_water" || theme === "boss_water" || theme === "sewer_flood" || theme === "sewer_boss";
    if (isWater) {
      // Underwater light rays from above
      const rng = new SeededRNG(12345);
      for (let i = 0; i < 8; i++) {
        const rx = rng.next() * w;
        const rw = 20 + rng.next() * 40;
        ctx.fillStyle = `rgba(100,180,255,${0.02 + rng.next() * 0.03})`;
        ctx.beginPath();
        ctx.moveTo(rx - rw/2, 0);
        ctx.lineTo(rx + rw/2, 0);
        ctx.lineTo(rx + rw * 1.5, h);
        ctx.lineTo(rx - rw, h);
        ctx.closePath();
        ctx.fill();
      }
    } else if (theme !== "cave" && theme !== "pyramid_interior" && theme !== "pyramid_boss") {
      const rng = new SeededRNG(12345);
      const count = theme === "clouds" || theme === "sky_kingdom" ? 30 : theme === "lakeside" ? 80 : theme === "desert" ? 60 : theme === "star_bridge" || theme === "sky_boss" ? 200 : theme === "rainbow_boss" || theme === "prismatic_falls" ? 60 : 120;
      for (let i = 0; i < count; i++) {
        const sx = rng.next() * w;
        const sy = rng.next() * h * 0.65;
        const sz = rng.nextFloat(0.5, 2);
        ctx.fillStyle = `rgba(255,255,255,${rng.nextFloat(0.3, 0.9)})`;
        ctx.beginPath();
        ctx.arc(sx, sy, sz, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  // === MEADOW theme ===
  buildFarMountains(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(54321);
    ctx.fillStyle = "#1a1040";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.35 + rng.next() * h * 0.25;
      const width = 80 + rng.next() * 120;
      ctx.lineTo(mx, h - peakH);
      mx += width;
      ctx.lineTo(mx, h - peakH * 0.4 - rng.next() * 30);
      mx += 30 + rng.next() * 40;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(200,180,255,0.15)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  buildNearMountains(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(99887);
    ctx.fillStyle = "#2a1850";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.25 + rng.next() * h * 0.2;
      const width = 60 + rng.next() * 100;
      ctx.lineTo(mx + width * 0.5, h - peakH);
      mx += width;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildHills(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22233);
    ctx.fillStyle = "#1a3a20";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 40 - Math.sin(x * 0.008 + 1) * 30 - Math.sin(x * 0.015) * 20 - rng.next() * 3;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    for (let i = 0; i < 40; i++) {
      const tx = rng.next() * w;
      const ty = h - 30 - Math.sin(tx * 0.008 + 1) * 30 - Math.sin(tx * 0.015) * 20;
      const th = 15 + rng.next() * 25;
      ctx.fillStyle = `rgba(15,${40+Math.floor(rng.next()*20)},20,0.9)`;
      ctx.beginPath();
      ctx.moveTo(tx, ty);
      ctx.lineTo(tx - 6 - rng.next()*4, ty + th);
      ctx.lineTo(tx + 6 + rng.next()*4, ty + th);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildBushes(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44455);
    for (let i = 0; i < 50; i++) {
      const bx = rng.next() * w;
      const by = h - 8 - rng.next() * 30;
      const bw = 10 + rng.next() * 20;
      const bh = 6 + rng.next() * 10;
      ctx.fillStyle = `rgba(${20+Math.floor(rng.next()*15)},${60+Math.floor(rng.next()*30)},${20+Math.floor(rng.next()*15)},0.6)`;
      ctx.beginPath();
      ctx.ellipse(bx, by, bw, bh, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === CAVE theme ===
  buildCaveFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(67890);
    // Stalactites from ceiling
    ctx.fillStyle = "#151530";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    let mx = 0;
    while (mx < w) {
      const drop = h * 0.15 + rng.next() * h * 0.2;
      const width = 30 + rng.next() * 60;
      ctx.lineTo(mx + width * 0.5, drop);
      mx += width;
    }
    ctx.lineTo(w, 0);
    ctx.closePath();
    ctx.fill();
    // Rock wall base
    ctx.fillStyle = "#12122a";
    ctx.beginPath();
    ctx.moveTo(0, h);
    mx = 0;
    while (mx < w) {
      const rise = h * 0.15 + rng.next() * h * 0.12;
      ctx.lineTo(mx, h - rise);
      mx += 40 + rng.next() * 60;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildCaveMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(78901);
    // Mid stalactites
    ctx.fillStyle = "#1a1a3a";
    for (let i = 0; i < 20; i++) {
      const sx = rng.next() * w;
      const sw = 8 + rng.next() * 15;
      const sh = 20 + rng.next() * 40;
      ctx.beginPath();
      ctx.moveTo(sx - sw/2, 0);
      ctx.lineTo(sx, sh);
      ctx.lineTo(sx + sw/2, 0);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildCaveNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(89012);
    // Glowing crystal formations
    const crystalColors = ["#4466aa","#6644aa","#44aa88","#aa4488"];
    for (let i = 0; i < 25; i++) {
      const cx = rng.next() * w;
      const cy = h - 20 - rng.next() * 50;
      const cs = 4 + rng.next() * 8;
      const clr = crystalColors[Math.floor(rng.next() * crystalColors.length)];
      ctx.fillStyle = clr;
      ctx.globalAlpha = 0.4 + rng.next() * 0.3;
      ctx.beginPath();
      ctx.moveTo(cx, cy - cs);
      ctx.lineTo(cx + cs * 0.4, cy);
      ctx.lineTo(cx, cy + cs * 0.3);
      ctx.lineTo(cx - cs * 0.4, cy);
      ctx.closePath();
      ctx.fill();
      // Crystal glow
      ctx.fillStyle = clr;
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.arc(cx, cy, cs * 1.5, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildCaveFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(90123);
    // Rock debris on floor
    for (let i = 0; i < 40; i++) {
      const rx = rng.next() * w;
      const ry = h - 5 - rng.next() * 25;
      const rw = 4 + rng.next() * 10;
      const rh = 3 + rng.next() * 6;
      ctx.fillStyle = `rgba(${30+Math.floor(rng.next()*20)},${30+Math.floor(rng.next()*20)},${50+Math.floor(rng.next()*20)},0.5)`;
      ctx.beginPath();
      ctx.ellipse(rx, ry, rw, rh, rng.next() * 0.5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === FOREST theme ===
  buildForestFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33344);
    // Distant dark treeline
    ctx.fillStyle = "#0a1a0a";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.4 + rng.next() * h * 0.2;
      ctx.lineTo(mx, h - peakH);
      mx += 15 + rng.next() * 25;
      ctx.lineTo(mx, h - peakH * 0.7);
      mx += 10 + rng.next() * 15;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildForestMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44455);
    ctx.fillStyle = "#0c220c";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 3) {
      const y = h - 50 - Math.sin(x * 0.006) * 25 - Math.sin(x * 0.018) * 15 - rng.next() * 10;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Tree trunks
    for (let i = 0; i < 25; i++) {
      const tx = rng.next() * w;
      ctx.fillStyle = `rgba(40,25,10,0.8)`;
      ctx.fillRect(tx - 2, h - 60, 4, 60);
    }
  }
  buildForestNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55566);
    // Thick canopy layers
    for (let i = 0; i < 60; i++) {
      const tx = rng.next() * w;
      const ty = h - 20 - rng.next() * 60;
      const tw = 12 + rng.next() * 20;
      const th = 10 + rng.next() * 18;
      const g = 30 + Math.floor(rng.next() * 40);
      ctx.fillStyle = `rgba(${10+Math.floor(rng.next()*15)},${g},${10+Math.floor(rng.next()*10)},0.7)`;
      ctx.beginPath();
      ctx.ellipse(tx, ty, tw, th, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildForestFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66677);
    // Ferns and undergrowth
    for (let i = 0; i < 50; i++) {
      const fx = rng.next() * w;
      const fy = h - 3 - rng.next() * 20;
      const fw = 6 + rng.next() * 12;
      const fh = 4 + rng.next() * 8;
      ctx.fillStyle = `rgba(${20+Math.floor(rng.next()*15)},${50+Math.floor(rng.next()*30)},${15+Math.floor(rng.next()*10)},0.5)`;
      ctx.beginPath();
      ctx.ellipse(fx, fy, fw, fh, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Mushrooms
    for (let i = 0; i < 10; i++) {
      const mx = rng.next() * w;
      const my = h - 5 - rng.next() * 15;
      ctx.fillStyle = "rgba(180,60,60,0.4)";
      ctx.beginPath();
      ctx.ellipse(mx, my - 3, 4, 3, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(150,140,100,0.3)";
      ctx.fillRect(mx - 1, my - 1, 2, 5);
    }
  }
  // === CLOUD theme ===
  buildCloudsFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(11122);
    // Distant puffy clouds
    for (let i = 0; i < 15; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.3 + rng.next() * h * 0.3;
      const cw = 40 + rng.next() * 60;
      const ch = 15 + rng.next() * 20;
      ctx.fillStyle = `rgba(255,255,255,${0.08 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.ellipse(cx, cy, cw, ch, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - cw * 0.3, cy - ch * 0.3, cw * 0.6, ch * 0.7, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildCloudsMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    // Rainbow arc
    const rainbow = ["#ff000030","#ff880030","#ffff0030","#00ff0030","#0088ff30","#8800cc30"];
    const cx = w * 0.5, cy = h * 1.2;
    for (let i = 0; i < rainbow.length; i++) {
      ctx.strokeStyle = rainbow[i];
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(cx, cy, h * 0.8 + i * 8, Math.PI, 0);
      ctx.stroke();
    }
  }
  buildCloudsNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22233);
    // Nearer, bigger clouds
    for (let i = 0; i < 10; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.5 + rng.next() * h * 0.3;
      const cw = 50 + rng.next() * 80;
      const ch = 20 + rng.next() * 25;
      ctx.fillStyle = `rgba(255,255,255,${0.12 + rng.next() * 0.1})`;
      for (let j = 0; j < 3; j++) {
        ctx.beginPath();
        ctx.ellipse(cx + (j-1) * cw * 0.3, cy - j * 5, cw * 0.5, ch * 0.6, 0, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  buildCloudsWisp(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33344);
    // Thin cloud wisps in foreground
    for (let i = 0; i < 20; i++) {
      const sx = rng.next() * w;
      const sy = h * 0.4 + rng.next() * h * 0.4;
      const sw = 30 + rng.next() * 50;
      ctx.strokeStyle = `rgba(255,255,255,${0.06 + rng.next() * 0.06})`;
      ctx.lineWidth = 2 + rng.next() * 4;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(sx + sw * 0.5, sy - 10 + rng.next() * 20, sx + sw, sy + rng.next() * 10);
      ctx.stroke();
    }
  }
  // === LAKESIDE theme (2-1, Wisconsin autumn foliage with lake) ===
  buildLakeFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22201);
    // Distant autumn hills with fall color canopy
    const hillColors = ["#8a4420","#6a5a20","#9a5530","#5a6a28","#7a4828"];
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.3 + rng.next() * h * 0.25;
      const width = 60 + rng.next() * 100;
      ctx.lineTo(mx + width * 0.5, h - peakH);
      mx += width;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fillStyle = "#3a4a25";
    ctx.fill();
    // Autumn tree crowns on the hills
    for (let i = 0; i < 60; i++) {
      const tx = rng.next() * w;
      const hillY = h * 0.5 + rng.next() * h * 0.2;
      const tr = 8 + rng.next() * 15;
      ctx.fillStyle = hillColors[Math.floor(rng.next() * hillColors.length)];
      ctx.globalAlpha = 0.3 + rng.next() * 0.2;
      ctx.beginPath();
      ctx.ellipse(tx, hillY, tr, tr * 0.7, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildLakeMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22202);
    // Lake band in mid-distance (just a strip, not full screen)
    const lakeY = h * 0.65;
    const lakeH = h * 0.12;
    const grd = ctx.createLinearGradient(0, lakeY, 0, lakeY + lakeH);
    grd.addColorStop(0, "rgba(50,90,130,0.35)");
    grd.addColorStop(0.5, "rgba(40,80,120,0.3)");
    grd.addColorStop(1, "rgba(30,70,100,0.15)");
    ctx.fillStyle = grd;
    ctx.fillRect(0, lakeY, w, lakeH);
    // Ripples
    for (let i = 0; i < 20; i++) {
      const rx = rng.next() * w;
      const ry = lakeY + 3 + rng.next() * (lakeH - 6);
      const rw = 12 + rng.next() * 25;
      ctx.strokeStyle = `rgba(100,160,200,${0.12 + rng.next() * 0.1})`;
      ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.quadraticCurveTo(rx + rw * 0.5, ry - 1.5, rx + rw, ry);
      ctx.stroke();
    }
    // Treeline above the lake (near shore across the water)
    const autumnColors = ["#cc5522","#dd7733","#bb8825","#cc4418","#aa6630","#88aa30"];
    for (let i = 0; i < 40; i++) {
      const tx = rng.next() * w;
      const ty = lakeY - 2 - rng.next() * 18;
      const tw = 6 + rng.next() * 12;
      const th = 5 + rng.next() * 10;
      ctx.fillStyle = autumnColors[Math.floor(rng.next() * autumnColors.length)];
      ctx.globalAlpha = 0.25 + rng.next() * 0.15;
      ctx.beginPath();
      ctx.ellipse(tx, ty, tw, th, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildLakeNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22203);
    // Near autumn trees (birch trunks + colorful canopy)
    const leafColors = ["#cc4415","#dd7730","#ddaa22","#88aa30","#cc6620","#ee8833","#bbcc30"];
    for (let i = 0; i < 20; i++) {
      const tx = rng.next() * w;
      const treeH = 35 + rng.next() * 45;
      const baseY = h - 8 - rng.next() * 30;
      const topY = baseY - treeH;
      // Trunk (birch = light with dark marks, others = brown)
      const isBirch = rng.next() < 0.35;
      if (isBirch) {
        ctx.fillStyle = "rgba(200,195,180,0.5)";
        ctx.fillRect(tx - 2, topY + treeH * 0.3, 4, treeH * 0.7);
        // Birch marks
        ctx.fillStyle = "rgba(60,50,40,0.3)";
        for (let m = 0; m < 3; m++) {
          const my = topY + treeH * 0.4 + rng.next() * treeH * 0.5;
          ctx.fillRect(tx - 2, my, 4, 2);
        }
      } else {
        ctx.fillStyle = `rgba(${60+Math.floor(rng.next()*20)},${40+Math.floor(rng.next()*15)},${20+Math.floor(rng.next()*10)},0.5)`;
        ctx.fillRect(tx - 2, topY + treeH * 0.3, 4, treeH * 0.7);
      }
      // Canopy (autumn colors!)
      const canopyR = 10 + rng.next() * 16;
      for (let c = 0; c < 3; c++) {
        const cx = tx + (rng.next() - 0.5) * canopyR;
        const cy = topY + rng.next() * canopyR * 0.6;
        const cr = canopyR * (0.5 + rng.next() * 0.4);
        ctx.fillStyle = leafColors[Math.floor(rng.next() * leafColors.length)];
        ctx.globalAlpha = 0.35 + rng.next() * 0.2;
        ctx.beginPath();
        ctx.ellipse(cx, cy, cr, cr * 0.7, 0, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }
  buildLakeShore(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(22204);
    // Fallen leaves, ferns, undergrowth
    const leafColors = ["#cc5520","#dd8830","#ccaa22","#aa4418","#88aa28"];
    // Ferns and bushes
    for (let i = 0; i < 35; i++) {
      const bx = rng.next() * w;
      const by = h - 4 - rng.next() * 22;
      const bw = 6 + rng.next() * 12;
      const bh = 4 + rng.next() * 7;
      const isAutumn = rng.next() < 0.5;
      if (isAutumn) {
        ctx.fillStyle = leafColors[Math.floor(rng.next() * leafColors.length)];
        ctx.globalAlpha = 0.3 + rng.next() * 0.2;
      } else {
        ctx.fillStyle = `rgba(${30+Math.floor(rng.next()*20)},${55+Math.floor(rng.next()*30)},${20+Math.floor(rng.next()*10)},0.4)`;
        ctx.globalAlpha = 0.5;
      }
      ctx.beginPath();
      ctx.ellipse(bx, by, bw, bh, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Scattered fallen leaves on ground
    for (let i = 0; i < 25; i++) {
      const lx = rng.next() * w;
      const ly = h - 2 - rng.next() * 8;
      ctx.fillStyle = leafColors[Math.floor(rng.next() * leafColors.length)];
      ctx.globalAlpha = 0.2 + rng.next() * 0.15;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 2 + rng.next() * 3, 1 + rng.next() * 1.5, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    // Small rocks
    for (let i = 0; i < 10; i++) {
      const rx = rng.next() * w;
      const ry = h - 2 - rng.next() * 10;
      ctx.fillStyle = `rgba(${100+Math.floor(rng.next()*40)},${90+Math.floor(rng.next()*30)},${80+Math.floor(rng.next()*20)},0.25)`;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.ellipse(rx, ry, 3 + rng.next() * 4, 2 + rng.next() * 2, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  // === SHALLOW WATER theme (2-2, underwater coral reef) ===
  buildShallowFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33301);
    // Distant coral formations
    for (let i = 0; i < 20; i++) {
      const cx = rng.next() * w;
      const cy = h - rng.next() * h * 0.4;
      const cw = 20 + rng.next() * 40;
      const ch = 15 + rng.next() * 30;
      const colors = ["#aa3040","#cc6644","#aa6688","#884466","#cc8844"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.globalAlpha = 0.15 + rng.next() * 0.1;
      ctx.beginPath();
      // Branching coral shape
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx - cw * 0.3, cy - ch);
      ctx.lineTo(cx - cw * 0.1, cy - ch * 0.6);
      ctx.lineTo(cx + cw * 0.2, cy - ch * 0.9);
      ctx.lineTo(cx + cw * 0.4, cy - ch * 0.5);
      ctx.lineTo(cx + cw * 0.3, cy);
      ctx.closePath();
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildShallowMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33302);
    // Seaweed strands swaying
    for (let i = 0; i < 35; i++) {
      const sx = rng.next() * w;
      const sHeight = 30 + rng.next() * 50;
      const sy = h;
      const sway = 8 + rng.next() * 12;
      ctx.strokeStyle = `rgba(${20+Math.floor(rng.next()*30)},${80+Math.floor(rng.next()*60)},${20+Math.floor(rng.next()*20)},0.35)`;
      ctx.lineWidth = 2 + rng.next() * 2;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(sx + sway, sy - sHeight * 0.5, sx - sway * 0.5, sy - sHeight);
      ctx.stroke();
    }
  }
  buildShallowNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33303);
    // Nearer coral and anemones
    const colors = ["#ff5566","#ff8844","#ffaa55","#ee6688","#ff7744"];
    for (let i = 0; i < 18; i++) {
      const cx = rng.next() * w;
      const cy = h - 10 - rng.next() * 50;
      const cr = 6 + rng.next() * 12;
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.globalAlpha = 0.3 + rng.next() * 0.2;
      // Anemone tentacles
      for (let t = 0; t < 6; t++) {
        const angle = (t / 6) * Math.PI - Math.PI;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.quadraticCurveTo(
          cx + Math.cos(angle) * cr * 1.5, cy + Math.sin(angle) * cr * 1.5,
          cx + Math.cos(angle) * cr * 0.8, cy + Math.sin(angle) * cr * 2
        );
        ctx.lineWidth = 2;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.stroke();
      }
      // Anemone body
      ctx.beginPath();
      ctx.ellipse(cx, cy, cr, cr * 0.6, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildShallowFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33304);
    // Sandy ripples on ocean floor
    for (let i = 0; i < 40; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 20;
      const rw = 10 + rng.next() * 25;
      ctx.strokeStyle = `rgba(180,160,120,${0.1 + rng.next() * 0.1})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.quadraticCurveTo(rx + rw * 0.5, ry - 2, rx + rw, ry);
      ctx.stroke();
    }
    // Shells and pebbles
    for (let i = 0; i < 15; i++) {
      const sx = rng.next() * w;
      const sy = h - 2 - rng.next() * 10;
      ctx.fillStyle = `rgba(${200+Math.floor(rng.next()*50)},${180+Math.floor(rng.next()*40)},${150+Math.floor(rng.next()*40)},0.25)`;
      ctx.beginPath();
      ctx.ellipse(sx, sy, 2 + rng.next() * 3, 1 + rng.next() * 2, rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === DEEP WATER theme (2-3, dark depths) ===
  buildDeepFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44401);
    // Bioluminescent particles in distance
    for (let i = 0; i < 50; i++) {
      const px = rng.next() * w;
      const py = rng.next() * h;
      const pr = 1 + rng.next() * 3;
      const colors = ["#00ffaa","#44aaff","#ff44aa","#aaffee","#44ff88"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.globalAlpha = 0.1 + rng.next() * 0.15;
      ctx.beginPath();
      ctx.arc(px, py, pr, 0, Math.PI*2);
      ctx.fill();
      // Glow halo
      ctx.globalAlpha = 0.04;
      ctx.beginPath();
      ctx.arc(px, py, pr * 4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  buildDeepMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44402);
    // Kelp forest in mid-distance
    for (let i = 0; i < 20; i++) {
      const kx = rng.next() * w;
      const kh = 60 + rng.next() * 80;
      const segments = 5 + Math.floor(rng.next() * 4);
      ctx.strokeStyle = `rgba(15,${40+Math.floor(rng.next()*30)},20,0.3)`;
      ctx.lineWidth = 3 + rng.next() * 2;
      ctx.beginPath();
      ctx.moveTo(kx, h);
      let cx = kx;
      for (let s = 0; s < segments; s++) {
        cx += (rng.next() - 0.5) * 15;
        const sy = h - (kh / segments) * (s + 1);
        ctx.lineTo(cx, sy);
      }
      ctx.stroke();
      // Kelp leaves
      for (let s = 1; s < segments; s++) {
        const ly = h - (kh / segments) * s;
        const ldir = rng.next() < 0.5 ? -1 : 1;
        ctx.fillStyle = `rgba(20,${60+Math.floor(rng.next()*30)},30,0.25)`;
        ctx.beginPath();
        ctx.ellipse(kx + ldir * 8, ly, 6, 3, ldir * 0.3, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  buildDeepNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44403);
    // Anglerfish lights and dark shapes
    for (let i = 0; i < 6; i++) {
      const ax = rng.next() * w;
      const ay = h * 0.3 + rng.next() * h * 0.4;
      // Dark silhouette
      ctx.fillStyle = "rgba(5,8,15,0.25)";
      ctx.beginPath();
      ctx.ellipse(ax, ay, 12 + rng.next() * 8, 8 + rng.next() * 5, 0, 0, Math.PI*2);
      ctx.fill();
      // Lure light
      ctx.fillStyle = "rgba(100,255,200,0.3)";
      ctx.beginPath();
      ctx.arc(ax + 12, ay - 10, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(100,255,200,0.08)";
      ctx.beginPath();
      ctx.arc(ax + 12, ay - 10, 10, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildDeepFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44404);
    // Volcanic vents and dark rocks
    for (let i = 0; i < 30; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 20;
      const rw = 5 + rng.next() * 10;
      const rh = 3 + rng.next() * 6;
      ctx.fillStyle = `rgba(${20+Math.floor(rng.next()*15)},${20+Math.floor(rng.next()*15)},${30+Math.floor(rng.next()*20)},0.4)`;
      ctx.beginPath();
      ctx.ellipse(rx, ry, rw, rh, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Occasional thermal vent glow
    for (let i = 0; i < 4; i++) {
      const vx = rng.next() * w;
      ctx.fillStyle = "rgba(255,100,50,0.06)";
      ctx.beginPath();
      ctx.moveTo(vx - 5, h);
      ctx.lineTo(vx + 5, h);
      ctx.lineTo(vx + 15, h - 40);
      ctx.lineTo(vx - 15, h - 40);
      ctx.closePath();
      ctx.fill();
    }
  }
  // === BOSS WATER theme (2-4, kraken's lair) ===
  buildBossWaterFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55501);
    // Distant tentacle shadows
    for (let i = 0; i < 5; i++) {
      const tx = rng.next() * w;
      const ty = h * 0.2 + rng.next() * h * 0.5;
      ctx.strokeStyle = "rgba(40,15,50,0.2)";
      ctx.lineWidth = 8 + rng.next() * 6;
      ctx.beginPath();
      ctx.moveTo(tx, ty + 60);
      ctx.quadraticCurveTo(tx + 30, ty, tx - 20, ty - 40);
      ctx.stroke();
    }
    // Eerie particles
    for (let i = 0; i < 30; i++) {
      const px = rng.next() * w;
      const py = rng.next() * h;
      ctx.fillStyle = `rgba(${100+Math.floor(rng.next()*60)},40,${140+Math.floor(rng.next()*60)},${0.06 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.arc(px, py, 1 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildBossWaterMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55502);
    // Ink clouds
    for (let i = 0; i < 10; i++) {
      const cx = rng.next() * w;
      const cy = rng.next() * h;
      const cr = 30 + rng.next() * 50;
      ctx.fillStyle = `rgba(20,5,30,${0.05 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.ellipse(cx, cy, cr, cr * 0.6, rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildBossWaterNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55503);
    // Bone and wreckage debris
    for (let i = 0; i < 12; i++) {
      const bx = rng.next() * w;
      const by = h - 15 - rng.next() * 40;
      ctx.fillStyle = `rgba(${140+Math.floor(rng.next()*40)},${130+Math.floor(rng.next()*30)},${110+Math.floor(rng.next()*30)},0.15)`;
      ctx.save();
      ctx.translate(bx, by);
      ctx.rotate(rng.next() * Math.PI);
      ctx.fillRect(-8, -1, 16, 2);
      ctx.restore();
    }
  }
  buildBossWaterFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55504);
    // Dark volcanic rock floor
    for (let i = 0; i < 35; i++) {
      const rx = rng.next() * w;
      const ry = h - 2 - rng.next() * 18;
      ctx.fillStyle = `rgba(${15+Math.floor(rng.next()*15)},${8+Math.floor(rng.next()*10)},${20+Math.floor(rng.next()*15)},0.4)`;
      ctx.beginPath();
      ctx.ellipse(rx, ry, 4 + rng.next() * 8, 2 + rng.next() * 4, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Purple glow spots
    for (let i = 0; i < 6; i++) {
      const gx = rng.next() * w;
      ctx.fillStyle = "rgba(120,40,160,0.06)";
      ctx.beginPath();
      ctx.arc(gx, h - 5, 15 + rng.next() * 10, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === TREETOP theme (3-1: warm sunset canopy) ===
  buildTreetopFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33311);
    // Distant forest canopy silhouette
    ctx.fillStyle = "#1a2a10";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.5 + rng.next() * h * 0.2;
      ctx.lineTo(mx, h - peakH);
      mx += 12 + rng.next() * 20;
      ctx.lineTo(mx, h - peakH * 0.75);
      mx += 8 + rng.next() * 12;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildTreetopMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33322);
    // Tree trunks with bark texture
    for (let i = 0; i < 20; i++) {
      const tx = rng.next() * w;
      const tw = 6 + rng.next() * 10;
      ctx.fillStyle = `rgba(${50+Math.floor(rng.next()*30)},${30+Math.floor(rng.next()*20)},${15+Math.floor(rng.next()*10)},0.7)`;
      ctx.fillRect(tx - tw/2, h * 0.1, tw, h * 0.9);
      // Bark lines
      ctx.strokeStyle = `rgba(30,18,8,0.3)`;
      ctx.lineWidth = 1;
      for (let j = 0; j < 4; j++) {
        const ly = h * 0.15 + rng.next() * h * 0.7;
        ctx.beginPath(); ctx.moveTo(tx - tw/2 + 1, ly); ctx.lineTo(tx + tw/2 - 1, ly + 3); ctx.stroke();
      }
    }
    // Leaf clusters on trunks
    for (let i = 0; i < 40; i++) {
      const lx = rng.next() * w;
      const ly = h * 0.15 + rng.next() * h * 0.5;
      const lr = 8 + rng.next() * 15;
      const g = 60 + Math.floor(rng.next() * 50);
      ctx.fillStyle = `rgba(${30+Math.floor(rng.next()*20)},${g},${15+Math.floor(rng.next()*10)},0.5)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, lr, lr * 0.7, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildTreetopNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33333);
    // Near branches with leaves
    for (let i = 0; i < 30; i++) {
      const bx = rng.next() * w;
      const by = rng.next() * h * 0.6;
      const blen = 20 + rng.next() * 40;
      const bdir = rng.next() > 0.5 ? 1 : -1;
      ctx.strokeStyle = `rgba(60,35,15,0.6)`;
      ctx.lineWidth = 2 + rng.next() * 2;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.quadraticCurveTo(bx + blen * bdir * 0.5, by + 10, bx + blen * bdir, by + 5);
      ctx.stroke();
      // Leaves on branch
      for (let j = 0; j < 5; j++) {
        const lx = bx + (blen * bdir * (j + 1) / 6);
        const ly = by + 3 + rng.next() * 8;
        const g = 70 + Math.floor(rng.next() * 60);
        ctx.fillStyle = `rgba(${30+Math.floor(rng.next()*20)},${g},${10+Math.floor(rng.next()*15)},0.6)`;
        ctx.beginPath();
        ctx.ellipse(lx, ly, 5 + rng.next() * 6, 3 + rng.next() * 4, rng.next(), 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  buildTreetopFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(33344);
    // Hanging vines
    for (let i = 0; i < 25; i++) {
      const vx = rng.next() * w;
      const vlen = 15 + rng.next() * 30;
      ctx.strokeStyle = `rgba(40,80,20,${0.3 + rng.next() * 0.3})`;
      ctx.lineWidth = 1 + rng.next();
      ctx.beginPath();
      ctx.moveTo(vx, 0);
      ctx.quadraticCurveTo(vx + (rng.next() - 0.5) * 10, vlen * 0.5, vx + (rng.next() - 0.5) * 5, vlen);
      ctx.stroke();
      // Leaf at vine tip
      ctx.fillStyle = `rgba(50,100,25,0.5)`;
      ctx.beginPath();
      ctx.ellipse(vx + (rng.next()-0.5) * 3, vlen, 3, 2, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Falling leaves
    for (let i = 0; i < 12; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h;
      ctx.fillStyle = `rgba(${80+Math.floor(rng.next()*60)},${100+Math.floor(rng.next()*40)},${20+Math.floor(rng.next()*20)},0.3)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 2 + rng.next() * 3, 1 + rng.next() * 2, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === TREETOP_HIGH theme (3-2: bright sky, high up in canopy) ===
  buildTreetopHighFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44411);
    // Clouds below (you're high up!)
    for (let i = 0; i < 20; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.6 + rng.next() * h * 0.35;
      const cw = 30 + rng.next() * 50;
      const ch = 10 + rng.next() * 12;
      ctx.fillStyle = `rgba(255,255,255,${0.06 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.ellipse(cx, cy, cw, ch, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildTreetopHighMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44422);
    // Huge tree trunks stretching down
    for (let i = 0; i < 12; i++) {
      const tx = rng.next() * w;
      const tw = 10 + rng.next() * 18;
      ctx.fillStyle = `rgba(${40+Math.floor(rng.next()*20)},${25+Math.floor(rng.next()*15)},${12+Math.floor(rng.next()*8)},0.5)`;
      ctx.fillRect(tx - tw/2, 0, tw, h);
      // Bark detail
      ctx.strokeStyle = "rgba(25,15,5,0.2)";
      ctx.lineWidth = 1;
      for (let j = 0; j < 6; j++) {
        const ly = rng.next() * h;
        ctx.beginPath(); ctx.moveTo(tx - tw/2, ly); ctx.lineTo(tx + tw/2, ly + 2); ctx.stroke();
      }
    }
  }
  buildTreetopHighNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44433);
    // Sprawling branches at eye level
    for (let i = 0; i < 25; i++) {
      const bx = rng.next() * w;
      const by = h * 0.2 + rng.next() * h * 0.5;
      const blen = 30 + rng.next() * 50;
      const bdir = rng.next() > 0.5 ? 1 : -1;
      ctx.strokeStyle = `rgba(50,30,12,0.5)`;
      ctx.lineWidth = 2 + rng.next() * 3;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.bezierCurveTo(bx + blen * 0.3 * bdir, by - 15, bx + blen * 0.7 * bdir, by + 10, bx + blen * bdir, by - 5);
      ctx.stroke();
    }
    // Bright leaf clusters
    for (let i = 0; i < 45; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h * 0.7;
      const g = 80 + Math.floor(rng.next() * 60);
      ctx.fillStyle = `rgba(${40+Math.floor(rng.next()*25)},${g},${20+Math.floor(rng.next()*15)},0.4)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 6 + rng.next() * 10, 4 + rng.next() * 7, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildTreetopHighFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44444);
    // Wind-blown leaves drifting
    for (let i = 0; i < 20; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h;
      const colors = ["rgba(100,140,40,0.35)","rgba(120,160,50,0.3)","rgba(80,120,30,0.25)","rgba(140,100,30,0.3)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.beginPath();
      ctx.ellipse(lx, ly, 2 + rng.next() * 4, 1 + rng.next() * 2, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    // Light rays from above
    for (let i = 0; i < 5; i++) {
      const rx = rng.next() * w;
      const rw = 8 + rng.next() * 15;
      const grd = ctx.createLinearGradient(rx, 0, rx + rw, h);
      grd.addColorStop(0, "rgba(255,255,200,0.08)");
      grd.addColorStop(1, "rgba(255,255,200,0)");
      ctx.fillStyle = grd;
      ctx.fillRect(rx, 0, rw, h);
    }
  }
  // === TREETOP_DARK theme (3-3: stormy, dark canopy) ===
  buildTreetopDarkFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55511);
    // Rain streaks
    ctx.strokeStyle = "rgba(150,160,180,0.08)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 80; i++) {
      const rx = rng.next() * w;
      const ry = rng.next() * h;
      const rlen = 8 + rng.next() * 15;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx - 2, ry + rlen);
      ctx.stroke();
    }
    // Distant dark silhouette
    ctx.fillStyle = "#08080c";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.55 + rng.next() * h * 0.2;
      ctx.lineTo(mx, h - peakH);
      mx += 10 + rng.next() * 18;
      ctx.lineTo(mx, h - peakH * 0.8);
      mx += 8 + rng.next() * 10;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildTreetopDarkMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55522);
    // Dense dark canopy
    for (let i = 0; i < 50; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h * 0.6;
      const lr = 10 + rng.next() * 18;
      const g = 15 + Math.floor(rng.next() * 25);
      ctx.fillStyle = `rgba(${8+Math.floor(rng.next()*10)},${g},${8+Math.floor(rng.next()*8)},0.6)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, lr, lr * 0.6, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Dark trunks
    for (let i = 0; i < 15; i++) {
      const tx = rng.next() * w;
      ctx.fillStyle = `rgba(20,12,8,0.6)`;
      ctx.fillRect(tx - 3, 0, 6 + rng.next() * 6, h);
    }
  }
  buildTreetopDarkNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55533);
    // Gnarled branches
    for (let i = 0; i < 20; i++) {
      const bx = rng.next() * w;
      const by = rng.next() * h * 0.7;
      const blen = 25 + rng.next() * 45;
      const bdir = rng.next() > 0.5 ? 1 : -1;
      ctx.strokeStyle = `rgba(30,18,10,0.7)`;
      ctx.lineWidth = 2 + rng.next() * 3;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.bezierCurveTo(bx + blen * 0.4 * bdir, by - 20, bx + blen * 0.6 * bdir, by + 15, bx + blen * bdir, by + rng.next() * 10);
      ctx.stroke();
    }
    // Sparse dead leaves
    for (let i = 0; i < 15; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h;
      ctx.fillStyle = `rgba(${40+Math.floor(rng.next()*30)},${25+Math.floor(rng.next()*15)},${10+Math.floor(rng.next()*10)},0.4)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 3 + rng.next() * 4, 2 + rng.next() * 2, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildTreetopDarkFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55544);
    // Ground fog/mist
    for (let i = 0; i < 20; i++) {
      const fx = rng.next() * w;
      const fy = h - 5 - rng.next() * 20;
      const fw = 25 + rng.next() * 40;
      const fh = 8 + rng.next() * 12;
      ctx.fillStyle = `rgba(60,60,80,${0.05 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.ellipse(fx, fy, fw, fh, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // More rain
    ctx.strokeStyle = "rgba(140,150,170,0.06)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 40; i++) {
      const rx = rng.next() * w;
      const ry = rng.next() * h;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx - 1, ry + 6 + rng.next() * 8);
      ctx.stroke();
    }
  }
  // === TREETOP_BOSS theme (3-4: hawk's peak) ===
  buildTreetopBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66611);
    // Dead tree silhouettes
    for (let i = 0; i < 12; i++) {
      const tx = rng.next() * w;
      const th = h * 0.4 + rng.next() * h * 0.3;
      ctx.fillStyle = `rgba(${15+Math.floor(rng.next()*10)},${5+Math.floor(rng.next()*8)},${15+Math.floor(rng.next()*10)},0.6)`;
      ctx.fillRect(tx - 2, h - th, 4 + rng.next() * 4, th);
      // Dead branches
      for (let j = 0; j < 3; j++) {
        const by = h - th + rng.next() * th * 0.5;
        const bdir = rng.next() > 0.5 ? 1 : -1;
        const blen = 10 + rng.next() * 20;
        ctx.strokeStyle = `rgba(20,10,18,0.5)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(tx, by);
        ctx.lineTo(tx + blen * bdir, by - 5 - rng.next() * 10);
        ctx.stroke();
      }
    }
  }
  buildTreetopBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66622);
    // Cobwebs between trees
    for (let i = 0; i < 8; i++) {
      const cx = rng.next() * w;
      const cy = rng.next() * h * 0.5;
      const cr = 15 + rng.next() * 25;
      ctx.strokeStyle = `rgba(180,180,200,${0.06 + rng.next() * 0.06})`;
      ctx.lineWidth = 0.5;
      // Radial web lines
      for (let j = 0; j < 8; j++) {
        const angle = (j / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * cr, cy + Math.sin(angle) * cr);
        ctx.stroke();
      }
      // Spiral
      for (let r = 5; r < cr; r += 6) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    // Dark gnarled trunks
    for (let i = 0; i < 10; i++) {
      const tx = rng.next() * w;
      ctx.fillStyle = `rgba(18,8,15,0.6)`;
      ctx.fillRect(tx - 4, 0, 8 + rng.next() * 8, h);
    }
  }
  buildTreetopBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66633);
    // Glowing red eyes in darkness
    for (let i = 0; i < 8; i++) {
      const ex = rng.next() * w;
      const ey = h * 0.2 + rng.next() * h * 0.4;
      // Left eye
      ctx.fillStyle = `rgba(255,40,40,${0.15 + rng.next() * 0.15})`;
      ctx.beginPath(); ctx.arc(ex - 3, ey, 2, 0, Math.PI*2); ctx.fill();
      // Right eye
      ctx.beginPath(); ctx.arc(ex + 3, ey, 2, 0, Math.PI*2); ctx.fill();
      // Eye glow
      ctx.fillStyle = `rgba(255,30,30,0.03)`;
      ctx.beginPath(); ctx.arc(ex, ey, 10, 0, Math.PI*2); ctx.fill();
    }
    // Twisted branches reaching out
    for (let i = 0; i < 15; i++) {
      const bx = rng.next() * w;
      const by = rng.next() * h * 0.6;
      const blen = 15 + rng.next() * 30;
      ctx.strokeStyle = `rgba(25,12,20,0.5)`;
      ctx.lineWidth = 1.5 + rng.next() * 2;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      const bdir = rng.next() > 0.5 ? 1 : -1;
      ctx.bezierCurveTo(bx + blen * 0.3 * bdir, by - 10, bx + blen * 0.7 * bdir, by + 12, bx + blen * bdir, by + rng.next() * 8);
      ctx.stroke();
    }
  }
  buildTreetopBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66644);
    // Nest debris — twigs and scraps
    for (let i = 0; i < 30; i++) {
      const dx = rng.next() * w;
      const dy = h - 3 - rng.next() * 15;
      ctx.strokeStyle = `rgba(60,30,15,${0.3 + rng.next() * 0.2})`;
      ctx.lineWidth = 1;
      const dl = 3 + rng.next() * 8;
      const da = rng.next() * Math.PI;
      ctx.beginPath();
      ctx.moveTo(dx, dy);
      ctx.lineTo(dx + Math.cos(da) * dl, dy + Math.sin(da) * dl);
      ctx.stroke();
    }
    // Scattered bones/scraps
    for (let i = 0; i < 8; i++) {
      const bx = rng.next() * w;
      const by = h - 4 - rng.next() * 10;
      ctx.fillStyle = `rgba(180,170,150,${0.1 + rng.next() * 0.1})`;
      ctx.fillRect(bx, by, 2 + rng.next() * 4, 1 + rng.next() * 2);
    }
  }
  // === FAIRY theme (4-1: Enchanted waterfall forest) ===
  buildFairyFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44111);
    // Distant purple/pink mountain silhouettes
    for (let i = 0; i < 6; i++) {
      const mx = rng.next() * w;
      const mw = 80 + rng.next() * 120;
      const mh = 40 + rng.next() * 50;
      ctx.fillStyle = `rgba(${80+Math.floor(rng.next()*40)},${40+Math.floor(rng.next()*30)},${100+Math.floor(rng.next()*40)},${0.2 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.moveTo(mx - mw/2, h);
      ctx.lineTo(mx - mw/4, h - mh * 0.7);
      ctx.lineTo(mx, h - mh);
      ctx.lineTo(mx + mw/4, h - mh * 0.8);
      ctx.lineTo(mx + mw/2, h);
      ctx.closePath();
      ctx.fill();
    }
    // Cascading waterfall lines
    for (let i = 0; i < 8; i++) {
      const wx = rng.next() * w;
      const wy = rng.next() * h * 0.5;
      ctx.strokeStyle = `rgba(180,200,255,${0.08 + rng.next() * 0.06})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(wx, wy);
      ctx.lineTo(wx + (rng.next()-0.5) * 3, h);
      ctx.stroke();
    }
  }
  buildFairyMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44122);
    // Tall magical trees with glowing leaves
    for (let i = 0; i < 15; i++) {
      const tx = rng.next() * w;
      const th = 50 + rng.next() * 80;
      const tw = 6 + rng.next() * 10;
      // Trunk
      ctx.fillStyle = `rgba(${50+Math.floor(rng.next()*20)},${30+Math.floor(rng.next()*15)},${40+Math.floor(rng.next()*20)},0.4)`;
      ctx.fillRect(tx - tw/2, h - th, tw, th);
      // Canopy
      ctx.fillStyle = `rgba(${40+Math.floor(rng.next()*30)},${80+Math.floor(rng.next()*40)},${60+Math.floor(rng.next()*30)},0.35)`;
      ctx.beginPath();
      ctx.ellipse(tx, h - th - 10, 20 + rng.next() * 15, 15 + rng.next() * 10, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Fairy lights (small glowing dots)
    for (let i = 0; i < 30; i++) {
      const fx = rng.next() * w;
      const fy = rng.next() * h * 0.7;
      const colors = ["rgba(255,220,100,0.3)","rgba(200,150,255,0.25)","rgba(100,255,200,0.2)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.beginPath();
      ctx.arc(fx, fy, 1.5 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44133);
    // Waterfall mist particles
    for (let i = 0; i < 20; i++) {
      const mx = rng.next() * w;
      const my = h * 0.3 + rng.next() * h * 0.5;
      ctx.fillStyle = `rgba(200,220,255,${0.05 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.ellipse(mx, my, 15 + rng.next() * 20, 8 + rng.next() * 10, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Floating flower petals
    for (let i = 0; i < 18; i++) {
      const px = rng.next() * w;
      const py = rng.next() * h;
      const pc = ["rgba(255,150,180,0.3)","rgba(255,180,200,0.25)","rgba(220,140,255,0.2)"];
      ctx.fillStyle = pc[Math.floor(rng.next() * pc.length)];
      ctx.beginPath();
      ctx.ellipse(px, py, 2 + rng.next() * 3, 1 + rng.next() * 2, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44144);
    // Luminous mushrooms
    for (let i = 0; i < 15; i++) {
      const mx = rng.next() * w;
      const my = h - 5 - rng.next() * 12;
      const mc = ["rgba(180,100,255,0.4)","rgba(100,200,150,0.35)","rgba(255,150,100,0.3)"];
      ctx.fillStyle = mc[Math.floor(rng.next() * mc.length)];
      // Stem
      ctx.fillRect(mx - 1, my, 2, 5 + rng.next() * 4);
      // Cap
      ctx.beginPath();
      ctx.ellipse(mx, my, 4 + rng.next() * 4, 3 + rng.next() * 2, 0, Math.PI, Math.PI*2);
      ctx.fill();
    }
    // Fern clusters
    for (let i = 0; i < 12; i++) {
      const fx = rng.next() * w;
      const fy = h - 3 - rng.next() * 8;
      ctx.fillStyle = `rgba(40,${100+Math.floor(rng.next()*40)},50,0.3)`;
      ctx.beginPath();
      ctx.ellipse(fx, fy, 5 + rng.next() * 6, 3 + rng.next() * 3, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === FAIRY_MIST theme (4-2: Misty enchanted hollow) ===
  buildFairyMistFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44211);
    // Fog layers with ethereal glow
    for (let i = 0; i < 10; i++) {
      const fy = rng.next() * h;
      ctx.fillStyle = `rgba(${140+Math.floor(rng.next()*40)},${120+Math.floor(rng.next()*30)},${180+Math.floor(rng.next()*40)},${0.04 + rng.next() * 0.04})`;
      ctx.fillRect(0, fy, w, 20 + rng.next() * 30);
    }
    // Faint tree silhouettes
    for (let i = 0; i < 8; i++) {
      const tx = rng.next() * w;
      const th = 60 + rng.next() * 80;
      ctx.fillStyle = `rgba(60,40,80,${0.1 + rng.next() * 0.08})`;
      ctx.fillRect(tx - 5, h - th, 10, th);
      ctx.beginPath();
      ctx.ellipse(tx, h - th, 25 + rng.next() * 15, 20 + rng.next() * 10, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyMistMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44222);
    // Twisted ancient trees with glowing bark veins
    for (let i = 0; i < 10; i++) {
      const tx = rng.next() * w;
      const th = 40 + rng.next() * 60;
      const tw = 8 + rng.next() * 12;
      ctx.fillStyle = `rgba(50,30,50,0.5)`;
      ctx.fillRect(tx - tw/2, h - th, tw, th);
      // Glowing bark veins
      ctx.strokeStyle = `rgba(${100+Math.floor(rng.next()*60)},${200+Math.floor(rng.next()*55)},${140+Math.floor(rng.next()*60)},0.3)`;
      ctx.lineWidth = 1;
      for (let v = 0; v < 4; v++) {
        const vy = h - th + rng.next() * th;
        ctx.beginPath();
        ctx.moveTo(tx - tw/2, vy);
        ctx.quadraticCurveTo(tx, vy + (rng.next()-0.5) * 10, tx + tw/2, vy + (rng.next()-0.5) * 5);
        ctx.stroke();
      }
    }
    // Firefly particles
    for (let i = 0; i < 25; i++) {
      const fx = rng.next() * w;
      const fy = rng.next() * h * 0.8;
      ctx.fillStyle = `rgba(200,255,100,${0.2 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.arc(fx, fy, 1 + rng.next() * 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyMistNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44233);
    // Thick mist tendrils
    for (let i = 0; i < 15; i++) {
      const mx = rng.next() * w;
      const my = h * 0.4 + rng.next() * h * 0.4;
      ctx.fillStyle = `rgba(${160+Math.floor(rng.next()*40)},${150+Math.floor(rng.next()*30)},${200+Math.floor(rng.next()*40)},${0.06 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.ellipse(mx, my, 25 + rng.next() * 35, 8 + rng.next() * 12, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Hanging moss with glow spots
    for (let i = 0; i < 20; i++) {
      const mx = rng.next() * w;
      const my = rng.next() * h * 0.4;
      const ml = 10 + rng.next() * 20;
      ctx.strokeStyle = `rgba(50,80,40,0.3)`;
      ctx.lineWidth = 1 + rng.next();
      ctx.beginPath();
      ctx.moveTo(mx, my);
      ctx.quadraticCurveTo(mx + (rng.next()-0.5) * 6, my + ml * 0.5, mx + (rng.next()-0.5) * 3, my + ml);
      ctx.stroke();
      // Glow spot at tip
      ctx.fillStyle = `rgba(150,255,180,0.3)`;
      ctx.beginPath();
      ctx.arc(mx + (rng.next()-0.5) * 3, my + ml, 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyMistFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44244);
    // Glowing puddles
    for (let i = 0; i < 10; i++) {
      const px = rng.next() * w;
      const py = h - 4 - rng.next() * 6;
      ctx.fillStyle = `rgba(100,180,200,${0.15 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.ellipse(px, py, 8 + rng.next() * 12, 2 + rng.next() * 3, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Lily pads on puddles
    for (let i = 0; i < 8; i++) {
      const lx = rng.next() * w;
      const ly = h - 4 - rng.next() * 5;
      ctx.fillStyle = `rgba(60,120,40,0.3)`;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 3 + rng.next() * 3, 1.5 + rng.next() * 1.5, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === FAIRY_DARK theme (4-3: Deep crystal cave with waterfalls) ===
  buildFairyDarkFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44311);
    // Dark cavern walls with embedded crystals
    for (let i = 0; i < 12; i++) {
      const cx = rng.next() * w;
      const cy = rng.next() * h;
      const cs = 3 + rng.next() * 6;
      const colors = ["rgba(140,80,220,0.25)","rgba(80,120,220,0.2)","rgba(180,100,255,0.2)","rgba(100,200,255,0.15)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      // Crystal shape
      ctx.beginPath();
      ctx.moveTo(cx, cy - cs);
      ctx.lineTo(cx + cs * 0.5, cy);
      ctx.lineTo(cx, cy + cs * 0.3);
      ctx.lineTo(cx - cs * 0.5, cy);
      ctx.closePath();
      ctx.fill();
    }
    // Cave wall outline
    for (let i = 0; i < 8; i++) {
      const wx = rng.next() * w;
      ctx.fillStyle = `rgba(20,15,35,${0.15 + rng.next() * 0.1})`;
      ctx.fillRect(wx, 0, 30 + rng.next() * 40, h * 0.3 + rng.next() * h * 0.2);
    }
  }
  buildFairyDarkMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44322);
    // Crystal stalactite formations
    for (let i = 0; i < 12; i++) {
      const sx = rng.next() * w;
      const sl = 20 + rng.next() * 40;
      const sw = 4 + rng.next() * 6;
      const colors = ["rgba(140,80,220,0.4)","rgba(80,140,255,0.35)","rgba(180,100,255,0.3)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.beginPath();
      ctx.moveTo(sx - sw/2, 0);
      ctx.lineTo(sx + sw/2, 0);
      ctx.lineTo(sx + sw/4, sl);
      ctx.lineTo(sx - sw/4, sl);
      ctx.closePath();
      ctx.fill();
      // Light refraction beam
      ctx.strokeStyle = `rgba(200,180,255,0.08)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(sx, sl);
      ctx.lineTo(sx + (rng.next()-0.5) * 20, h);
      ctx.stroke();
    }
  }
  buildFairyDarkNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44333);
    // Waterfall curtains (vertical blue lines)
    for (let i = 0; i < 6; i++) {
      const wx = rng.next() * w;
      ctx.strokeStyle = `rgba(100,150,220,${0.1 + rng.next() * 0.08})`;
      ctx.lineWidth = 2 + rng.next() * 3;
      ctx.beginPath();
      ctx.moveTo(wx, 0);
      ctx.lineTo(wx + (rng.next()-0.5) * 5, h);
      ctx.stroke();
    }
    // Floating crystal shards
    for (let i = 0; i < 15; i++) {
      const cx = rng.next() * w;
      const cy = rng.next() * h;
      const cs = 2 + rng.next() * 4;
      ctx.fillStyle = `rgba(${150+Math.floor(rng.next()*60)},${120+Math.floor(rng.next()*60)},255,0.25)`;
      ctx.beginPath();
      ctx.moveTo(cx, cy - cs);
      ctx.lineTo(cx + cs * 0.4, cy);
      ctx.lineTo(cx, cy + cs * 0.3);
      ctx.lineTo(cx - cs * 0.4, cy);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildFairyDarkFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44344);
    // Glowing crystal rubble
    for (let i = 0; i < 18; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 10;
      const rs = 2 + rng.next() * 4;
      const colors = ["rgba(140,80,220,0.3)","rgba(80,160,255,0.25)","rgba(180,100,255,0.25)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.fillRect(rx, ry, rs, rs * 0.6);
    }
    // Dark water pools
    for (let i = 0; i < 6; i++) {
      const px = rng.next() * w;
      const py = h - 2 - rng.next() * 4;
      ctx.fillStyle = `rgba(20,30,60,0.3)`;
      ctx.beginPath();
      ctx.ellipse(px, py, 12 + rng.next() * 15, 2 + rng.next() * 2, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === FAIRY_BOSS theme (4-4: Flower boss garden arena) ===
  buildFairyBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44411);
    // Overgrown garden wall with thorny vines
    for (let i = 0; i < 10; i++) {
      const vx = rng.next() * w;
      const vy = rng.next() * h * 0.6;
      ctx.strokeStyle = `rgba(40,60,20,${0.2 + rng.next() * 0.15})`;
      ctx.lineWidth = 2 + rng.next() * 2;
      ctx.beginPath();
      ctx.moveTo(vx, 0);
      ctx.bezierCurveTo(vx + (rng.next()-0.5) * 30, vy * 0.3, vx + (rng.next()-0.5) * 30, vy * 0.7, vx + (rng.next()-0.5) * 20, vy);
      ctx.stroke();
      // Thorns
      for (let t = 0; t < 4; t++) {
        const ty = rng.next() * vy;
        ctx.fillStyle = "rgba(60,30,10,0.3)";
        ctx.beginPath();
        ctx.moveTo(vx + (rng.next()-0.5) * 8, ty);
        ctx.lineTo(vx + (rng.next()-0.5) * 5 + 5, ty - 3);
        ctx.lineTo(vx + (rng.next()-0.5) * 5, ty + 1);
        ctx.closePath();
        ctx.fill();
      }
    }
  }
  buildFairyBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44422);
    // Giant wilted flowers and twisted stems
    for (let i = 0; i < 8; i++) {
      const fx = rng.next() * w;
      const fh = 40 + rng.next() * 50;
      // Twisted stem
      ctx.strokeStyle = `rgba(50,60,20,0.4)`;
      ctx.lineWidth = 2 + rng.next() * 3;
      ctx.beginPath();
      ctx.moveTo(fx, h);
      ctx.quadraticCurveTo(fx + (rng.next()-0.5) * 20, h - fh * 0.5, fx + (rng.next()-0.5) * 10, h - fh);
      ctx.stroke();
      // Wilted flower head
      ctx.fillStyle = `rgba(${120+Math.floor(rng.next()*40)},${60+Math.floor(rng.next()*30)},${80+Math.floor(rng.next()*40)},0.3)`;
      ctx.beginPath();
      ctx.ellipse(fx + (rng.next()-0.5) * 10, h - fh, 8 + rng.next() * 6, 5 + rng.next() * 4, rng.next() * 0.5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildFairyBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44433);
    // Floating pollen/spores with golden glow
    for (let i = 0; i < 25; i++) {
      const px = rng.next() * w;
      const py = rng.next() * h;
      ctx.fillStyle = `rgba(255,${200+Math.floor(rng.next()*55)},${80+Math.floor(rng.next()*40)},${0.15 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.arc(px, py, 1 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
    // Thorn branches
    for (let i = 0; i < 10; i++) {
      const bx = rng.next() * w;
      const by = rng.next() * h * 0.6;
      const bl = 15 + rng.next() * 25;
      ctx.strokeStyle = `rgba(40,25,10,0.35)`;
      ctx.lineWidth = 1.5 + rng.next();
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(bx + bl * (rng.next() > 0.5 ? 1 : -1), by + (rng.next()-0.5) * 15);
      ctx.stroke();
    }
  }
  buildFairyBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(44454);
    // Cracked earth with roots
    for (let i = 0; i < 15; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 8;
      ctx.strokeStyle = `rgba(60,40,20,0.3)`;
      ctx.lineWidth = 1 + rng.next();
      const rl = 5 + rng.next() * 15;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx + (rng.next()-0.5) * rl, ry + rng.next() * 5);
      ctx.stroke();
    }
    // Scattered petals
    for (let i = 0; i < 20; i++) {
      const px = rng.next() * w;
      const py = h - 2 - rng.next() * 10;
      const pc = ["rgba(255,100,130,0.2)","rgba(255,150,170,0.15)","rgba(220,80,120,0.15)"];
      ctx.fillStyle = pc[Math.floor(rng.next() * pc.length)];
      ctx.beginPath();
      ctx.ellipse(px, py, 2 + rng.next() * 3, 1 + rng.next() * 1.5, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === SEWER theme (5-1): Dry sewer entrance ===
  buildSewerFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55111);
    // Brick wall silhouettes
    ctx.fillStyle = "#1a1a14";
    for (let bx = 0; bx < w; bx += 24) {
      for (let by = h * 0.3; by < h; by += 12) {
        const offset = (Math.floor(by / 12) % 2) * 12;
        ctx.fillRect(bx + offset, by, 22, 10);
        ctx.fillStyle = "#121210";
        ctx.fillRect(bx + offset, by + 10, 22, 2);
        ctx.fillStyle = "#1a1a14";
      }
    }
    // Distant pipe outlines
    for (let i = 0; i < 5; i++) {
      const px = rng.next() * w;
      const py = h * 0.2 + rng.next() * h * 0.3;
      const pr = 15 + rng.next() * 20;
      ctx.strokeStyle = "rgba(40,40,30,0.4)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(px, py, pr, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
  buildSewerMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55222);
    // Large pipe cross-sections
    for (let i = 0; i < 6; i++) {
      const px = rng.next() * w;
      const py = h * 0.3 + rng.next() * h * 0.3;
      const pr = 25 + rng.next() * 30;
      ctx.fillStyle = `rgba(30,30,22,0.6)`;
      ctx.beginPath();
      ctx.arc(px, py, pr, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(50,50,40,0.5)";
      ctx.lineWidth = 3;
      ctx.stroke();
      // Dark interior
      ctx.fillStyle = "rgba(5,5,3,0.8)";
      ctx.beginPath();
      ctx.arc(px, py, pr - 4, 0, Math.PI * 2);
      ctx.fill();
    }
    // Dripping water lines
    for (let i = 0; i < 12; i++) {
      const dx = rng.next() * w;
      const dy = rng.next() * h * 0.4;
      const dl = 10 + rng.next() * 30;
      ctx.strokeStyle = `rgba(60,80,70,${0.15 + rng.next() * 0.15})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(dx, dy);
      ctx.lineTo(dx + (rng.next() - 0.5) * 3, dy + dl);
      ctx.stroke();
    }
    // Grime patches
    for (let i = 0; i < 10; i++) {
      const gx = rng.next() * w;
      const gy = h * 0.5 + rng.next() * h * 0.3;
      ctx.fillStyle = `rgba(40,50,20,${0.1 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.ellipse(gx, gy, 8 + rng.next() * 15, 4 + rng.next() * 8, rng.next() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  buildSewerNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55333);
    // Hanging chains
    for (let i = 0; i < 8; i++) {
      const cx = rng.next() * w;
      const cl = 20 + rng.next() * 60;
      ctx.strokeStyle = `rgba(80,70,50,${0.3 + rng.next() * 0.2})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, 0);
      for (let y = 0; y < cl; y += 6) {
        ctx.lineTo(cx + Math.sin(y * 0.3) * 3, y);
      }
      ctx.stroke();
    }
    // Water drips (animated feel via position)
    for (let i = 0; i < 15; i++) {
      const dx = rng.next() * w;
      const dy = rng.next() * h * 0.6;
      ctx.fillStyle = `rgba(80,120,100,${0.2 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.arc(dx, dy, 1 + rng.next() * 2, 0, Math.PI * 2);
      ctx.fill();
    }
    // Steam vents
    for (let i = 0; i < 4; i++) {
      const sx = rng.next() * w;
      ctx.fillStyle = `rgba(80,80,70,${0.06 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.moveTo(sx - 3, h);
      ctx.quadraticCurveTo(sx + (rng.next() - 0.5) * 20, h - 30 - rng.next() * 40, sx + (rng.next() - 0.5) * 10, h - 50 - rng.next() * 30);
      ctx.quadraticCurveTo(sx + 15, h - 20, sx + 3, h);
      ctx.fill();
    }
  }
  buildSewerFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55444);
    // Puddles
    for (let i = 0; i < 12; i++) {
      const px = rng.next() * w;
      const py = h - 3 - rng.next() * 6;
      ctx.fillStyle = `rgba(40,60,50,${0.15 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.ellipse(px, py, 8 + rng.next() * 15, 2 + rng.next() * 3, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    // Debris
    for (let i = 0; i < 8; i++) {
      const dx = rng.next() * w;
      const dy = h - 2 - rng.next() * 5;
      ctx.fillStyle = `rgba(50,45,35,${0.3 + rng.next() * 0.2})`;
      ctx.fillRect(dx, dy, 3 + rng.next() * 6, 2 + rng.next() * 3);
    }
    // Tiny rat shapes
    for (let i = 0; i < 6; i++) {
      const rx = rng.next() * w;
      const ry = h - 4 - rng.next() * 3;
      ctx.fillStyle = `rgba(60,50,40,${0.2 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.ellipse(rx, ry, 3, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      // tail
      ctx.strokeStyle = `rgba(60,50,40,0.15)`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(rx - 3, ry);
      ctx.quadraticCurveTo(rx - 6, ry - 2, rx - 8, ry - 4);
      ctx.stroke();
    }
  }
  // === SEWER FLOOD theme (5-2): Flooded tunnels (underwater) ===
  buildSewerFloodFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55211);
    // Submerged brick walls with murky tint
    for (let bx = 0; bx < w; bx += 26) {
      for (let by = h * 0.2; by < h; by += 14) {
        const offset = (Math.floor(by / 14) % 2) * 13;
        ctx.fillStyle = `rgba(20,30,18,${0.3 + rng.next() * 0.2})`;
        ctx.fillRect(bx + offset, by, 24, 12);
      }
    }
    // Murky green-brown tint overlay
    ctx.fillStyle = "rgba(20,40,15,0.1)";
    ctx.fillRect(0, 0, w, h);
  }
  buildSewerFloodMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55222);
    // Underwater pipe openings
    for (let i = 0; i < 5; i++) {
      const px = rng.next() * w;
      const py = h * 0.25 + rng.next() * h * 0.4;
      const pr = 20 + rng.next() * 25;
      ctx.fillStyle = `rgba(15,25,12,0.5)`;
      ctx.beginPath();
      ctx.arc(px, py, pr, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(5,10,5,0.7)";
      ctx.beginPath();
      ctx.arc(px, py, pr - 4, 0, Math.PI * 2);
      ctx.fill();
    }
    // Submerged debris
    for (let i = 0; i < 10; i++) {
      const dx = rng.next() * w;
      const dy = h * 0.4 + rng.next() * h * 0.4;
      ctx.fillStyle = `rgba(30,40,25,${0.15 + rng.next() * 0.1})`;
      ctx.fillRect(dx, dy, 5 + rng.next() * 12, 3 + rng.next() * 6);
    }
  }
  buildSewerFloodNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55233);
    // Floating garbage
    for (let i = 0; i < 8; i++) {
      const fx = rng.next() * w;
      const fy = rng.next() * h * 0.7;
      ctx.fillStyle = `rgba(50,60,40,${0.15 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.ellipse(fx, fy, 4 + rng.next() * 8, 2 + rng.next() * 4, rng.next() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
    }
    // Bubble streams
    for (let i = 0; i < 6; i++) {
      const bx = rng.next() * w;
      for (let j = 0; j < 5; j++) {
        const by = h - rng.next() * h;
        const br = 1 + rng.next() * 2;
        ctx.fillStyle = `rgba(80,120,80,${0.08 + rng.next() * 0.08})`;
        ctx.beginPath();
        ctx.arc(bx + (rng.next() - 0.5) * 8, by, br, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    // Murky particles
    for (let i = 0; i < 20; i++) {
      const mx = rng.next() * w;
      const my = rng.next() * h;
      ctx.fillStyle = `rgba(60,80,50,${0.06 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.arc(mx, my, 1 + rng.next() * 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  buildSewerFloodFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55244);
    // Sludge and sediment
    for (let i = 0; i < 15; i++) {
      const sx = rng.next() * w;
      const sy = h - 2 - rng.next() * 8;
      ctx.fillStyle = `rgba(30,40,20,${0.2 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.ellipse(sx, sy, 10 + rng.next() * 20, 2 + rng.next() * 4, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // === SEWER DEEP theme (5-3): Deep underworks (dry) ===
  buildSewerDeepFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55311);
    // Ancient stone walls
    for (let bx = 0; bx < w; bx += 30) {
      for (let by = h * 0.15; by < h; by += 18) {
        const offset = (Math.floor(by / 18) % 2) * 15;
        ctx.fillStyle = `rgba(18,18,14,${0.4 + rng.next() * 0.2})`;
        ctx.fillRect(bx + offset, by, 28, 16);
        ctx.strokeStyle = "rgba(10,10,8,0.3)";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(bx + offset, by, 28, 16);
      }
    }
    // Cave formations (stalactites)
    for (let i = 0; i < 8; i++) {
      const sx = rng.next() * w;
      const sl = 15 + rng.next() * 25;
      ctx.fillStyle = `rgba(25,22,18,0.4)`;
      ctx.beginPath();
      ctx.moveTo(sx - 4, 0);
      ctx.lineTo(sx, sl);
      ctx.lineTo(sx + 4, 0);
      ctx.fill();
    }
  }
  buildSewerDeepMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55322);
    // Massive industrial pipes
    for (let i = 0; i < 4; i++) {
      const px = rng.next() * w;
      const py = h * 0.2 + rng.next() * h * 0.4;
      const pw = 30 + rng.next() * 40;
      const ph = 15 + rng.next() * 10;
      ctx.fillStyle = `rgba(40,35,25,0.4)`;
      ctx.fillRect(px - pw/2, py - ph/2, pw, ph);
      // Rust patches
      ctx.fillStyle = `rgba(80,40,20,${0.1 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.ellipse(px + (rng.next()-0.5)*pw*0.6, py, 5+rng.next()*8, 3+rng.next()*4, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Warning signs (yellow triangles)
    for (let i = 0; i < 3; i++) {
      const wx = rng.next() * w;
      const wy = h * 0.3 + rng.next() * h * 0.3;
      ctx.fillStyle = `rgba(180,160,20,${0.1 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.moveTo(wx, wy - 6);
      ctx.lineTo(wx + 5, wy + 4);
      ctx.lineTo(wx - 5, wy + 4);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildSewerDeepNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55333);
    // Dripping toxic green water
    for (let i = 0; i < 10; i++) {
      const dx = rng.next() * w;
      const dy = rng.next() * h * 0.5;
      const dl = 8 + rng.next() * 25;
      ctx.strokeStyle = `rgba(60,120,40,${0.12 + rng.next() * 0.1})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(dx, dy);
      ctx.lineTo(dx + (rng.next()-0.5)*4, dy + dl);
      ctx.stroke();
      // Drip at bottom
      ctx.fillStyle = `rgba(60,120,40,${0.15 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.arc(dx + (rng.next()-0.5)*4, dy + dl, 2, 0, Math.PI*2);
      ctx.fill();
    }
    // Sparking wires
    for (let i = 0; i < 4; i++) {
      const sx = rng.next() * w;
      const sy = rng.next() * h * 0.4;
      ctx.strokeStyle = `rgba(100,80,30,${0.15 + rng.next() * 0.1})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(sx, 0);
      ctx.quadraticCurveTo(sx + (rng.next()-0.5)*20, sy*0.5, sx + (rng.next()-0.5)*10, sy);
      ctx.stroke();
      // Spark
      ctx.fillStyle = `rgba(255,220,80,${0.1 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.arc(sx + (rng.next()-0.5)*10, sy, 2, 0, Math.PI*2);
      ctx.fill();
    }
    // Cobwebs
    for (let i = 0; i < 5; i++) {
      const cx = rng.next() * w;
      ctx.strokeStyle = `rgba(100,100,80,${0.06 + rng.next() * 0.06})`;
      ctx.lineWidth = 0.5;
      for (let r = 0; r < 4; r++) {
        const angle = rng.next() * Math.PI * 0.5;
        const len = 8 + rng.next() * 15;
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx + Math.cos(angle)*len, Math.sin(angle)*len);
        ctx.stroke();
      }
    }
  }
  buildSewerDeepFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55344);
    // Broken tiles
    for (let i = 0; i < 15; i++) {
      const tx = rng.next() * w;
      const ty = h - 2 - rng.next() * 6;
      const tw = 3 + rng.next() * 8;
      const th = 2 + rng.next() * 3;
      ctx.fillStyle = `rgba(45,42,35,${0.2 + rng.next() * 0.15})`;
      ctx.fillRect(tx, ty, tw, th);
    }
    // Rubble
    for (let i = 0; i < 10; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 4;
      ctx.fillStyle = `rgba(50,45,35,${0.2 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.arc(rx, ry, 1 + rng.next() * 3, 0, Math.PI * 2);
      ctx.fill();
    }
    // Toxic puddles (green)
    for (let i = 0; i < 5; i++) {
      const px = rng.next() * w;
      const py = h - 2 - rng.next() * 4;
      ctx.fillStyle = `rgba(40,80,30,${0.1 + rng.next() * 0.1})`;
      ctx.beginPath();
      ctx.ellipse(px, py, 6 + rng.next() * 12, 2 + rng.next() * 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // === SEWER BOSS theme (5-4): Rat King's den (underwater) ===
  buildSewerBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55411);
    // Nest-like cavern with bones and pipes
    ctx.fillStyle = "rgba(20,15,10,0.3)";
    ctx.beginPath();
    ctx.moveTo(0, h * 0.3);
    for (let x = 0; x < w; x += 8) {
      ctx.lineTo(x, h * 0.25 + Math.sin(x * 0.02) * 15 + rng.next() * 10);
    }
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.fill();
    // Distant pipes in walls
    for (let i = 0; i < 6; i++) {
      const px = rng.next() * w;
      const py = h * 0.2 + rng.next() * h * 0.3;
      ctx.fillStyle = `rgba(25,20,14,0.3)`;
      ctx.beginPath();
      ctx.arc(px, py, 12 + rng.next() * 15, 0, Math.PI * 2);
      ctx.fill();
    }
    // Bone silhouettes
    for (let i = 0; i < 8; i++) {
      const bx = rng.next() * w;
      const by = h * 0.4 + rng.next() * h * 0.3;
      ctx.strokeStyle = `rgba(60,55,45,${0.15 + rng.next() * 0.1})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(bx + 8 + rng.next() * 10, by + (rng.next()-0.5) * 6);
      ctx.stroke();
    }
  }
  buildSewerBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55422);
    // Shredded nest material
    for (let i = 0; i < 15; i++) {
      const nx = rng.next() * w;
      const ny = h * 0.4 + rng.next() * h * 0.4;
      ctx.strokeStyle = `rgba(60,45,25,${0.12 + rng.next() * 0.1})`;
      ctx.lineWidth = 1 + rng.next();
      ctx.beginPath();
      ctx.moveTo(nx, ny);
      ctx.quadraticCurveTo(nx + (rng.next()-0.5)*20, ny + rng.next()*10, nx + (rng.next()-0.5)*15, ny + 5 + rng.next()*8);
      ctx.stroke();
    }
    // Scattered cheese wedges
    for (let i = 0; i < 5; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.5 + rng.next() * h * 0.3;
      ctx.fillStyle = `rgba(180,150,40,${0.08 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.moveTo(cx, cy - 4);
      ctx.lineTo(cx + 5, cy + 3);
      ctx.lineTo(cx - 5, cy + 3);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildSewerBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55433);
    // Floating bones
    for (let i = 0; i < 8; i++) {
      const bx = rng.next() * w;
      const by = rng.next() * h * 0.7;
      ctx.fillStyle = `rgba(70,65,55,${0.12 + rng.next() * 0.08})`;
      ctx.beginPath();
      ctx.ellipse(bx, by, 4 + rng.next() * 6, 1.5 + rng.next() * 2, rng.next() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
      // Bone ends
      ctx.beginPath();
      ctx.arc(bx - 4, by, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(bx + 4, by, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    // Murky particles
    for (let i = 0; i < 20; i++) {
      const mx = rng.next() * w;
      const my = rng.next() * h;
      ctx.fillStyle = `rgba(50,40,25,${0.05 + rng.next() * 0.06})`;
      ctx.beginPath();
      ctx.arc(mx, my, 1 + rng.next() * 2.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  buildSewerBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(55444);
    // Nest floor debris
    for (let i = 0; i < 20; i++) {
      const dx = rng.next() * w;
      const dy = h - 2 - rng.next() * 8;
      ctx.fillStyle = `rgba(45,35,20,${0.15 + rng.next() * 0.15})`;
      ctx.beginPath();
      ctx.ellipse(dx, dy, 3 + rng.next() * 8, 1 + rng.next() * 3, rng.next() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
    }
    // Scattered small bones
    for (let i = 0; i < 8; i++) {
      const bx = rng.next() * w;
      const by = h - 3 - rng.next() * 5;
      ctx.strokeStyle = `rgba(70,65,50,${0.15 + rng.next() * 0.1})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(bx + 4 + rng.next() * 6, by + (rng.next()-0.5) * 3);
      ctx.stroke();
    }
  }
  // === DESERT theme ===
  buildDesertFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66001);
    // Sun disk
    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    ctx.arc(w * 0.7, h * 0.22, 25, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,215,0,0.15)";
    ctx.beginPath();
    ctx.arc(w * 0.7, h * 0.22, 45, 0, Math.PI*2);
    ctx.fill();
    // Distant pyramid silhouettes
    for (let i = 0; i < 4; i++) {
      const px = 80 + rng.next() * (w - 160);
      const pw = 50 + rng.next() * 80;
      const ph = 30 + rng.next() * 50;
      ctx.fillStyle = `rgba(${140 + Math.floor(rng.next()*30)},${110 + Math.floor(rng.next()*30)},${60 + Math.floor(rng.next()*20)},0.5)`;
      ctx.beginPath();
      ctx.moveTo(px, h * 0.7);
      ctx.lineTo(px + pw/2, h * 0.7 - ph);
      ctx.lineTo(px + pw, h * 0.7);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildDesertMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66002);
    // Rolling sand dunes
    ctx.fillStyle = "#c49850";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 35 - Math.sin(x * 0.006 + 0.5) * 25 - Math.sin(x * 0.013) * 15 - rng.next() * 2;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Dune highlights
    ctx.strokeStyle = "rgba(255,220,150,0.2)";
    ctx.lineWidth = 1;
    for (let x = 0; x < w; x += 8) {
      const y = h - 35 - Math.sin(x * 0.006 + 0.5) * 25 - Math.sin(x * 0.013) * 15;
      ctx.beginPath();
      ctx.moveTo(x, y); ctx.lineTo(x + 6, y + 1);
      ctx.stroke();
    }
  }
  buildDesertNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66003);
    // Larger dunes
    ctx.fillStyle = "#b8884a";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 22 - Math.sin(x * 0.009) * 18 - Math.sin(x * 0.018 + 2) * 10 - rng.next() * 3;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Palm tree silhouettes
    for (let i = 0; i < 6; i++) {
      const tx = rng.next() * w;
      const tBase = h - 15 - Math.sin(tx * 0.009) * 18 - Math.sin(tx * 0.018 + 2) * 10;
      const th = 20 + rng.next() * 30;
      ctx.strokeStyle = "rgba(80,60,30,0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(tx, tBase);
      ctx.quadraticCurveTo(tx + rng.next() * 8 - 4, tBase - th * 0.6, tx + 2, tBase - th);
      ctx.stroke();
      // Fronds
      ctx.fillStyle = "rgba(60,90,30,0.5)";
      for (let f = 0; f < 5; f++) {
        const angle = -Math.PI * 0.7 + f * 0.35;
        ctx.beginPath();
        ctx.moveTo(tx + 2, tBase - th);
        ctx.quadraticCurveTo(
          tx + 2 + Math.cos(angle) * 12, tBase - th + Math.sin(angle) * 6,
          tx + 2 + Math.cos(angle) * 18, tBase - th + Math.sin(angle) * 14
        );
        ctx.lineTo(tx + 2 + Math.cos(angle) * 16, tBase - th + Math.sin(angle) * 14 + 2);
        ctx.quadraticCurveTo(tx + 2 + Math.cos(angle) * 8, tBase - th + Math.sin(angle) * 4 + 2, tx + 2, tBase - th);
        ctx.fill();
      }
    }
  }
  buildDesertFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66004);
    // Sand ripples
    ctx.strokeStyle = "rgba(180,150,100,0.15)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 30; i++) {
      const rx = rng.next() * w;
      const ry = h - 3 - rng.next() * 12;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.quadraticCurveTo(rx + 8, ry - 1, rx + 16, ry);
      ctx.stroke();
    }
    // Scattered rocks
    for (let i = 0; i < 12; i++) {
      const rx = rng.next() * w;
      const ry = h - 2 - rng.next() * 6;
      ctx.fillStyle = `rgba(${100 + Math.floor(rng.next()*40)},${80 + Math.floor(rng.next()*30)},${50 + Math.floor(rng.next()*20)},0.4)`;
      ctx.beginPath();
      ctx.ellipse(rx, ry, 2 + rng.next() * 4, 1 + rng.next() * 2, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Small cacti silhouettes
    for (let i = 0; i < 4; i++) {
      const cx = rng.next() * w;
      const cy = h - 5 - rng.next() * 8;
      ctx.fillStyle = `rgba(40,70,30,0.35)`;
      ctx.fillRect(cx, cy, 3, 8);
      ctx.fillRect(cx - 3, cy + 2, 3, 3);
      ctx.fillRect(cx + 3, cy + 3, 3, 3);
    }
  }

  // === PYRAMID INTERIOR theme ===
  buildPyramidFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66011);
    // Stone block wall texture
    ctx.fillStyle = "#4a4030";
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = "#3a3020";
    ctx.lineWidth = 1;
    for (let row = 0; row < h; row += 14) {
      const offset = (row / 14) % 2 === 0 ? 0 : 18;
      for (let col = offset; col < w; col += 36) {
        ctx.strokeRect(col, row, 36, 14);
        // Subtle variation
        ctx.fillStyle = `rgba(${50 + Math.floor(rng.next()*20)},${40 + Math.floor(rng.next()*15)},${25 + Math.floor(rng.next()*10)},0.15)`;
        ctx.fillRect(col + 1, row + 1, 34, 12);
      }
    }
  }
  buildPyramidMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66012);
    // Hieroglyph panels
    for (let i = 0; i < 5; i++) {
      const px = rng.next() * (w - 50);
      const py = h * 0.3 + rng.next() * (h * 0.4);
      const pw = 30 + rng.next() * 30;
      const ph = 20 + rng.next() * 25;
      // Panel background
      ctx.fillStyle = "rgba(90,80,55,0.25)";
      ctx.fillRect(px, py, pw, ph);
      ctx.strokeStyle = "rgba(120,100,60,0.3)";
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, pw, ph);
      // Simplified hieroglyph symbols
      ctx.fillStyle = "rgba(140,120,70,0.25)";
      for (let s = 0; s < 4; s++) {
        const sx = px + 4 + rng.next() * (pw - 10);
        const sy = py + 4 + rng.next() * (ph - 10);
        const shape = Math.floor(rng.next() * 3);
        if (shape === 0) { ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill(); }
        else if (shape === 1) { ctx.fillRect(sx-2, sy-3, 4, 6); }
        else { ctx.beginPath(); ctx.moveTo(sx,sy-3); ctx.lineTo(sx+3,sy+3); ctx.lineTo(sx-3,sy+3); ctx.closePath(); ctx.fill(); }
      }
    }
    // Torch brackets
    for (let i = 0; i < 4; i++) {
      const tx = 40 + rng.next() * (w - 80);
      const ty = h * 0.2 + rng.next() * (h * 0.3);
      // Bracket
      ctx.fillStyle = "rgba(100,80,40,0.4)";
      ctx.fillRect(tx - 2, ty, 4, 10);
      // Flame glow
      ctx.fillStyle = "rgba(255,180,50,0.12)";
      ctx.beginPath(); ctx.arc(tx, ty - 2, 15, 0, Math.PI*2); ctx.fill();
      // Flame
      ctx.fillStyle = "rgba(255,150,30,0.3)";
      ctx.beginPath(); ctx.moveTo(tx-3, ty); ctx.quadraticCurveTo(tx, ty-10, tx+3, ty); ctx.fill();
    }
  }
  buildPyramidNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66013);
    // Stone columns
    for (let i = 0; i < 3; i++) {
      const cx = 30 + rng.next() * (w - 60);
      const colW = 12 + rng.next() * 8;
      ctx.fillStyle = "rgba(70,60,40,0.35)";
      ctx.fillRect(cx, h * 0.15, colW, h * 0.7);
      // Column top capital
      ctx.fillRect(cx - 3, h * 0.15, colW + 6, 5);
      ctx.fillRect(cx - 2, h * 0.15 + 5, colW + 4, 3);
      // Column base
      ctx.fillRect(cx - 3, h * 0.85 - 5, colW + 6, 5);
    }
    // Sarcophagus silhouette
    const sx = rng.next() * (w - 40) + 20;
    ctx.fillStyle = "rgba(80,70,45,0.25)";
    ctx.beginPath();
    ctx.moveTo(sx, h - 8);
    ctx.lineTo(sx + 5, h - 28);
    ctx.quadraticCurveTo(sx + 12, h - 35, sx + 19, h - 28);
    ctx.lineTo(sx + 24, h - 8);
    ctx.closePath();
    ctx.fill();
  }
  buildPyramidFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66014);
    // Stone debris
    for (let i = 0; i < 15; i++) {
      const dx = rng.next() * w;
      const dy = h - 2 - rng.next() * 8;
      ctx.fillStyle = `rgba(${60 + Math.floor(rng.next()*30)},${50 + Math.floor(rng.next()*25)},${30 + Math.floor(rng.next()*15)},0.3)`;
      ctx.beginPath();
      ctx.ellipse(dx, dy, 2 + rng.next() * 5, 1 + rng.next() * 3, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    // Sand piles
    for (let i = 0; i < 6; i++) {
      const sx = rng.next() * w;
      const sy = h - 2 - rng.next() * 4;
      ctx.fillStyle = "rgba(160,130,80,0.2)";
      ctx.beginPath();
      ctx.ellipse(sx, sy, 8 + rng.next() * 12, 2 + rng.next() * 3, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // === PYRAMID BOSS theme ===
  buildPyramidBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66021);
    // Ornate wall with golden glow
    ctx.fillStyle = "#3a2a10";
    ctx.fillRect(0, 0, w, h);
    // Golden glow from below
    const grd = ctx.createLinearGradient(0, h, 0, h * 0.4);
    grd.addColorStop(0, "rgba(200,160,40,0.15)");
    grd.addColorStop(1, "rgba(200,160,40,0)");
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, w, h);
    // Cat motif carvings
    for (let i = 0; i < 4; i++) {
      const cx = 50 + rng.next() * (w - 100);
      const cy = h * 0.3 + rng.next() * (h * 0.3);
      // Cat silhouette (sitting)
      ctx.fillStyle = "rgba(120,100,50,0.2)";
      ctx.beginPath();
      ctx.ellipse(cx, cy + 8, 8, 10, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath(); ctx.arc(cx, cy - 4, 6, 0, Math.PI*2); ctx.fill();
      // Cat ears
      ctx.beginPath(); ctx.moveTo(cx-5, cy-8); ctx.lineTo(cx-8, cy-16); ctx.lineTo(cx-2, cy-8); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(cx+5, cy-8); ctx.lineTo(cx+8, cy-16); ctx.lineTo(cx+2, cy-8); ctx.closePath(); ctx.fill();
    }
  }
  buildPyramidBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66022);
    // Golden sarcophagi
    for (let i = 0; i < 3; i++) {
      const sx = rng.next() * (w - 30) + 15;
      const sy = h * 0.4 + rng.next() * (h * 0.3);
      ctx.fillStyle = "rgba(180,150,40,0.2)";
      ctx.beginPath();
      ctx.moveTo(sx, sy + 20);
      ctx.lineTo(sx + 4, sy - 5);
      ctx.quadraticCurveTo(sx + 10, sy - 12, sx + 16, sy - 5);
      ctx.lineTo(sx + 20, sy + 20);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "rgba(220,180,50,0.25)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    // Jewels scattered
    for (let i = 0; i < 10; i++) {
      const jx = rng.next() * w;
      const jy = h * 0.5 + rng.next() * (h * 0.4);
      const colors = ["rgba(255,50,50,0.2)","rgba(50,100,255,0.2)","rgba(50,255,100,0.2)","rgba(255,200,50,0.25)"];
      ctx.fillStyle = colors[Math.floor(rng.next() * colors.length)];
      ctx.beginPath();
      ctx.arc(jx, jy, 1.5 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildPyramidBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66023);
    // Columns with cat statues
    for (let i = 0; i < 3; i++) {
      const cx = 40 + rng.next() * (w - 80);
      const colW = 14;
      // Column
      ctx.fillStyle = "rgba(90,70,30,0.3)";
      ctx.fillRect(cx, h * 0.12, colW, h * 0.75);
      ctx.fillRect(cx - 4, h * 0.12, colW + 8, 6);
      // Cat statue on top
      ctx.fillStyle = "rgba(180,150,50,0.3)";
      ctx.beginPath();
      ctx.ellipse(cx + colW/2, h * 0.12 - 6, 6, 8, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath(); ctx.arc(cx + colW/2, h * 0.12 - 14, 5, 0, Math.PI*2); ctx.fill();
      // Ears
      ctx.beginPath();
      ctx.moveTo(cx + colW/2 - 4, h * 0.12 - 17);
      ctx.lineTo(cx + colW/2 - 6, h * 0.12 - 24);
      ctx.lineTo(cx + colW/2 - 1, h * 0.12 - 17);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(cx + colW/2 + 4, h * 0.12 - 17);
      ctx.lineTo(cx + colW/2 + 6, h * 0.12 - 24);
      ctx.lineTo(cx + colW/2 + 1, h * 0.12 - 17);
      ctx.closePath(); ctx.fill();
    }
  }
  buildPyramidBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(66024);
    // Gold coins scattered
    for (let i = 0; i < 20; i++) {
      const cx = rng.next() * w;
      const cy = h - 2 - rng.next() * 6;
      ctx.fillStyle = `rgba(${200 + Math.floor(rng.next()*55)},${160 + Math.floor(rng.next()*40)},${20 + Math.floor(rng.next()*30)},0.25)`;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 2 + rng.next() * 2, 1 + rng.next(), 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Artifacts
    for (let i = 0; i < 5; i++) {
      const ax = rng.next() * w;
      const ay = h - 3 - rng.next() * 5;
      ctx.fillStyle = "rgba(150,120,40,0.2)";
      const shape = Math.floor(rng.next() * 3);
      if (shape === 0) { ctx.fillRect(ax, ay, 5, 3); } // small bar
      else if (shape === 1) { ctx.beginPath(); ctx.arc(ax, ay, 3, 0, Math.PI*2); ctx.fill(); } // orb
      else { ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(ax+4,ay+4); ctx.lineTo(ax-4,ay+4); ctx.closePath(); ctx.fill(); } // triangle
    }
  }

  // === SKY KINGDOM theme ===
  buildSkyKingdomFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77001);
    // Distant floating islands
    for (let i = 0; i < 6; i++) {
      const ix = rng.next() * w;
      const iy = h * 0.3 + rng.next() * h * 0.3;
      const iw = 30 + rng.next() * 50;
      const ih = 8 + rng.next() * 12;
      ctx.fillStyle = `rgba(${180+Math.floor(rng.next()*40)},${200+Math.floor(rng.next()*40)},${240},0.4)`;
      ctx.beginPath();
      ctx.ellipse(ix, iy, iw, ih, 0, 0, Math.PI*2);
      ctx.fill();
      // Mini castle on island
      if (rng.next() > 0.4) {
        ctx.fillStyle = `rgba(200,210,240,0.35)`;
        const tw = 6 + rng.next() * 8;
        const th = 10 + rng.next() * 18;
        ctx.fillRect(ix - tw/2, iy - ih - th, tw, th);
        ctx.beginPath();
        ctx.moveTo(ix - tw/2 - 2, iy - ih - th);
        ctx.lineTo(ix, iy - ih - th - 8);
        ctx.lineTo(ix + tw/2 + 2, iy - ih - th);
        ctx.closePath();
        ctx.fill();
      }
    }
  }
  buildSkyKingdomMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77002);
    // Cloud banks
    ctx.fillStyle = "rgba(200,220,255,0.25)";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 40 - Math.sin(x * 0.005) * 20 - Math.sin(x * 0.012 + 1) * 15 - rng.next() * 3;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Floating towers
    for (let i = 0; i < 4; i++) {
      const tx = 60 + rng.next() * (w - 120);
      const tBase = h - 30 - Math.sin(tx * 0.005) * 20;
      const tw = 10 + rng.next() * 8;
      const th = 30 + rng.next() * 40;
      ctx.fillStyle = `rgba(160,180,220,0.35)`;
      ctx.fillRect(tx - tw/2, tBase - th, tw, th);
      // Windows
      ctx.fillStyle = "rgba(255,255,180,0.3)";
      for (let wi = 0; wi < 3; wi++) {
        ctx.fillRect(tx - 2, tBase - th + 6 + wi * 12, 4, 4);
      }
    }
  }
  buildSkyKingdomNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77003);
    // Closer clouds
    for (let i = 0; i < 10; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.5 + rng.next() * h * 0.35;
      ctx.fillStyle = `rgba(200,215,240,${0.15 + rng.next() * 0.15})`;
      const cw = 30 + rng.next() * 50;
      const ch = 8 + rng.next() * 12;
      ctx.beginPath();
      ctx.ellipse(cx, cy, cw, ch, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - cw*0.3, cy - ch*0.4, cw*0.5, ch*0.8, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + cw*0.3, cy - ch*0.3, cw*0.4, ch*0.7, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Banners/flags
    for (let i = 0; i < 5; i++) {
      const fx = rng.next() * w;
      const fy = h * 0.6 + rng.next() * h * 0.2;
      ctx.strokeStyle = "rgba(180,180,200,0.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(fx, fy); ctx.lineTo(fx, fy - 15);
      ctx.stroke();
      ctx.fillStyle = `rgba(${Math.floor(rng.next()*100)+150},${Math.floor(rng.next()*100)+100},${Math.floor(rng.next()*100)+150},0.2)`;
      ctx.beginPath();
      ctx.moveTo(fx, fy - 15);
      ctx.lineTo(fx + 8, fy - 12);
      ctx.lineTo(fx, fy - 9);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildSkyKingdomFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77004);
    // Wispy cloud floor
    ctx.fillStyle = "rgba(220,230,255,0.12)";
    for (let i = 0; i < 20; i++) {
      const cx = rng.next() * w;
      const cy = h - 2 - rng.next() * 8;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 15 + rng.next() * 25, 3 + rng.next() * 4, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === STORM PEAKS theme ===
  buildStormPeaksFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77011);
    // Lightning streaks in background
    ctx.strokeStyle = "rgba(180,180,255,0.08)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
      const lx = rng.next() * w;
      ctx.beginPath();
      ctx.moveTo(lx, 0);
      let ly = 0;
      for (let s = 0; s < 5; s++) {
        ly += h * 0.15;
        ctx.lineTo(lx + (rng.next() - 0.5) * 30, ly);
      }
      ctx.stroke();
    }
    // Distant storm clouds (dark)
    ctx.fillStyle = "rgba(30,30,60,0.5)";
    ctx.beginPath();
    ctx.moveTo(0, h * 0.5);
    for (let x = 0; x <= w; x += 6) {
      ctx.lineTo(x, h * 0.5 - 10 - Math.sin(x * 0.008) * 15 - rng.next() * 8);
    }
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.closePath();
    ctx.fill();
  }
  buildStormPeaksMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77012);
    // Dark craggy peaks
    ctx.fillStyle = "#2a2a44";
    ctx.beginPath();
    ctx.moveTo(0, h);
    let mx = 0;
    while (mx < w) {
      const peakH = h * 0.3 + rng.next() * h * 0.25;
      const width = 40 + rng.next() * 80;
      ctx.lineTo(mx, h - peakH);
      mx += width;
      ctx.lineTo(mx, h - peakH * 0.3 - rng.next() * 20);
      mx += 20 + rng.next() * 30;
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildStormPeaksNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77013);
    // Closer dark clouds with rain streaks
    ctx.fillStyle = "rgba(40,40,70,0.4)";
    for (let i = 0; i < 8; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.4 + rng.next() * h * 0.3;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 30 + rng.next() * 40, 10 + rng.next() * 8, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Rain streaks
    ctx.strokeStyle = "rgba(150,150,200,0.08)";
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 40; i++) {
      const rx = rng.next() * w;
      const ry = rng.next() * h;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx - 2, ry + 8);
      ctx.stroke();
    }
  }
  buildStormPeaksFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77014);
    // Wind-swept debris
    ctx.strokeStyle = "rgba(150,150,180,0.1)";
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 15; i++) {
      const rx = rng.next() * w;
      const ry = h - 2 - rng.next() * 6;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx + 8 + rng.next() * 12, ry - 1);
      ctx.stroke();
    }
  }
  // === STAR BRIDGE theme ===
  buildStarBridgeFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77021);
    // Aurora borealis
    const auroraColors = ["rgba(0,255,128,0.06)","rgba(0,128,255,0.05)","rgba(128,0,255,0.04)","rgba(255,0,128,0.03)"];
    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = auroraColors[i];
      ctx.beginPath();
      ctx.moveTo(0, h * 0.15 + i * 15);
      for (let x = 0; x <= w; x += 6) {
        const y = h * 0.15 + i * 15 + Math.sin(x * 0.004 + i * 0.8) * 20 + Math.sin(x * 0.01 + i) * 10;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h * 0.4 + i * 15);
      ctx.lineTo(0, h * 0.4 + i * 15);
      ctx.closePath();
      ctx.fill();
    }
    // Constellations
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    for (let i = 0; i < 20; i++) {
      const sx = rng.next() * w;
      const sy = rng.next() * h * 0.5;
      ctx.beginPath();
      ctx.arc(sx, sy, 1 + rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildStarBridgeMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77022);
    // Starry bridge arcs
    ctx.strokeStyle = "rgba(180,200,255,0.12)";
    ctx.lineWidth = 3;
    for (let i = 0; i < 3; i++) {
      const sx = rng.next() * w * 0.3;
      const ex = sx + 100 + rng.next() * 200;
      const peakY = h * 0.4 - rng.next() * h * 0.2;
      ctx.beginPath();
      ctx.moveTo(sx, h * 0.7);
      ctx.quadraticCurveTo((sx + ex) / 2, peakY, ex, h * 0.7);
      ctx.stroke();
    }
    // Floating crystals
    for (let i = 0; i < 8; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.3 + rng.next() * h * 0.35;
      ctx.fillStyle = `rgba(${150+Math.floor(rng.next()*100)},${150+Math.floor(rng.next()*100)},255,0.2)`;
      ctx.beginPath();
      ctx.moveTo(cx, cy - 5);
      ctx.lineTo(cx + 3, cy);
      ctx.lineTo(cx, cy + 5);
      ctx.lineTo(cx - 3, cy);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildStarBridgeNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77023);
    // Nebula clouds
    for (let i = 0; i < 6; i++) {
      const cx = rng.next() * w;
      const cy = h * 0.4 + rng.next() * h * 0.4;
      const colors = ["rgba(60,0,120,0.08)","rgba(0,60,120,0.08)","rgba(120,0,60,0.06)"];
      ctx.fillStyle = colors[i % colors.length];
      ctx.beginPath();
      ctx.ellipse(cx, cy, 30 + rng.next() * 40, 15 + rng.next() * 15, rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildStarBridgeFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77024);
    // Stardust on ground
    ctx.fillStyle = "rgba(180,200,255,0.15)";
    for (let i = 0; i < 25; i++) {
      const sx = rng.next() * w;
      const sy = h - 1 - rng.next() * 5;
      ctx.beginPath();
      ctx.arc(sx, sy, 0.5 + rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === SKY BOSS theme ===
  buildSkyBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77031);
    // Storm vortex
    ctx.strokeStyle = "rgba(100,120,200,0.1)";
    ctx.lineWidth = 3;
    for (let i = 0; i < 5; i++) {
      const cx = w * 0.5;
      const cy = h * 0.3;
      const r = 30 + i * 20;
      ctx.beginPath();
      ctx.arc(cx, cy, r, i * 0.3, i * 0.3 + Math.PI * 1.2);
      ctx.stroke();
    }
    // Lightning flashes
    ctx.strokeStyle = "rgba(200,200,255,0.06)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      const lx = rng.next() * w;
      ctx.beginPath();
      ctx.moveTo(lx, 0);
      let ly = 0;
      for (let s = 0; s < 4; s++) {
        ly += h * 0.2;
        ctx.lineTo(lx + (rng.next() - 0.5) * 20, ly);
      }
      ctx.stroke();
    }
  }
  buildSkyBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77032);
    // Swirling dark clouds
    ctx.fillStyle = "rgba(30,30,60,0.4)";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 50 - Math.sin(x * 0.007) * 25 - Math.sin(x * 0.015 + 0.5) * 15 - rng.next() * 4;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
  }
  buildSkyBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77033);
    // Crackle energy
    ctx.strokeStyle = "rgba(140,160,255,0.12)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      const sx = rng.next() * w;
      const sy = rng.next() * h;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + (rng.next()-0.5)*20, sy + rng.next()*15);
      ctx.lineTo(sx + (rng.next()-0.5)*25, sy + rng.next()*25);
      ctx.stroke();
    }
  }
  buildSkyBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(77034);
    // Charged ground particles
    ctx.fillStyle = "rgba(140,160,255,0.1)";
    for (let i = 0; i < 15; i++) {
      const px = rng.next() * w;
      const py = h - 1 - rng.next() * 4;
      ctx.beginPath();
      ctx.arc(px, py, 1 + rng.next(), 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === RAINBOW ROAD theme ===
  buildRainbowRoadFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88001);
    // Rainbow arcs in background
    const rainbowColors = ["#ff4444","#ff8844","#ffcc44","#44ff44","#4488ff","#8844ff","#ff44ff"];
    for (let r = 0; r < 2; r++) {
      const cx = rng.next() * w * 0.6 + w * 0.2;
      const cy = h * 0.8;
      for (let i = 0; i < 7; i++) {
        ctx.strokeStyle = rainbowColors[i].replace(")", ",0.1)").replace("rgb", "rgba");
        const alpha = 0.08;
        ctx.strokeStyle = `rgba(${parseInt(rainbowColors[i].slice(1,3),16)},${parseInt(rainbowColors[i].slice(3,5),16)},${parseInt(rainbowColors[i].slice(5,7),16)},${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cx, cy, 80 + i * 6 + r * 60, Math.PI, 0);
        ctx.stroke();
      }
    }
    // Sparkles
    for (let i = 0; i < 30; i++) {
      const sx = rng.next() * w;
      const sy = rng.next() * h * 0.7;
      const ci = Math.floor(rng.next() * 7);
      ctx.fillStyle = rainbowColors[ci].replace(")", ",0.3)").replace("rgb", "rgba");
      ctx.fillStyle = `rgba(${parseInt(rainbowColors[ci].slice(1,3),16)},${parseInt(rainbowColors[ci].slice(3,5),16)},${parseInt(rainbowColors[ci].slice(5,7),16)},0.3)`;
      ctx.beginPath();
      ctx.arc(sx, sy, 0.5 + rng.next() * 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildRainbowRoadMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88002);
    // Colorful rolling hills
    const hillColors = ["rgba(255,100,100,0.15)","rgba(100,255,100,0.15)","rgba(100,100,255,0.15)"];
    for (let hi = 0; hi < 3; hi++) {
      ctx.fillStyle = hillColors[hi];
      ctx.beginPath();
      ctx.moveTo(0, h);
      for (let x = 0; x <= w; x += 4) {
        const y = h - 25 - hi * 12 - Math.sin(x * 0.006 + hi * 2) * 20 - rng.next() * 2;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildRainbowRoadNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88003);
    // Floating color orbs
    const orbColors = ["rgba(255,80,80,0.15)","rgba(255,200,80,0.15)","rgba(80,255,80,0.15)","rgba(80,80,255,0.15)","rgba(200,80,255,0.15)"];
    for (let i = 0; i < 12; i++) {
      const ox = rng.next() * w;
      const oy = h * 0.3 + rng.next() * h * 0.5;
      ctx.fillStyle = orbColors[i % orbColors.length];
      ctx.beginPath();
      ctx.arc(ox, oy, 6 + rng.next() * 10, 0, Math.PI*2);
      ctx.fill();
    }
    // Sparkle trails
    ctx.fillStyle = "rgba(255,255,255,0.15)";
    for (let i = 0; i < 20; i++) {
      ctx.beginPath();
      ctx.arc(rng.next() * w, rng.next() * h, rng.next() * 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildRainbowRoadFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88004);
    // Rainbow shimmer on ground
    const rainbowColors = ["#ff4444","#ff8844","#ffcc44","#44ff44","#4488ff","#8844ff"];
    for (let i = 0; i < 25; i++) {
      const sx = rng.next() * w;
      const sy = h - 1 - rng.next() * 5;
      const ci = Math.floor(rng.next() * rainbowColors.length);
      ctx.fillStyle = `rgba(${parseInt(rainbowColors[ci].slice(1,3),16)},${parseInt(rainbowColors[ci].slice(3,5),16)},${parseInt(rainbowColors[ci].slice(5,7),16)},0.12)`;
      ctx.beginPath();
      ctx.arc(sx, sy, 1 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === CRYSTAL PALACE theme ===
  buildCrystalPalaceFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88011);
    // Crystal pillars in background
    for (let i = 0; i < 6; i++) {
      const px = rng.next() * w;
      const pw = 8 + rng.next() * 12;
      const ph = 40 + rng.next() * 60;
      const colors = ["rgba(160,140,220,0.2)","rgba(140,160,220,0.2)","rgba(180,140,200,0.2)"];
      ctx.fillStyle = colors[i % colors.length];
      ctx.fillRect(px - pw/2, h * 0.3, pw, ph);
      // Crystal facet highlights
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(px - pw/2, h * 0.3, pw/3, ph);
      // Pointed top
      ctx.fillStyle = colors[i % colors.length];
      ctx.beginPath();
      ctx.moveTo(px - pw/2, h * 0.3);
      ctx.lineTo(px, h * 0.3 - 10);
      ctx.lineTo(px + pw/2, h * 0.3);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildCrystalPalaceMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88012);
    // Prismatic reflections
    ctx.fillStyle = "rgba(180,160,240,0.12)";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 35 - Math.sin(x * 0.007) * 18 - Math.sin(x * 0.014 + 2) * 10 - rng.next() * 3;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Hanging crystals
    for (let i = 0; i < 8; i++) {
      const cx = rng.next() * w;
      const cy = rng.next() * h * 0.3;
      const cSize = 4 + rng.next() * 8;
      ctx.fillStyle = `rgba(${180+Math.floor(rng.next()*70)},${160+Math.floor(rng.next()*70)},255,0.15)`;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + cSize/2, cy + cSize);
      ctx.lineTo(cx, cy + cSize * 2);
      ctx.lineTo(cx - cSize/2, cy + cSize);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildCrystalPalaceNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88013);
    // Crystal wall panels
    for (let i = 0; i < 5; i++) {
      const px = rng.next() * w;
      const py = h * 0.4 + rng.next() * h * 0.3;
      const pw = 15 + rng.next() * 20;
      const ph = 20 + rng.next() * 30;
      ctx.fillStyle = `rgba(${140+Math.floor(rng.next()*60)},${120+Math.floor(rng.next()*60)},${200+Math.floor(rng.next()*55)},0.1)`;
      ctx.beginPath();
      ctx.moveTo(px, py - ph/2);
      ctx.lineTo(px + pw/2, py);
      ctx.lineTo(px, py + ph/2);
      ctx.lineTo(px - pw/2, py);
      ctx.closePath();
      ctx.fill();
    }
    // Light refractions
    ctx.fillStyle = "rgba(255,220,255,0.06)";
    for (let i = 0; i < 10; i++) {
      const lx = rng.next() * w;
      const ly = rng.next() * h;
      ctx.beginPath();
      ctx.ellipse(lx, ly, 20 + rng.next() * 30, 2 + rng.next() * 3, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildCrystalPalaceFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88014);
    // Reflective floor tiles
    ctx.fillStyle = "rgba(160,140,220,0.08)";
    for (let i = 0; i < 15; i++) {
      const tx = rng.next() * w;
      const ty = h - 1 - rng.next() * 5;
      ctx.fillRect(tx, ty, 8, 2);
    }
  }
  // === PRISMATIC FALLS theme ===
  buildPrismaticFallsFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88021);
    // Distant waterfalls of color
    const fallColors = ["rgba(255,100,200,0.06)","rgba(100,200,255,0.06)","rgba(200,100,255,0.06)"];
    for (let i = 0; i < 4; i++) {
      const fx = rng.next() * w;
      const fw = 8 + rng.next() * 15;
      ctx.fillStyle = fallColors[i % fallColors.length];
      ctx.fillRect(fx, 0, fw, h * 0.7);
      // Splash at bottom
      ctx.beginPath();
      ctx.ellipse(fx + fw/2, h * 0.7, fw, 5, 0, 0, Math.PI*2);
      ctx.fill();
    }
    // Mist
    for (let i = 0; i < 6; i++) {
      ctx.fillStyle = "rgba(200,180,240,0.05)";
      ctx.beginPath();
      ctx.ellipse(rng.next() * w, h * 0.6 + rng.next() * h * 0.2, 40 + rng.next() * 50, 10 + rng.next() * 10, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildPrismaticFallsMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88022);
    // Rainbow mist layers
    const mistColors = ["rgba(255,100,100,0.08)","rgba(255,255,100,0.06)","rgba(100,255,100,0.07)","rgba(100,100,255,0.08)"];
    for (let mi = 0; mi < 4; mi++) {
      ctx.fillStyle = mistColors[mi];
      ctx.beginPath();
      ctx.moveTo(0, h);
      for (let x = 0; x <= w; x += 4) {
        const y = h - 30 - mi * 10 - Math.sin(x * 0.005 + mi * 1.5) * 15 - rng.next() * 3;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.closePath();
      ctx.fill();
    }
  }
  buildPrismaticFallsNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88023);
    // Color droplets
    const dropColors = ["rgba(255,100,200,0.12)","rgba(100,200,255,0.12)","rgba(200,255,100,0.10)","rgba(255,200,100,0.10)"];
    for (let i = 0; i < 15; i++) {
      const dx = rng.next() * w;
      const dy = rng.next() * h;
      ctx.fillStyle = dropColors[i % dropColors.length];
      ctx.beginPath();
      ctx.arc(dx, dy, 2 + rng.next() * 4, 0, Math.PI*2);
      ctx.fill();
    }
    // Prismatic streaks
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
      const sx = rng.next() * w;
      const sy = rng.next() * h * 0.5;
      ctx.strokeStyle = dropColors[i % dropColors.length];
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - 3, sy + 15 + rng.next() * 15);
      ctx.stroke();
    }
  }
  buildPrismaticFallsFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88024);
    // Puddles of color
    const puddleColors = ["rgba(255,100,200,0.08)","rgba(100,200,255,0.08)","rgba(200,100,255,0.08)"];
    for (let i = 0; i < 12; i++) {
      const px = rng.next() * w;
      const py = h - 1 - rng.next() * 4;
      ctx.fillStyle = puddleColors[i % puddleColors.length];
      ctx.beginPath();
      ctx.ellipse(px, py, 5 + rng.next() * 8, 1 + rng.next() * 2, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
  // === RAINBOW BOSS theme ===
  buildRainbowBossFar(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88031);
    // Dark void with color streaks
    for (let i = 0; i < 8; i++) {
      const colors = ["rgba(100,0,150,0.06)","rgba(0,80,150,0.05)","rgba(150,0,80,0.06)","rgba(80,0,150,0.05)"];
      ctx.fillStyle = colors[i % colors.length];
      const sx = rng.next() * w;
      const sy = rng.next() * h;
      ctx.beginPath();
      ctx.ellipse(sx, sy, 30 + rng.next() * 60, 10 + rng.next() * 20, rng.next() * Math.PI, 0, Math.PI*2);
      ctx.fill();
    }
    // Shadow tendrils
    ctx.strokeStyle = "rgba(60,0,100,0.08)";
    ctx.lineWidth = 3;
    for (let i = 0; i < 5; i++) {
      const tx = rng.next() * w;
      ctx.beginPath();
      ctx.moveTo(tx, h);
      ctx.quadraticCurveTo(tx + (rng.next()-0.5)*40, h * 0.5, tx + (rng.next()-0.5)*60, rng.next() * h * 0.3);
      ctx.stroke();
    }
  }
  buildRainbowBossMid(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88032);
    // Ominous dark clouds with purple edges
    ctx.fillStyle = "rgba(20,0,40,0.4)";
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let x = 0; x <= w; x += 4) {
      const y = h - 45 - Math.sin(x * 0.006) * 20 - Math.sin(x * 0.013 + 1) * 12 - rng.next() * 4;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    // Purple edge glow
    ctx.strokeStyle = "rgba(120,40,180,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = 0; x <= w; x += 4) {
      const y = h - 45 - Math.sin(x * 0.006) * 20 - Math.sin(x * 0.013 + 1) * 12;
      if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  buildRainbowBossNear(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88033);
    // Floating shadow orbs
    for (let i = 0; i < 6; i++) {
      const ox = rng.next() * w;
      const oy = h * 0.3 + rng.next() * h * 0.4;
      const orad = 8 + rng.next() * 14;
      const grad = ctx.createRadialGradient(ox, oy, 0, ox, oy, orad);
      grad.addColorStop(0, "rgba(80,0,120,0.12)");
      grad.addColorStop(1, "rgba(40,0,60,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(ox, oy, orad, 0, Math.PI*2);
      ctx.fill();
    }
  }
  buildRainbowBossFloor(ctx, w, h) {
    ctx.clearRect(0, 0, w, h);
    const rng = new SeededRNG(88034);
    // Dark energy on ground
    ctx.fillStyle = "rgba(80,0,120,0.08)";
    for (let i = 0; i < 12; i++) {
      const px = rng.next() * w;
      const py = h - 1 - rng.next() * 4;
      ctx.beginPath();
      ctx.arc(px, py, 1.5 + rng.next() * 2, 0, Math.PI*2);
      ctx.fill();
    }
  }

  draw(ctx, camX) {
    for (const layer of this.layers) {
      const offsetX = -(camX * layer.speed) % (CFG.W * 2);
      ctx.drawImage(layer.canvas, offsetX, 0);
      ctx.drawImage(layer.canvas, offsetX + CFG.W * 2, 0);
    }
  }
}

// --- Tile Renderer ---
class TileRenderer {
  constructor() {
    this.tileCache = null;
    this.cacheKey = "";
  }
  drawTiles(ctx, level, camX, camY) {
    const T = CFG.TILE;
    const baseDef = level.levelDef;
    const hasZones = !!baseDef.zones;
    let def = baseDef;
    let currentZoneStartCol = -1;
    const startCol = Math.max(0, Math.floor(camX / T));
    const endCol = Math.min(level.cols - 1, Math.ceil((camX + CFG.W) / T));
    const startRow = Math.max(0, Math.floor(camY / T));
    const endRow = Math.min(level.rows - 1, Math.ceil((camY + CFG.H) / T));

    for (let r = startRow; r <= endRow; r++) {
      for (let c = startCol; c <= endCol; c++) {
        // Zone-aware color lookup (only re-lookup at zone boundaries)
        if (hasZones) {
          const zone = level.getZoneAtCol(c);
          if (zone.startCol !== currentZoneStartCol) {
            def = zone;
            currentZoneStartCol = zone.startCol;
          }
        }
        const tile = level.get(c, r);
        if (tile === TILE_EMPTY) continue;
        const sx = c * T - camX;
        const sy = r * T - camY;

        if (tile === TILE_GRASS) {
          // Dirt body
          ctx.fillStyle = def.dirt;
          ctx.fillRect(sx, sy + 4, T, T - 4);
          // Grass/surface top
          const grd = ctx.createLinearGradient(sx, sy, sx, sy + 6);
          grd.addColorStop(0, def.grassTop);
          grd.addColorStop(1, def.grassBot);
          ctx.fillStyle = grd;
          ctx.fillRect(sx, sy, T, 6);
          // Blades (skip for cloud/cave themes)
          if (def.grassBlade) {
            ctx.fillStyle = def.grassBlade;
            for (let b = 0; b < 3; b++) {
              const bx = sx + 3 + b * 7;
              ctx.fillRect(bx, sy - 1, 2, 3);
            }
          }
          // Top highlight line
          ctx.fillStyle = "rgba(255,255,255,0.15)";
          ctx.fillRect(sx, sy, T, 1);
        } else if (tile === TILE_DIRT) {
          ctx.fillStyle = def.dirt;
          ctx.fillRect(sx, sy, T, T);
          // Darker edges
          ctx.fillStyle = def.dirtDark;
          ctx.fillRect(sx, sy, 1, T);
          ctx.fillRect(sx+T-1, sy, 1, T);
          // Random specks (deterministic)
          const seed = c * 31 + r * 17;
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          ctx.fillRect(sx + (seed % 7) + 3, sy + ((seed*3) % 9) + 3, 2, 2);
          ctx.fillRect(sx + ((seed*7) % 11) + 2, sy + ((seed*5) % 11) + 5, 2, 1);
        }
      }
    }

    // Water fill in pit gaps (for lakeside/zoned levels with waterInPits)
    const checkWater = hasZones || baseDef.waterInPits;
    if (checkWater) {
      const waterRow1 = level.rows - 2; // where grass normally is
      const waterRow2 = level.rows - 1; // where dirt normally is
      for (let c = startCol; c <= endCol; c++) {
        // Check if this column's zone has waterInPits
        const zoneWater = hasZones ? !!level.getZoneAtCol(c).waterInPits : baseDef.waterInPits;
        if (!zoneWater) continue;
        if (level.get(c, waterRow1) === TILE_EMPTY && level.get(c, waterRow2) === TILE_EMPTY) {
          const wx = c * T - camX;
          const wy1 = waterRow1 * T - camY;
          // Water fill (two rows deep)
          ctx.fillStyle = "rgba(40,90,140,0.5)";
          ctx.fillRect(wx, wy1, T, T * 2);
          // Surface shimmer on top row
          ctx.fillStyle = "rgba(100,170,220,0.35)";
          ctx.fillRect(wx, wy1, T, 3);
          // Subtle wave highlight
          const waveSeed = c * 13;
          ctx.fillStyle = "rgba(150,200,240,0.2)";
          ctx.fillRect(wx + (waveSeed % 8) + 2, wy1 + 1, 6, 1);
        }
      }
    }
  }
}

// --- Sprite Drawer (procedural placeholder sprites) ---
class SpriteDrawer {
  constructor() {}

  // Draw the unicorn using loaded sprite images
  drawPlayer(ctx, player, gt) {
    const c = ctx;
    const px = Math.round(player.cx);
    const py = Math.round(player.bottom);
    const facing = player.facing;

    // Invincibility flash
    if (player.invTimer > 0 && Math.floor(gt * 10) % 2 === 0) return;

    c.save();
    c.translate(px, py);

    // Squash/stretch
    const sq = player.squash;
    c.scale(facing * (1 + sq), 1 - sq);

    // Small unicorn by default, big when powered up
    // Kittycorn is half size (she's a cat, not a horse!)
    let sizeScale = player.isBig ? 0.825 : 0.65;
    if (player.isMermaid && player.isUnderwater) sizeScale = 0.7;
    else if (player.isMouseicorn && !player.isUnderwater) sizeScale = 0.85;
    else if (player.isPixicorn) sizeScale = 0.85;
    else if (player.isKittycorn && !player.isUnderwater) sizeScale *= 0.5;
    const dw = CFG.PLAYER_DRAW_W * sizeScale;
    const dh = CFG.PLAYER_DRAW_H * sizeScale;

    // Shadow
    c.fillStyle = "rgba(0,0,0,0.25)";
    c.beginPath();
    c.ellipse(0, 0, 10 * sizeScale + 4, 3 * sizeScale + 1, 0, 0, Math.PI*2);
    c.fill();

    // Choose which sprite to draw
    let sprite = null;
    let srcX = 0, srcY = 0, srcW = 0, srcH = 0;
    let drawOverrideH = dh; // can be overridden per-state

    let celebrateFlip = 1; // extra flip for kittycorn celebrate bounce

    if (player.animState === "hoopClear" && player.isMermaid && SPRITES.mermicornVictory) {
      // Mermicorn victory — flash between frames 2 and 3 for celebration
      sprite = SPRITES.mermicornVictory;
      srcW = CFG.SPRITE_MERMICORN_VICTORY_FW;
      srcH = CFG.SPRITE_MERMICORN_VICTORY_FH;
      const vFrame = player.animFrame < 2 ? player.animFrame
        : 1 + Math.floor(gt * 6) % 2; // cycle frames 2-3 for sparkle
      srcX = vFrame * srcW;
      srcY = 0;
    } else if (player.animState === "hoopClear" && player.isPixicorn && SPRITES.pixicorn) {
      sprite = SPRITES.pixicorn;
      srcW = CFG.SPRITE_PIXICORN_FW;
      srcH = CFG.SPRITE_PIXICORN_FH;
      srcX = 5 * srcW;  // frame 5 = victory
      srcY = 0;
    } else if (player.animState === "hoopClear" && player.isMouseicorn && !player.isUnderwater && SPRITES.mousicorn) {
      sprite = SPRITES.mousicorn;
      srcW = CFG.SPRITE_MOUSICORN_FW;
      srcH = CFG.SPRITE_MOUSICORN_FH;
      srcX = CFG.SPRITE_MOUSICORN_JUMP_FRAME * srcW; // frame 7 = wings spread victory
      srcY = 0;
    } else if (player.animState === "hoopClear" && player.isKittycorn && SPRITES.kittycornCelebrate) {
      // Kittycorn celebrate — bounce right, left, right over and over
      sprite = SPRITES.kittycornCelebrate;
      srcW = CFG.SPRITE_KITTYCORN_CELEBRATE_FW;
      srcH = CFG.SPRITE_KITTYCORN_CELEBRATE_FH;
      const cFrame = Math.floor(gt * 4) % CFG.SPRITE_KITTYCORN_CELEBRATE_FRAMES;
      srcX = cFrame * srcW;
      srcY = 0;
      // Alternate facing: frame 0 right, frame 1 left, frame 2 right
      const desiredDir = cFrame === 1 ? -1 : 1;
      celebrateFlip = desiredDir * facing;
    } else if (player.animState === "hoopClear" && SPRITES.hoopClear) {
      sprite = SPRITES.hoopClear;
      srcW = CFG.SPRITE_HOOP_FW;
      srcH = CFG.SPRITE_HOOP_FH;
      srcX = player.animFrame * srcW;
      srcY = 0;
    } else if (player.animState === "growWings" && SPRITES.growWings) {
      sprite = SPRITES.growWings;
      srcW = CFG.SPRITE_GROW_WINGS_FW;
      srcH = CFG.SPRITE_GROW_WINGS_FH;
      srcX = player.animFrame * srcW;
      srcY = 0;
    } else if (player.isMermaid && player.isUnderwater && SPRITES.mermicorn) {
      // Mermicorn swim sprite — overrides all normal sprites when mermaid + underwater
      sprite = SPRITES.mermicorn;
      srcW = CFG.SPRITE_MERMICORN_FW;
      srcH = CFG.SPRITE_MERMICORN_FH;
      const swimSpeed = Math.abs(player.speedX) > 0.3 ? 8 : 3;
      const swimFrame = Math.floor(gt * swimSpeed) % CFG.SPRITE_MERMICORN_FRAMES;
      srcX = swimFrame * srcW;
      srcY = 0;
    } else if (player.isPixicorn && !player.isUnderwater) {
      // Pixicorn sprites — small flying unicorn
      if (SPRITES.pixicorn) {
        sprite = SPRITES.pixicorn;
        srcW = CFG.SPRITE_PIXICORN_FW;
        srcH = CFG.SPRITE_PIXICORN_FH;
        if (player.animState === "standPoop" || player.poopTimer > 0) {
          srcX = 3 * srcW; // hover frame for pooping
        } else if (Math.abs(player.speedX) > 0.3) {
          // Flying in motion — frames 0-2
          const flyFrame = Math.floor(gt * 10) % CFG.SPRITE_PIXICORN_FLY_FRAMES;
          srcX = flyFrame * srcW;
        } else {
          // Hovering still — frames 3-4
          const hoverFrame = Math.floor(gt * 4) % CFG.SPRITE_PIXICORN_HOVER_FRAMES;
          srcX = (3 + hoverFrame) * srcW;
        }
        srcY = 0;
      }
    } else if (player.isMouseicorn && !player.isUnderwater) {
      // Mousicorn sprites — small scurrying mouse unicorn on land
      if (SPRITES.mousicorn) {
        sprite = SPRITES.mousicorn;
        srcW = CFG.SPRITE_MOUSICORN_FW;
        srcH = CFG.SPRITE_MOUSICORN_FH;
        if (player.animState === "standPoop" || player.poopTimer > 0) {
          srcX = CFG.SPRITE_MOUSICORN_POOP_FRAME * srcW; // frame 6
        } else if (!player.onGround) {
          // Alternate frames 6-7 for wing flap while airborne
          const jumpFrame = Math.floor(gt * 6) % 2 === 0 ? 6 : 7;
          srcX = jumpFrame * srcW;
        } else if (Math.abs(player.speedX) > 0.3) {
          // Fast scurry — frames 0-5
          const runFrame = Math.floor(gt * 12) % CFG.SPRITE_MOUSICORN_RUN_FRAMES;
          srcX = runFrame * srcW;
        } else {
          srcX = CFG.SPRITE_MOUSICORN_STAND_FRAME * srcW; // frame 0
        }
        srcY = 0;
      }
    } else if (player.isKittycorn && !player.isUnderwater) {
      // Kittycorn sprites — overrides normal sprites on land when kittycorn
      if (player.animState === "standPoop" && SPRITES.kittycornStandPoop) {
        sprite = SPRITES.kittycornStandPoop;
        srcW = CFG.SPRITE_KITTYCORN_STAND_POOP_W;
        srcH = CFG.SPRITE_KITTYCORN_STAND_POOP_H;
        srcX = 0;
        srcY = 0;
      } else if (player.animState === "run" && SPRITES.kittycornRun) {
        sprite = SPRITES.kittycornRun;
        srcW = CFG.SPRITE_KITTYCORN_RUN_FW;
        srcH = CFG.SPRITE_KITTYCORN_RUN_FH;
        const runFrame = Math.floor(gt * 10) % CFG.SPRITE_KITTYCORN_RUN_FRAMES;
        srcX = runFrame * srcW;
        srcY = 0;
      } else if (!player.onGround && SPRITES.kittycornJump) {
        sprite = SPRITES.kittycornJump;
        srcW = CFG.SPRITE_KITTYCORN_JUMP_FW;
        srcH = CFG.SPRITE_KITTYCORN_JUMP_FH;
        const jFrame = Math.min(Math.floor(gt * 6) % CFG.SPRITE_KITTYCORN_JUMP_FRAMES, CFG.SPRITE_KITTYCORN_JUMP_FRAMES - 1);
        srcX = jFrame * srcW;
        srcY = 0;
      } else if (SPRITES.kittycornStand) {
        sprite = SPRITES.kittycornStand;
        srcW = CFG.SPRITE_KITTYCORN_STAND_W;
        srcH = CFG.SPRITE_KITTYCORN_STAND_H;
        srcX = 0;
        srcY = 0;
      }
    } else if (player.animState === "standPoop" && player.hasWings && SPRITES.standPoopWings) {
      sprite = SPRITES.standPoopWings;
      srcW = CFG.SPRITE_STAND_POOP_WINGS_FW;
      srcH = CFG.SPRITE_STAND_POOP_WINGS_FH;
      srcX = Math.min(player.animFrame, CFG.SPRITE_STAND_POOP_WINGS_FRAMES - 1) * srcW;
      srcY = 0;
    } else if (player.animState === "standPoop" && SPRITES.standPoop) {
      sprite = SPRITES.standPoop;
      srcW = CFG.SPRITE_STAND_POOP_FW;
      srcH = CFG.SPRITE_STAND_POOP_FH;
      srcX = player.animFrame * srcW;
      srcY = 0;
    } else if (player.animState === "run" && player.hasWings && SPRITES.runWings) {
      sprite = SPRITES.runWings;
      srcW = CFG.SPRITE_RUN_WINGS_FW;
      srcH = CFG.SPRITE_RUN_WINGS_FH;
      srcX = (player.animFrame % CFG.SPRITE_RUN_WINGS_FRAMES) * srcW;
      srcY = 0;
    } else if (player.animState === "run" && SPRITES.run) {
      sprite = SPRITES.run;
      srcW = CFG.SPRITE_RUN_FW;
      srcH = CFG.SPRITE_RUN_FH;
      srcX = player.animFrame * srcW;
      srcY = 0;
    } else if ((player.animState === "jump" || player.animState === "fall") &&
               player.hasWings && SPRITES.jumpWings) {
      // Winged jump: cycle through frames
      sprite = SPRITES.jumpWings;
      srcW = CFG.SPRITE_JUMP_WINGS_FW;
      srcH = CFG.SPRITE_JUMP_WINGS_FH;
      const wingFrame = Math.floor(gt * 6) % CFG.SPRITE_JUMP_WINGS_FRAMES;
      srcX = wingFrame * srcW;
      srcY = 0;
    } else if ((player.animState === "jump" || player.animState === "fall") && SPRITES.jump) {
      // No-wings jump: velocity-based frame selection
      sprite = SPRITES.jump;
      srcW = CFG.SPRITE_JUMP_FW;
      srcH = CFG.SPRITE_JUMP_FH;
      drawOverrideH = dh + 5;
      let jumpFrame;
      if (player.jumpType === "first") {
        // Map velocity to frames 0-6: rising=0-2, peak=3, falling=4-6
        const maxV = Math.abs(CFG.JUMP_FORCE);
        const t = (player.vy + maxV) / (maxV + CFG.MAX_FALL); // 0=max rise, 1=max fall
        jumpFrame = Math.min(6, Math.max(0, Math.floor(t * 7)));
      } else {
        // Double/triple jump: cycle through mid-air frames 2-4
        jumpFrame = 2 + Math.floor(gt * 6) % 3;
      }
      srcX = jumpFrame * srcW;
      srcY = 0;
    } else if ((player.animState === "jump" || player.animState === "fall") && SPRITES.fall) {
      // Legacy fallback
      sprite = SPRITES.fall;
      srcW = CFG.SPRITE_FALL_W;
      srcH = CFG.SPRITE_FALL_H;
      srcX = 0;
      srcY = 0;
    } else if (player.hasWings && SPRITES.idleWings) {
      sprite = SPRITES.idleWings;
      srcW = CFG.SPRITE_IDLE_WINGS_W;
      srcH = CFG.SPRITE_IDLE_WINGS_H;
      srcX = 0;
      srcY = 0;
    } else if (SPRITES.idle) {
      sprite = SPRITES.idle;
      srcW = CFG.SPRITE_IDLE_W;
      srcH = CFG.SPRITE_IDLE_H;
      srcX = 0;
      srcY = 0;
    }

    if (sprite) {
      // Draw sprite image - anchor at bottom center (feet)
      // Scale from sprite native size to game draw size
      const scaleRatio = drawOverrideH / srcH;
      const drawW = srcW * scaleRatio;
      const drawH = drawOverrideH;
      let footAdj = 5; // shift sprite down so feet touch ground (sprites have bottom padding)
      if (player.isMouseicorn && !player.isUnderwater) footAdj = 19; // mousicorn art sits higher in frame
      // Apply celebrate bounce flip (kittycorn hoop clear alternates direction)
      if (celebrateFlip !== 1) c.scale(celebrateFlip, 1);
      c.drawImage(
        sprite,
        srcX, srcY, srcW, srcH,     // source rect
        -drawW / 2, -drawH + footAdj, drawW, drawH  // dest rect (bottom-center anchor)
      );
    } else {
      // Procedural fallback if sprites haven't loaded
      this.drawPlayerFallback(c, player, gt, dw, dh);
    }

    c.restore();
  }

  // Simple procedural fallback while sprites load
  drawPlayerFallback(c, player, gt, dw, dh) {
    c.fillStyle = "#ffffff";
    this.roundRect(c, -dw/2, -dh, dw, dh, 6);
    c.fill();
    // Horn
    c.fillStyle = "#ff88cc";
    c.beginPath();
    c.moveTo(dw*0.1, -dh);
    c.lineTo(dw*0.15, -dh - 12);
    c.lineTo(dw*0.2, -dh);
    c.closePath();
    c.fill();
  }

  // Draw a star collectible
  drawStar(ctx, star, gt) {
    if (!star.alive) return;
    const sx = star.cx;
    const sy = star.cy;

    // Glow
    if (!star.collected) {
      const glowSize = 12 + Math.sin(gt * 4 + star.glowPhase) * 4;
      const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
      glow.addColorStop(0, "rgba(255,255,100,0.3)");
      glow.addColorStop(1, "rgba(255,255,100,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(sx, sy, glowSize, 0, Math.PI*2);
      ctx.fill();
    }

    // Star shape
    const pulse = star.collected ? (1 + star.collectTimer * 3) : (1 + Math.sin(gt * 3 + star.phase) * 0.1);
    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(pulse, pulse);
    if (star.collected) ctx.globalAlpha = star.collectTimer / 0.3;
    ctx.rotate(gt * 0.5 + star.phase);

    ctx.fillStyle = "#ffee44";
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const ang = (i * Math.PI * 2 / 5) - Math.PI / 2;
      const r = i === 0 ? 7 : 7;
      ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
      const ang2 = ang + Math.PI / 5;
      ctx.lineTo(Math.cos(ang2) * 3, Math.sin(ang2) * 3);
    }
    ctx.closePath();
    ctx.fill();

    // Star center highlight
    ctx.fillStyle = "#ffffaa";
    ctx.beginPath();
    ctx.arc(0, 0, 2.5, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Draw a fly enemy
  drawFly(ctx, fly, gt) {
    if (!fly.alive) return;
    const fx = fly.cx;
    const fy = fly.cy;
    const drawW = 28;
    const drawH = 28;

    if (SPRITES.fly) {
      const frame = Math.floor(gt * 10) % CFG.SPRITE_FLY_FRAMES;
      const srcX = frame * CFG.SPRITE_FLY_FW;
      ctx.save();
      ctx.translate(fx, fy);
      ctx.scale(fly.dir, 1);
      ctx.drawImage(
        SPRITES.fly,
        srcX, 0, CFG.SPRITE_FLY_FW, CFG.SPRITE_FLY_FH,
        -drawW/2, -drawH/2, drawW, drawH
      );
      ctx.restore();
    } else {
      // Procedural fallback
      ctx.save();
      ctx.translate(fx, fy);
      ctx.scale(fly.dir, 1);
      ctx.fillStyle = "#334";
      ctx.beginPath();
      ctx.ellipse(0, 0, 7, 5, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // Draw a gnome (ground enemy)
  drawGnome(ctx, gnome, gt) {
    if (!gnome.alive) return;
    const gx = gnome.cx;
    const gy = gnome.bottom;
    const drawW = 22;
    const drawH = 36;

    if (SPRITES.gnome) {
      const srcX = gnome.animFrame * CFG.SPRITE_GNOME_FW;
      ctx.save();
      ctx.translate(gx, gy);
      ctx.scale(gnome.dir, 1);
      ctx.drawImage(
        SPRITES.gnome,
        srcX, 0, CFG.SPRITE_GNOME_FW, CFG.SPRITE_GNOME_FH,
        -drawW/2, -drawH, drawW, drawH
      );
      ctx.restore();
    } else {
      // Procedural fallback - red triangle hat, circle body
      ctx.save();
      ctx.translate(gx, gy);
      ctx.fillStyle = "#cc2222";
      ctx.beginPath();
      ctx.moveTo(-6, -14);
      ctx.lineTo(0, -30);
      ctx.lineTo(6, -14);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#886644";
      ctx.beginPath();
      ctx.arc(0, -8, 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // Draw a wing crystal pickup
  drawWingCrystal(ctx, wc, gt) {
    if (!wc.alive || wc.collected) return;
    const wx = wc.cx;
    const wy = wc.cy;

    // Outer glow
    const glowSize = 14 + Math.sin(gt * 3 + wc.phase) * 4;
    const glow = ctx.createRadialGradient(wx, wy, 0, wx, wy, glowSize);
    glow.addColorStop(0, "rgba(200,150,255,0.4)");
    glow.addColorStop(0.5, "rgba(150,100,255,0.15)");
    glow.addColorStop(1, "rgba(150,100,255,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(wx, wy, glowSize, 0, Math.PI*2);
    ctx.fill();

    // Crystal body (diamond shape)
    const pulse = 1 + Math.sin(gt * 4) * 0.1;
    ctx.save();
    ctx.translate(wx, wy);
    ctx.scale(pulse, pulse);
    ctx.rotate(gt * 0.5);

    // Wing shape
    ctx.fillStyle = "#ddb0ff";
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.bezierCurveTo(-10, -10, -12, 0, -6, 5);
    ctx.lineTo(0, 2);
    ctx.lineTo(6, 5);
    ctx.bezierCurveTo(12, 0, 10, -10, 0, -8);
    ctx.closePath();
    ctx.fill();

    // Inner shine
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.beginPath();
    ctx.moveTo(0, -5);
    ctx.bezierCurveTo(-5, -6, -6, 0, -3, 3);
    ctx.lineTo(0, 1);
    ctx.lineTo(3, 3);
    ctx.bezierCurveTo(6, 0, 5, -6, 0, -5);
    ctx.closePath();
    ctx.fill();

    ctx.restore();

    // Sparkle particles around it
    for (let i = 0; i < 3; i++) {
      const ang = gt * 2 + i * (Math.PI * 2 / 3);
      const dist = 10 + Math.sin(gt * 3 + i) * 3;
      const sx = wx + Math.cos(ang) * dist;
      const sy = wy + Math.sin(ang) * dist;
      const alpha = 0.4 + Math.sin(gt * 5 + i * 2) * 0.3;
      ctx.fillStyle = `rgba(220,180,255,${alpha})`;
      ctx.fillRect(sx - 1, sy - 1, 2, 2);
    }
  }

  // Draw a fish enemy (procedural)
  drawFish(ctx, fish, gt) {
    if (!fish.alive) return;
    const fx = fish.cx;
    const fy = fish.cy;

    if (SPRITES.fishSprite) {
      // Sprite-based fish
      const frame = Math.floor(gt * 6) % CFG.SPRITE_FISH_FRAMES;
      const srcX = frame * CFG.SPRITE_FISH_FW;
      const drawH = 24;  // game-size height for fish
      const scale = drawH / CFG.SPRITE_FISH_FH;
      const drawW = CFG.SPRITE_FISH_FW * scale;
      ctx.save();
      ctx.translate(fx, fy);
      ctx.scale(fish.dir, 1);
      ctx.drawImage(SPRITES.fishSprite,
        srcX, 0, CFG.SPRITE_FISH_FW, CFG.SPRITE_FISH_FH,
        -drawW/2, -drawH/2, drawW, drawH);
      ctx.restore();
    } else {
      // Procedural fallback
      ctx.save();
      ctx.translate(fx, fy);
      ctx.scale(fish.dir, 1);
      ctx.fillStyle = fish.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, 10, 6, 0, 0, Math.PI*2);
      ctx.fill();
      const tailSwing = Math.sin(fish.tailPhase) * 0.4;
      ctx.beginPath();
      ctx.moveTo(-8, 0);
      ctx.lineTo(-14, -5 + tailSwing * 5);
      ctx.lineTo(-14, 5 + tailSwing * 5);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(5, -2, 2.5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.arc(5.5, -2, 1.2, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Bubble trail
    for (let i = 0; i < 2; i++) {
      const bx = fx - fish.dir * (12 + i * 6);
      const by = fy - 3 + Math.sin(gt * 8 + i * 2) * 3;
      ctx.fillStyle = `rgba(150,200,255,${0.2 - i * 0.08})`;
      ctx.beginPath();
      ctx.arc(bx, by, 1.5 - i * 0.3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Draw a jellyfish enemy
  drawJellyfish(ctx, jelly, gt) {
    if (!jelly.alive) return;
    const jx = jelly.cx;
    const jy = jelly.cy;

    if (SPRITES.jellyfishSprite) {
      // Sprite-based jellyfish (some are 35% bigger)
      const frame = Math.floor(gt * 4) % CFG.SPRITE_JELLYFISH_FRAMES;
      const srcX = frame * CFG.SPRITE_JELLYFISH_FW;
      const drawH = 32 * (jelly.sizeScale || 1.0);
      const scale = drawH / CFG.SPRITE_JELLYFISH_FH;
      const drawW = CFG.SPRITE_JELLYFISH_FW * scale;
      ctx.save();
      ctx.translate(jx, jy);
      ctx.drawImage(SPRITES.jellyfishSprite,
        srcX, 0, CFG.SPRITE_JELLYFISH_FW, CFG.SPRITE_JELLYFISH_FH,
        -drawW/2, -drawH/2, drawW, drawH);
      ctx.restore();
    } else {
      // Procedural fallback (some are 35% bigger)
      const js = jelly.sizeScale || 1.0;
      const pulse = Math.sin(jelly.pulsePhase) * 0.15;
      ctx.save();
      ctx.translate(jx, jy);
      ctx.scale(js, js);
      ctx.fillStyle = jelly.color;
      ctx.globalAlpha = 0.25;
      ctx.beginPath(); ctx.arc(0, -3, 16, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(0, -3, 8 + pulse * 4, 6 + pulse * 2, 0, Math.PI, 0);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.beginPath(); ctx.ellipse(0, -5, 4, 3, 0, Math.PI, 0); ctx.fill();
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = jelly.color;
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 5; i++) {
        const tx = -6 + i * 3;
        const sway = Math.sin(gt * 3 + i * 1.2) * 4;
        ctx.beginPath(); ctx.moveTo(tx, -1);
        ctx.quadraticCurveTo(tx + sway, 8, tx - sway * 0.5, 16); ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  // Draw a narwhal enemy
  drawNarwhal(ctx, nw, gt) {
    if (!nw.alive) return;
    const nx = nw.cx;
    const ny = nw.cy;

    if (SPRITES.narwhal) {
      const srcX = nw.animFrame * CFG.SPRITE_NARWHAL_FW;
      const drawH = 56;
      const scale = drawH / CFG.SPRITE_NARWHAL_FH;
      const drawW = CFG.SPRITE_NARWHAL_FW * scale;
      ctx.save();
      ctx.translate(nx, ny);
      ctx.scale(nw.dir, 1);
      ctx.drawImage(SPRITES.narwhal,
        srcX, 0, CFG.SPRITE_NARWHAL_FW, CFG.SPRITE_NARWHAL_FH,
        -drawW/2, -drawH/2, drawW, drawH);
      ctx.restore();
    } else {
      // Procedural fallback — grey torpedo shape with horn (2x size)
      ctx.save();
      ctx.translate(nx, ny);
      ctx.scale(nw.dir, 1);
      ctx.fillStyle = "#667788";
      ctx.beginPath();
      ctx.ellipse(0, 0, 24, 14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "#ccddee";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(20, -4); ctx.lineTo(40, -12); ctx.stroke();
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(12, -4, 3.5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.arc(13, -4, 1.8, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // Draw a bird enemy (procedural — dark silhouette with flapping wings)
  drawBird(ctx, bird, gt) {
    if (!bird.alive) return;
    const bx = bird.cx;
    const by = bird.cy;

    if (SPRITES.hawk) {
      const srcX = bird.animFrame * CFG.SPRITE_HAWK_FW;
      const drawH = 28;
      const scale = drawH / CFG.SPRITE_HAWK_FH;
      const drawW = CFG.SPRITE_HAWK_FW * scale;
      ctx.save();
      ctx.translate(bx, by);
      ctx.scale(bird.dir, 1);
      ctx.drawImage(SPRITES.hawk,
        srcX, 0, CFG.SPRITE_HAWK_FW, CFG.SPRITE_HAWK_FH,
        -drawW/2, -drawH/2, drawW, drawH);
      ctx.restore();
    } else {
      // Procedural fallback
      const wingAngle = Math.sin(bird.wingPhase) * 0.6;
      ctx.save();
      ctx.translate(bx, by);
      ctx.scale(bird.dir, 1);
      ctx.fillStyle = "#2a1a0a";
      ctx.beginPath();
      ctx.ellipse(0, 0, 10, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#1a0a00";
      ctx.beginPath();
      ctx.arc(8, -3, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#cc8800";
      ctx.beginPath();
      ctx.moveTo(12, -3); ctx.lineTo(17, -2); ctx.lineTo(12, -1);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = "#ff4400";
      ctx.beginPath();
      ctx.arc(9, -4, 1.5, 0, Math.PI*2);
      ctx.fill();
      ctx.save();
      ctx.translate(-4, -4);
      ctx.rotate(-wingAngle);
      ctx.fillStyle = "#3a2510";
      ctx.beginPath();
      ctx.moveTo(0,0); ctx.lineTo(-12,-8); ctx.lineTo(-8,-2); ctx.lineTo(-14,2); ctx.lineTo(0,2);
      ctx.closePath(); ctx.fill();
      ctx.restore();
      ctx.fillStyle = "#2a1a0a";
      ctx.beginPath();
      ctx.moveTo(-8,-2); ctx.lineTo(-16,-4); ctx.lineTo(-14,0); ctx.lineTo(-16,3); ctx.lineTo(-8,2);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
  }

  // Draw a mousicorn gem pickup (cheese wedge with mouse ears)
  drawMousicornGem(ctx, gem, gt) {
    if (!gem.alive || gem.collected) return;
    const gx = gem.cx;
    const gy = gem.cy;
    const pulse = Math.sin(gt * 4) * 0.2 + 0.8;
    const hue = (gt * 50 + 30) % 360; // warm brown-orange cycling

    // Glow
    ctx.fillStyle = `rgba(200,150,80,${0.18 * pulse})`;
    ctx.beginPath();
    ctx.arc(gx, gy, 14, 0, Math.PI*2);
    ctx.fill();

    // Cheese wedge body (triangle)
    ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
    ctx.beginPath();
    ctx.moveTo(gx - 7, gy + 6);
    ctx.lineTo(gx + 7, gy + 6);
    ctx.lineTo(gx, gy - 7);
    ctx.closePath();
    ctx.fill();

    // Cheese holes
    ctx.fillStyle = `hsl(${(hue + 20) % 360}, 60%, 40%)`;
    ctx.beginPath(); ctx.arc(gx - 2, gy + 2, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + 3, gy + 3, 1, 0, Math.PI*2); ctx.fill();

    // Mouse ears on top
    ctx.fillStyle = `hsl(${(hue + 30) % 360}, 50%, 50%)`;
    ctx.beginPath();
    ctx.arc(gx - 4, gy - 9, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(gx + 4, gy - 9, 4, 0, Math.PI*2);
    ctx.fill();
    // Inner ears
    ctx.fillStyle = `hsl(${(hue + 10) % 360}, 60%, 65%)`;
    ctx.beginPath();
    ctx.arc(gx - 4, gy - 9, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(gx + 4, gy - 9, 2, 0, Math.PI*2);
    ctx.fill();

    // Inner highlight
    ctx.fillStyle = `rgba(255,255,255,${0.3 * pulse})`;
    ctx.beginPath();
    ctx.moveTo(gx - 3, gy + 3);
    ctx.lineTo(gx + 3, gy + 3);
    ctx.lineTo(gx, gy - 3);
    ctx.closePath();
    ctx.fill();

    // Sparkle orbits
    for (let i = 0; i < 4; i++) {
      const angle = gt * 3 + (i * Math.PI / 2);
      const sx = gx + Math.cos(angle) * 10;
      const sy = gy + Math.sin(angle) * 10;
      ctx.fillStyle = `rgba(220,180,100,${0.5 * pulse})`;
      ctx.beginPath();
      ctx.arc(sx, sy, 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Draw a kittycorn gem pickup (pink cat-ear crystal)
  drawKittycornGem(ctx, gem, gt) {
    if (!gem.alive || gem.collected) return;
    const gx = gem.cx;
    const gy = gem.cy;
    const pulse = Math.sin(gt * 4) * 0.2 + 0.8;
    const hue = (gt * 60) % 360;
    // Glow
    ctx.fillStyle = `rgba(255,100,180,${0.15 * pulse})`;
    ctx.beginPath();
    ctx.arc(gx, gy, 14, 0, Math.PI*2);
    ctx.fill();
    // Crystal body (diamond shape)
    ctx.fillStyle = `hsl(${hue}, 80%, 65%)`;
    ctx.beginPath();
    ctx.moveTo(gx, gy - 8);
    ctx.lineTo(gx + 6, gy);
    ctx.lineTo(gx, gy + 8);
    ctx.lineTo(gx - 6, gy);
    ctx.closePath();
    ctx.fill();
    // Cat ears on top
    ctx.fillStyle = `hsl(${(hue + 30) % 360}, 80%, 60%)`;
    ctx.beginPath();
    ctx.moveTo(gx - 5, gy - 6);
    ctx.lineTo(gx - 8, gy - 13);
    ctx.lineTo(gx - 2, gy - 8);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(gx + 5, gy - 6);
    ctx.lineTo(gx + 8, gy - 13);
    ctx.lineTo(gx + 2, gy - 8);
    ctx.closePath();
    ctx.fill();
    // Inner highlight
    ctx.fillStyle = `rgba(255,255,255,${0.3 * pulse})`;
    ctx.beginPath();
    ctx.moveTo(gx, gy - 4);
    ctx.lineTo(gx + 3, gy);
    ctx.lineTo(gx, gy + 4);
    ctx.lineTo(gx - 3, gy);
    ctx.closePath();
    ctx.fill();
    // Sparkle orbits
    for (let i = 0; i < 4; i++) {
      const angle = gt * 3 + (i * Math.PI / 2);
      const sx = gx + Math.cos(angle) * 10;
      const sy = gy + Math.sin(angle) * 10;
      ctx.fillStyle = `rgba(255,180,220,${0.5 * pulse})`;
      ctx.beginPath();
      ctx.arc(sx, sy, 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Draw a pixicorn gem pickup (fairy diamond with tiny wings)
  drawPixicornGem(ctx, gem, gt) {
    if (!gem.alive || gem.collected) return;
    const gx = gem.cx;
    const gy = gem.cy;
    const pulse = Math.sin(gt * 4) * 0.2 + 0.8;
    const hue = (gt * 80 + 260) % 360; // lavender/purple cycling

    // Glow
    ctx.fillStyle = `rgba(180,100,255,${0.2 * pulse})`;
    ctx.beginPath();
    ctx.arc(gx, gy, 14, 0, Math.PI*2);
    ctx.fill();

    // Crystal body (diamond shape)
    ctx.fillStyle = `hsl(${hue}, 70%, 65%)`;
    ctx.beginPath();
    ctx.moveTo(gx, gy - 8);
    ctx.lineTo(gx + 6, gy);
    ctx.lineTo(gx, gy + 8);
    ctx.lineTo(gx - 6, gy);
    ctx.closePath();
    ctx.fill();

    // Tiny wings on sides
    ctx.fillStyle = `hsla(${(hue + 40) % 360}, 80%, 75%, 0.7)`;
    // Left wing
    ctx.beginPath();
    ctx.moveTo(gx - 5, gy - 2);
    ctx.quadraticCurveTo(gx - 14, gy - 8, gx - 10, gy + 2);
    ctx.lineTo(gx - 5, gy);
    ctx.closePath();
    ctx.fill();
    // Right wing
    ctx.beginPath();
    ctx.moveTo(gx + 5, gy - 2);
    ctx.quadraticCurveTo(gx + 14, gy - 8, gx + 10, gy + 2);
    ctx.lineTo(gx + 5, gy);
    ctx.closePath();
    ctx.fill();

    // Inner highlight
    ctx.fillStyle = `rgba(255,255,255,${0.35 * pulse})`;
    ctx.beginPath();
    ctx.moveTo(gx, gy - 4);
    ctx.lineTo(gx + 3, gy);
    ctx.lineTo(gx, gy + 4);
    ctx.lineTo(gx - 3, gy);
    ctx.closePath();
    ctx.fill();

    // Sparkle dust orbiting
    for (let i = 0; i < 5; i++) {
      const angle = gt * 3.5 + (i * Math.PI * 2 / 5);
      const sx = gx + Math.cos(angle) * 11;
      const sy = gy + Math.sin(angle) * 11;
      ctx.fillStyle = `rgba(200,140,255,${0.5 * pulse})`;
      ctx.beginPath();
      ctx.arc(sx, sy, 1.2, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Draw a fireball projectile
  drawFireball(ctx, fb, gt) {
    if (!fb.alive) return;
    const fx = fb.cx;
    const fy = fb.cy;

    // Outer glow
    ctx.fillStyle = `rgba(255,100,0,${0.3 + Math.sin(gt * 20) * 0.1})`;
    ctx.beginPath();
    ctx.arc(fx, fy, 8, 0, Math.PI*2);
    ctx.fill();

    // Core
    ctx.fillStyle = `rgb(255,${180 + Math.floor(Math.sin(gt * 15) * 40)},0)`;
    ctx.beginPath();
    ctx.arc(fx, fy, 5, 0, Math.PI*2);
    ctx.fill();

    // Hot center
    ctx.fillStyle = "#ffffaa";
    ctx.beginPath();
    ctx.arc(fx, fy, 2.5, 0, Math.PI*2);
    ctx.fill();
  }

  // Draw a mermaid gem pickup (bright rainbow gem)
  drawMermaidGem(ctx, gem, gt) {
    if (!gem.alive || gem.collected) return;
    const gx = gem.cx;
    const gy = gem.cy;
    const rainbowColors = ["#ff0044","#ff8800","#ffdd00","#00dd44","#0088ff","#8844ff"];

    // Outer rainbow glow
    const glowSize = 16 + Math.sin(gt * 3 + gem.phase) * 4;
    const glow = ctx.createRadialGradient(gx, gy, 0, gx, gy, glowSize);
    const hue = (gt * 60) % 360;
    glow.addColorStop(0, `hsla(${hue},100%,70%,0.6)`);
    glow.addColorStop(0.5, `hsla(${(hue+60)%360},100%,60%,0.25)`);
    glow.addColorStop(1, `hsla(${(hue+120)%360},100%,50%,0)`);
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(gx, gy, glowSize, 0, Math.PI*2);
    ctx.fill();

    // Gem body (diamond/crystal shape)
    const pulse = 1 + Math.sin(gt * 4) * 0.1;
    ctx.save();
    ctx.translate(gx, gy);
    ctx.scale(pulse, pulse);
    ctx.rotate(Math.sin(gt * 1.5) * 0.15);

    // Diamond shape with rainbow gradient
    const gemGrad = ctx.createLinearGradient(-7, -9, 7, 9);
    for (let i = 0; i < rainbowColors.length; i++) {
      gemGrad.addColorStop(i / (rainbowColors.length - 1), rainbowColors[i]);
    }
    ctx.fillStyle = gemGrad;
    ctx.beginPath();
    ctx.moveTo(0, -9);    // top point
    ctx.lineTo(7, -2);    // upper right
    ctx.lineTo(7, 2);     // lower right
    ctx.lineTo(0, 9);     // bottom point
    ctx.lineTo(-7, 2);    // lower left
    ctx.lineTo(-7, -2);   // upper left
    ctx.closePath();
    ctx.fill();

    // White highlight facets
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.beginPath();
    ctx.moveTo(0, -9);
    ctx.lineTo(7, -2);
    ctx.lineTo(0, 0);
    ctx.lineTo(-7, -2);
    ctx.closePath();
    ctx.fill();

    // Bright center sparkle
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.beginPath();
    ctx.arc(0, -1, 2.5, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();

    // Orbiting rainbow sparkle particles
    for (let i = 0; i < 5; i++) {
      const ang = gt * 2.5 + i * (Math.PI * 2 / 5);
      const dist = 11 + Math.sin(gt * 3 + i) * 3;
      const sx = gx + Math.cos(ang) * dist;
      const sy = gy + Math.sin(ang) * dist;
      const alpha = 0.6 + Math.sin(gt * 5 + i * 2) * 0.3;
      ctx.fillStyle = rainbowColors[i % rainbowColors.length].replace(")", `,${alpha})`).replace("rgb", "rgba");
      // Use solid color with size variation
      const sz = 1.5 + Math.sin(gt * 4 + i) * 0.5;
      ctx.fillStyle = rainbowColors[i];
      ctx.globalAlpha = alpha;
      ctx.fillRect(sx - sz/2, sy - sz/2, sz, sz);
    }
    ctx.globalAlpha = 1;
  }

  // Draw the goal hoop
  drawHoop(ctx, hoop, gt) {
    if (!hoop.alive) return;
    const hx = hoop.cx;
    const hy = hoop.y;

    // Pole
    ctx.fillStyle = "#888";
    ctx.fillRect(hx - 2, hy, 4, hoop.h);

    // Hoop ring
    const rainbow = ["#ff0000","#ff8800","#ffff00","#00ff00","#0088ff","#8800cc","#ff00ff"];
    const ringY = hy + 5;
    const ringW = 14;
    const ringH = 20;
    for (let i = 0; i < rainbow.length; i++) {
      ctx.strokeStyle = rainbow[i];
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(hx, ringY + i * 2 + Math.sin(gt * 2 + i * 0.4) * 1, ringW, ringH - i, 0, 0, Math.PI*2);
      ctx.stroke();
    }

    // Sparkle on top
    const sparkle = Math.sin(gt * 6) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(255,255,200,${sparkle * 0.8})`;
    ctx.beginPath();
    ctx.arc(hx, hy, 4 + sparkle * 2, 0, Math.PI*2);
    ctx.fill();
  }

  // Draw poop projectile
  drawPoop(ctx, poop, gt) {
    if (!poop.alive) return;
    const px = poop.cx;
    const py = poop.bottom;
    const drawW = 28;
    const drawH = 28;

    if (SPRITES.poop) {
      let frame;
      if (poop.landed) {
        frame = CFG.SPRITE_POOP_FRAMES - 1; // show final poop pile
      } else {
        frame = Math.floor(gt * 8) % CFG.SPRITE_POOP_FRAMES;
      }
      const srcX = frame * CFG.SPRITE_POOP_FW;
      // Fade out after landing
      if (poop.landed && poop.landedTimer > poop.fadeTime - 1.0) {
        ctx.globalAlpha = Math.max(0, (poop.fadeTime - poop.landedTimer));
      }
      ctx.drawImage(
        SPRITES.poop,
        srcX, 0, CFG.SPRITE_POOP_FW, CFG.SPRITE_POOP_FH,
        px - drawW/2, py - drawH, drawW, drawH
      );
      ctx.globalAlpha = 1;
    } else {
      // Procedural fallback - sparkly pink blob
      ctx.fillStyle = "#cc88ff";
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  drawDeadFlower(ctx, flower, gt) {
    if (!flower.alive) return;
    const px = flower.cx;
    const py = flower.bottom;
    ctx.save();
    if (flower.revived) {
      // Alive flower - colorful, slight sway
      const sway = Math.sin(gt * 2 + px) * 2;
      // Stem
      ctx.strokeStyle = "#22aa22";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.quadraticCurveTo(px + sway, py - 8, px + sway * 0.5, py - 14);
      ctx.stroke();
      // Petals
      const colors = ["#ff4488", "#ff66aa", "#ff88cc", "#ff44aa", "#ff55bb"];
      for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2 + gt * 0.5;
        const pr = 4;
        ctx.fillStyle = colors[i];
        ctx.beginPath();
        ctx.ellipse(px + sway * 0.5 + Math.cos(a) * pr, py - 14 + Math.sin(a) * pr, 3, 2, a, 0, Math.PI * 2);
        ctx.fill();
      }
      // Center
      ctx.fillStyle = "#ffee44";
      ctx.beginPath();
      ctx.arc(px + sway * 0.5, py - 14, 2, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Dead flower - brown/wilted, drooping
      ctx.strokeStyle = "#8B6914";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.quadraticCurveTo(px + 2, py - 6, px + 4, py - 10);
      ctx.stroke();
      // Wilted petals
      ctx.fillStyle = "#9B7924";
      for (let i = 0; i < 4; i++) {
        const a = (i / 4) * Math.PI * 2 - 0.3;
        ctx.beginPath();
        ctx.ellipse(px + 4 + Math.cos(a) * 3, py - 10 + Math.sin(a) * 2, 2.5, 1.5, a + 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = "#6B5910";
      ctx.beginPath();
      ctx.arc(px + 4, py - 10, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  drawBlackFlower(ctx, flower, gt) {
    if (!flower.alive || flower.used) return;
    const px = flower.cx;
    const py = flower.bottom;
    ctx.save();
    // Dark menacing stem
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.quadraticCurveTo(px - 1, py - 8, px, py - 14);
    ctx.stroke();
    // Black petals with purple tint
    const glow = Math.sin(gt * 3) * 0.15 + 0.85;
    for (let i = 0; i < 6; i++) {
      const a = (i / 6) * Math.PI * 2 + gt * 0.3;
      ctx.fillStyle = `rgba(60,0,80,${glow})`;
      ctx.beginPath();
      ctx.ellipse(px + Math.cos(a) * 4, py - 14 + Math.sin(a) * 3, 3, 2, a, 0, Math.PI * 2);
      ctx.fill();
    }
    // Dark center
    ctx.fillStyle = "#1a001a";
    ctx.beginPath();
    ctx.arc(px, py - 14, 2.5, 0, Math.PI * 2);
    ctx.fill();
    // Subtle purple glow
    ctx.fillStyle = `rgba(120,0,180,${glow * 0.3})`;
    ctx.beginPath();
    ctx.arc(px, py - 14, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  drawRainbowBolt(ctx, bolt, gt) {
    if (!bolt.alive) return;
    const px = bolt.cx;
    const py = bolt.cy;
    ctx.save();
    // Rainbow trail - 6 colored stripes
    const colors = ["#ff0000","#ff8800","#ffff00","#00ff00","#0088ff","#8800ff"];
    const trailLen = 12;
    for (let i = 0; i < colors.length; i++) {
      const yOff = (i - 2.5) * 1.5;
      ctx.strokeStyle = colors[i];
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(px - bolt.facing * trailLen, py + yOff + Math.sin(gt * 12 + i) * 1);
      ctx.lineTo(px, py + yOff);
      ctx.stroke();
    }
    // Bright white core
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(px, py, 3, 0, Math.PI * 2);
    ctx.fill();
    // Glow
    ctx.fillStyle = `rgba(255,200,255,${0.3 + Math.sin(gt * 15) * 0.15})`;
    ctx.beginPath();
    ctx.arc(px, py, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  drawHayBale(ctx, bale, gt) {
    if (!bale.alive) return;
    const px = bale.cx;
    const py = bale.bottom;
    const bob = Math.sin(gt * 4) * 1;
    ctx.save();
    // Main bale body - golden cylinder
    ctx.fillStyle = "#daa520";
    this.roundRect(ctx, px - 8, py - 12 + bob, 16, 12, 3);
    ctx.fill();
    // Straw texture lines
    ctx.strokeStyle = "#c89418";
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 4; i++) {
      const lx = px - 6 + i * 4;
      ctx.beginPath();
      ctx.moveTo(lx, py - 10 + bob);
      ctx.lineTo(lx + 1, py - 2 + bob);
      ctx.stroke();
    }
    // Binding straps
    ctx.strokeStyle = "#8B6914";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(px - 8, py - 8 + bob);
    ctx.lineTo(px + 8, py - 8 + bob);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px - 8, py - 4 + bob);
    ctx.lineTo(px + 8, py - 4 + bob);
    ctx.stroke();
    // Sparkle to show it's collectible
    const sparkle = Math.sin(gt * 6) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(255,255,200,${sparkle * 0.6})`;
    ctx.beginPath();
    ctx.arc(px, py - 12 + bob, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Draw form gate
  drawFormGate(ctx, gate, gt) {
    if (gate.isOpen()) return;
    ctx.save();
    ctx.translate(gate.x, gate.y);

    const gw = gate.w + 20; // visual width wider than hitbox
    const gh = gate.h;

    // Opening animation: slide apart
    if (gate.opened) {
      const t = gate.openTimer / gate.openDuration;
      const slide = t * gw;
      ctx.translate(-slide * 0.5, 0);
      ctx.globalAlpha = 1 - t;
    }

    // Stone wall
    ctx.fillStyle = "#6a6050";
    ctx.fillRect(-5, 0, gw, gh);
    // Stone block lines
    ctx.strokeStyle = "#4a4030";
    ctx.lineWidth = 1;
    for (let row = 0; row < gh; row += 12) {
      const offset = (row / 12) % 2 === 0 ? 0 : 10;
      for (let col = offset; col < gw; col += 20) {
        ctx.strokeRect(-5 + col, row, 20, 12);
      }
    }

    // Gate form icon and glow
    const formColors = {
      mousicorn: "#aaaacc",
      kittycorn: "#ffaacc",
      mermaid: "#44ccff",
      pixicorn: "#ffdd44"
    };
    const color = formColors[gate.requiredForm] || "#ffffff";
    const pulse = 0.5 + Math.sin(gt * 3) * 0.3;

    // Arch shape at bottom (passthrough hole silhouette)
    ctx.fillStyle = `rgba(0,0,0,0.6)`;
    ctx.beginPath();
    if (gate.requiredForm === "mousicorn") {
      // Mouse-hole arch (rounded at top, flat bottom)
      ctx.moveTo(2, gh);
      ctx.quadraticCurveTo(2, gh - 28, gw/2, gh - 32);
      ctx.quadraticCurveTo(gw - 7, gh - 28, gw - 7, gh);
      ctx.closePath();
    } else {
      // Doorway arch
      ctx.moveTo(4, gh);
      ctx.lineTo(4, gh - 35);
      ctx.quadraticCurveTo(gw/2, gh - 50, gw - 9, gh - 35);
      ctx.lineTo(gw - 9, gh);
      ctx.closePath();
    }
    ctx.fill();

    // Glowing icon above arch
    ctx.fillStyle = color;
    ctx.globalAlpha = pulse;
    ctx.beginPath();
    ctx.arc(gw/2, gh - 45, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Form label
    ctx.fillStyle = color;
    ctx.font = "bold 6px monospace";
    ctx.textAlign = "center";
    ctx.fillText(gate.requiredForm.toUpperCase(), gw/2, gh - 52);

    ctx.restore();
  }

  // Draw the boss (Gnome King / Squid / Hawk / Pharaoh Cat)
  drawBoss(ctx, boss, gt) {
    if (!boss.alive) return;
    const bx = boss.cx;
    const by = boss.bottom;

    // Invincibility flash
    if (boss.invTimer > 0 && Math.floor(gt * 8) % 2 === 0) return;

    // Storm Dragon boss — sprite-based drawing
    if (boss.bossType === "storm_dragon" && SPRITES.dragonBoss) {
      const dfw = CFG.SPRITE_DRAGON_BOSS_FW;
      const dfh = CFG.SPRITE_DRAGON_BOSS_FH;
      const drawH = 90;
      const drawW = drawH * (dfw / dfh);

      // Pick frame based on phase
      let frame = 0;
      if (boss.defeated || boss.phase === "stunned") {
        frame = 1; // neutral pose when stunned
      } else if (boss.dragonPhase === "dive") {
        frame = 0; // diving forward pose
      } else if (boss.dragonPhase === "breathe") {
        frame = 2; // wings spread breathing pose
      } else {
        // fly/rise — cycle all 3 frames
        frame = Math.floor(gt * 6) % CFG.SPRITE_DRAGON_BOSS_FRAMES;
      }

      ctx.save();
      if (boss.defeated) {
        const t = boss.defeatTimer;
        const s = Math.max(0, 1 - t * 0.4);
        ctx.translate(bx, by);
        ctx.rotate(t * 5);
        ctx.scale(s, s);
      } else {
        ctx.translate(bx, by);
        ctx.scale(boss.dir, 1);
      }

      // Shadow
      if (!boss.defeated) {
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 24, 6, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // Hit flash effect — blink when stunned
      if (boss.phase === "stunned" && Math.floor(gt * 10) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      // Breath fire effect (drawn behind sprite during breathe phase)
      if (boss.dragonPhase === "breathe" && !boss.defeated) {
        ctx.fillStyle = "rgba(255,100,20,0.6)";
        ctx.beginPath();
        ctx.moveTo(drawW/2 + 5, -drawH/2 - 5);
        ctx.quadraticCurveTo(drawW/2 + 20, -drawH/2 - 10 + Math.sin(gt*12)*4, drawW/2 + 35, -drawH/2 + Math.sin(gt*8)*6);
        ctx.quadraticCurveTo(drawW/2 + 20, -drawH/2 + 5 + Math.sin(gt*10)*3, drawW/2 + 5, -drawH/2 + 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "rgba(255,200,50,0.4)";
        ctx.beginPath();
        ctx.moveTo(drawW/2 + 8, -drawH/2 - 2);
        ctx.quadraticCurveTo(drawW/2 + 18, -drawH/2 - 5 + Math.sin(gt*15)*3, drawW/2 + 28, -drawH/2);
        ctx.quadraticCurveTo(drawW/2 + 18, -drawH/2 + 3, drawW/2 + 8, -drawH/2 + 1);
        ctx.closePath();
        ctx.fill();
      }

      ctx.drawImage(SPRITES.dragonBoss,
        frame * dfw, 0, dfw, dfh,
        -drawW / 2, -drawH, drawW, drawH
      );

      // Lightning crackling during dive (over sprite)
      if (boss.dragonPhase === "dive" && !boss.defeated) {
        ctx.strokeStyle = "rgba(180,200,255,0.7)";
        ctx.lineWidth = 1.5;
        for (let li = 0; li < 3; li++) {
          const lx = -10 + li * 12 + Math.sin(gt*20+li)*4;
          ctx.beginPath();
          ctx.moveTo(lx, 0);
          ctx.lineTo(lx + Math.sin(gt*30)*3, 8);
          ctx.lineTo(lx - 2, 14);
          ctx.stroke();
        }
      }

      ctx.globalAlpha = 1;

      // Health bar
      if (!boss.defeated) {
        const barW = 48;
        const barH = 5;
        const barY = 6;
        ctx.fillStyle = "#000044";
        ctx.fillRect(-barW/2, barY, barW, barH);
        ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ffaa22" : "#4488ff";
        ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = "#88aaff";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-barW/2, barY, barW, barH);
      }

      // Stunned stars
      if (boss.phase === "stunned") {
        for (let i = 0; i < 3; i++) {
          const a = gt * 4 + i * (Math.PI * 2 / 3);
          const sx = Math.cos(a) * 20;
          const sy = -drawH - 6 + Math.sin(a) * 5;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath(); ctx.arc(sx, sy, 2.5, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore();
      return; // done drawing storm dragon boss
    }

    // Shadow Queen boss — sprite-based drawing
    if (boss.bossType === "shadow_queen" && SPRITES.shadowQueenBoss) {
      const sfw = CFG.SPRITE_SHADOW_BOSS_FW;
      const sfh = CFG.SPRITE_SHADOW_BOSS_FH;
      const drawH = 90;
      const drawW = drawH * (sfw / sfh);

      // Pick frame based on phase
      // Frames 0-1: standing/shooting, Frames 2-4: flying
      let frame = 0;
      if (boss.defeated || boss.phase === "stunned") {
        frame = 0; // standing frame with flash
      } else if (boss.queenPhase === "nova") {
        // Standing and shooting — cycle frames 0-1
        frame = Math.floor(gt * 4) % CFG.SPRITE_SHADOW_BOSS_STAND_FRAMES;
      } else {
        // Flying — float, dash, teleport all use fly frames 2-4
        frame = CFG.SPRITE_SHADOW_BOSS_FLY_START + Math.floor(gt * 8) % CFG.SPRITE_SHADOW_BOSS_FLY_FRAMES;
      }

      ctx.save();
      const teleportAlpha = boss.queenPhase === "teleport" ?
        (boss.teleportTimer < 0.3 ? 1 - boss.teleportTimer / 0.3 :
         boss.teleportTimer < 0.5 ? 0 :
         Math.min(1, (boss.teleportTimer - 0.5) / 0.3)) : 1;

      if (boss.defeated) {
        const t = boss.defeatTimer;
        const s = Math.max(0, 1 - t * 0.4);
        ctx.translate(bx, by);
        ctx.globalAlpha = s;
        ctx.rotate(t * 6);
        ctx.scale(s, s);
      } else {
        ctx.translate(bx, by);
        ctx.globalAlpha = teleportAlpha;
        ctx.scale(boss.dir, 1);
      }

      // Shadow aura
      if (!boss.defeated) {
        const auraSize = 35 + Math.sin(gt * 3) * 5;
        const grad = ctx.createRadialGradient(0, -drawH / 2, 5, 0, -drawH / 2, auraSize);
        grad.addColorStop(0, "rgba(100,0,180,0.15)");
        grad.addColorStop(1, "rgba(50,0,100,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, -drawH / 2, auraSize, 0, Math.PI*2);
        ctx.fill();
      }

      // Shadow beneath
      if (!boss.defeated) {
        ctx.fillStyle = "rgba(40,0,60,0.4)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 24, 6, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // Dash trail (behind sprite)
      if (boss.queenPhase === "dash") {
        ctx.fillStyle = "rgba(100,0,180,0.3)";
        for (let i = 1; i <= 3; i++) {
          ctx.beginPath();
          ctx.ellipse(-boss.dir * i * 12, -drawH / 2, 10, 18, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // Hit flash effect — blink when stunned
      if (boss.phase === "stunned" && Math.floor(gt * 10) % 2 === 0) {
        ctx.globalAlpha = Math.min(ctx.globalAlpha, 0.5);
      }

      ctx.drawImage(SPRITES.shadowQueenBoss,
        frame * sfw, 0, sfw, sfh,
        -drawW / 2, -drawH, drawW, drawH
      );

      // Nova effect (radial energy rays around sprite)
      if (boss.queenPhase === "nova") {
        ctx.strokeStyle = "rgba(200,100,255,0.5)";
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 6; i++) {
          const a = gt * 3 + i * (Math.PI / 3);
          const r1 = 25 + Math.sin(gt * 6 + i) * 5;
          const r2 = r1 + 12;
          ctx.beginPath();
          ctx.moveTo(Math.cos(a) * r1, -drawH / 2 + Math.sin(a) * r1);
          ctx.lineTo(Math.cos(a) * r2, -drawH / 2 + Math.sin(a) * r2);
          ctx.stroke();
        }
      }

      ctx.globalAlpha = 1;

      // Health bar (dark purple themed)
      if (!boss.defeated) {
        const barW = 44;
        const barH = 5;
        const barY = 8;
        ctx.fillStyle = "#1a0030";
        ctx.fillRect(-barW/2, barY, barW, barH);
        ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ff66ff" : "#aa44ff";
        ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = "#cc66ff";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-barW/2, barY, barW, barH);
      }

      // Stunned stars
      if (boss.phase === "stunned") {
        for (let i = 0; i < 3; i++) {
          const a = gt * 4 + i * (Math.PI * 2 / 3);
          const sx = Math.cos(a) * 18;
          const sy = -drawH - 6 + Math.sin(a) * 5;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath(); ctx.arc(sx, sy, 2.5, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore();
      return; // done drawing shadow queen boss
    }

    // Flower boss — sprite-based drawing
    const isFlower = boss.bossType === "flower";
    if (isFlower && SPRITES.flowerBoss) {
      const ffw = CFG.SPRITE_FLOWER_BOSS_FW;
      const ffh = CFG.SPRITE_FLOWER_BOSS_FH;
      const drawH = 80;
      const drawW = drawH * (ffw / ffh);

      // Pick frame — cycle all 4 angry faces, faster when shooting
      let frame;
      const animSpeed = boss.phase === "charge" ? 12 : 4;
      frame = Math.floor(gt * animSpeed) % CFG.SPRITE_FLOWER_BOSS_FRAMES;

      ctx.save();
      if (boss.defeated) {
        const t = boss.defeatTimer;
        const s = Math.max(0, 1 - t * 0.4);
        ctx.translate(bx, by);
        ctx.rotate(t * 3);
        ctx.scale(s, s);
      } else {
        ctx.translate(bx, by);
      }

      // Shadow
      if (!boss.defeated) {
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 20, 5, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // Hit flash effect — blink when stunned
      if (boss.phase === "stunned" && Math.floor(gt * 10) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      ctx.drawImage(SPRITES.flowerBoss,
        frame * ffw, 0, ffw, ffh,
        -drawW / 2, -drawH, drawW, drawH
      );

      ctx.globalAlpha = 1;

      // Health bar
      if (!boss.defeated) {
        const barW = 44;
        const barH = 5;
        const barY = 6;
        ctx.fillStyle = "#440000";
        ctx.fillRect(-barW/2, barY, barW, barH);
        ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ffaa22" : "#22ff22";
        ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-barW/2, barY, barW, barH);
      }

      // Stunned stars
      if (boss.phase === "stunned") {
        for (let i = 0; i < 3; i++) {
          const a = gt * 4 + i * (Math.PI * 2 / 3);
          const sx = Math.cos(a) * 16;
          const sy = -drawH - 6 + Math.sin(a) * 5;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath(); ctx.arc(sx, sy, 2.5, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore();
      return; // done drawing flower boss
    }

    // Pharaoh Cat boss — sprite-based drawing
    const isPharaohCat = boss.bossType === "pharaoh_cat";
    if (isPharaohCat && SPRITES.pharaohCatBoss) {
      const pfw = CFG.SPRITE_PHARAOH_BOSS_FW;
      const pfh = CFG.SPRITE_PHARAOH_BOSS_FH;
      const drawH = 80;
      const drawW = drawH * (pfw / pfh);

      // Pick frame based on phase
      let frame = 0;
      if (boss.defeated || boss.phase === "stunned") {
        frame = CFG.SPRITE_PHARAOH_BOSS_ROAR_FRAME; // roar pose when stunned
      } else if (boss.catPhase === "pounce") {
        frame = CFG.SPRITE_PHARAOH_BOSS_CHARGE_FRAME;
      } else if (boss.catPhase === "scratch") {
        frame = CFG.SPRITE_PHARAOH_BOSS_SCRATCH_FRAME;
      } else if (boss.catPhase === "hiss") {
        frame = CFG.SPRITE_PHARAOH_BOSS_HISS_FRAME;
      } else {
        // patrol — cycle walk frames
        frame = Math.floor(gt * 6) % CFG.SPRITE_PHARAOH_BOSS_WALK_FRAMES;
      }

      ctx.save();
      if (boss.defeated) {
        const t = boss.defeatTimer;
        const s = Math.max(0, 1 - t * 0.4);
        ctx.translate(bx, by);
        ctx.rotate(t * 4);
        ctx.scale(s, s);
      } else {
        ctx.translate(bx, by);
        ctx.scale(boss.dir, 1);
      }

      // Shadow
      if (!boss.defeated) {
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 22, 5, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // Hit flash effect — blink when stunned
      if (boss.phase === "stunned" && Math.floor(gt * 10) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      ctx.drawImage(SPRITES.pharaohCatBoss,
        frame * pfw, 0, pfw, pfh,
        -drawW / 2, -drawH, drawW, drawH
      );

      // Scratch effect (white claw marks over sprite during scratch phase)
      if (boss.catPhase === "scratch" && !boss.defeated) {
        const swipeX = drawW/4 + boss.scratchCount * 4;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(swipeX + i * 3, -drawH + 10 - i * 2);
          ctx.lineTo(swipeX + i * 3 + 6, -drawH/2 + i * 2);
          ctx.stroke();
        }
      }

      // Hiss effect (sound wave circles from mouth area)
      if (boss.catPhase === "hiss" && !boss.defeated) {
        ctx.strokeStyle = "rgba(255,200,100,0.5)";
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
          const rad = 8 + i * 8 + Math.sin(gt * 8) * 3;
          ctx.beginPath();
          ctx.arc(drawW/2, -drawH/2, rad, -0.5, 0.5);
          ctx.stroke();
        }
      }

      ctx.globalAlpha = 1;

      // Health bar (gold themed)
      if (!boss.defeated) {
        const barW = 44;
        const barH = 5;
        const barY = 6;
        ctx.fillStyle = "#3a2a00";
        ctx.fillRect(-barW/2, barY, barW, barH);
        ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ffaa22" : "#ffd700";
        ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = "#ffd700";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-barW/2, barY, barW, barH);
      }

      // Stunned stars
      if (boss.phase === "stunned") {
        for (let i = 0; i < 3; i++) {
          const a = gt * 4 + i * (Math.PI * 2 / 3);
          const sx = Math.cos(a) * 18;
          const sy = -drawH - 6 + Math.sin(a) * 5;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath(); ctx.arc(sx, sy, 2.5, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore();
      return; // done drawing pharaoh cat boss
    }

    // Rat King boss — sprite-based drawing
    const isRat = boss.bossType === "rat";
    if (isRat && SPRITES.ratKingBoss) {
      const rfw = CFG.SPRITE_RAT_BOSS_FW;
      const rfh = CFG.SPRITE_RAT_BOSS_FH;
      const drawH = 70;
      const drawW = drawH * (rfw / rfh);

      // Pick frame based on phase
      let frame = 0;
      let animSpeed = 6;
      if (boss.defeated || boss.phase === "stunned") {
        frame = CFG.SPRITE_RAT_BOSS_HIT_FRAME; // hit frame
        animSpeed = 1;
      } else if (boss.phase === "charge") {
        frame = CFG.SPRITE_RAT_BOSS_CHARGE_START + Math.floor(gt * 12) % CFG.SPRITE_RAT_BOSS_CHARGE_FRAMES;
      } else {
        // patrol/idle — cycle walk/taunt frames
        frame = Math.floor(gt * animSpeed) % CFG.SPRITE_RAT_BOSS_WALK_FRAMES;
      }

      ctx.save();
      if (boss.defeated) {
        const t = boss.defeatTimer;
        const s = Math.max(0, 1 - t * 0.4);
        ctx.translate(bx, by);
        ctx.rotate(t * 5);
        ctx.scale(s, s);
      } else {
        ctx.translate(bx, by);
        ctx.scale(boss.dir, 1);
      }

      // Shadow
      if (!boss.defeated) {
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 22, 5, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // Hit flash effect — blink white when stunned
      if (boss.phase === "stunned" && Math.floor(gt * 10) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      ctx.drawImage(SPRITES.ratKingBoss,
        frame * rfw, 0, rfw, rfh,
        -drawW / 2, -drawH, drawW, drawH
      );

      ctx.globalAlpha = 1;

      // Health bar
      if (!boss.defeated) {
        const barW = 44;
        const barH = 5;
        const barY = 6;
        ctx.fillStyle = "#440000";
        ctx.fillRect(-barW/2, barY, barW, barH);
        ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ffaa22" : "#22ff22";
        ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-barW/2, barY, barW, barH);
      }

      // Stunned stars
      if (boss.phase === "stunned") {
        for (let i = 0; i < 3; i++) {
          const a = gt * 4 + i * (Math.PI * 2 / 3);
          const sx = Math.cos(a) * 18;
          const sy = -drawH - 6 + Math.sin(a) * 5;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath(); ctx.arc(sx, sy, 2.5, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore();
      return; // done drawing rat boss
    }

    // Pick sprite sheet & frame based on boss phase + boss type
    const isSquid = boss.bossType === "squid";
    const isHawk = boss.bossType === "hawk";
    let sheet = null, fw = 0, fh = 0, totalFrames = 0, animSpeed = 8;
    let srcOffsetX = 0; // extra X offset into sprite sheet (for hawk hurt frames)
    if (boss.defeated || boss.phase === "stunned") {
      if (isHawk && SPRITES.hawkBoss) {
        sheet = SPRITES.hawkBoss;
        fw = CFG.SPRITE_HAWK_BOSS_FW; fh = CFG.SPRITE_HAWK_BOSS_FH;
        totalFrames = CFG.SPRITE_HAWK_BOSS_HURT_FRAMES; animSpeed = 4;
        srcOffsetX = CFG.SPRITE_HAWK_BOSS_FLY_FRAMES * fw; // frames 5-7
      } else if (isSquid && SPRITES.squidHurt) {
        sheet = SPRITES.squidHurt;
        fw = CFG.SPRITE_SQUID_HURT_FW; fh = CFG.SPRITE_SQUID_HURT_FH;
        totalFrames = 1; animSpeed = 1;
      } else {
        sheet = SPRITES.bossStunned;
        fw = CFG.SPRITE_BOSS_STUNNED_FW; fh = CFG.SPRITE_BOSS_STUNNED_FH;
        totalFrames = CFG.SPRITE_BOSS_STUNNED_FRAMES; animSpeed = 4;
      }
    } else if (boss.phase === "charge" || boss.phase === "swoop") {
      if (isHawk && SPRITES.hawkBoss) {
        sheet = SPRITES.hawkBoss;
        fw = CFG.SPRITE_HAWK_BOSS_FW; fh = CFG.SPRITE_HAWK_BOSS_FH;
        totalFrames = CFG.SPRITE_HAWK_BOSS_FLY_FRAMES; animSpeed = 14;
      } else if (isSquid && SPRITES.squidMove) {
        sheet = SPRITES.squidMove;
        fw = CFG.SPRITE_SQUID_MOVE_FW; fh = CFG.SPRITE_SQUID_MOVE_FH;
        totalFrames = CFG.SPRITE_SQUID_MOVE_FRAMES; animSpeed = 10;
      } else {
        sheet = SPRITES.bossCharge;
        fw = CFG.SPRITE_BOSS_CHARGE_FW; fh = CFG.SPRITE_BOSS_CHARGE_FH;
        totalFrames = CFG.SPRITE_BOSS_CHARGE_FRAMES; animSpeed = 14;
      }
    } else {
      // patrol/fly/rise — use idle/taunt or hawk fly
      if (isHawk && SPRITES.hawkBoss) {
        sheet = SPRITES.hawkBoss;
        fw = CFG.SPRITE_HAWK_BOSS_FW; fh = CFG.SPRITE_HAWK_BOSS_FH;
        totalFrames = CFG.SPRITE_HAWK_BOSS_FLY_FRAMES; animSpeed = 8;
      } else if (isSquid && SPRITES.squidTaunt) {
        sheet = SPRITES.squidTaunt;
        fw = CFG.SPRITE_SQUID_TAUNT_FW; fh = CFG.SPRITE_SQUID_TAUNT_FH;
        totalFrames = CFG.SPRITE_SQUID_TAUNT_FRAMES; animSpeed = 4;
      } else {
        sheet = SPRITES.bossIdle;
        fw = CFG.SPRITE_BOSS_IDLE_FW; fh = CFG.SPRITE_BOSS_IDLE_FH;
        totalFrames = CFG.SPRITE_BOSS_IDLE_FRAMES; animSpeed = 5;
      }
    }

    const frame = Math.floor(gt * animSpeed) % totalFrames;
    // Draw size: boss hitbox is 40x50, sprite should be bigger for visual impact
    const drawH = 70;
    const drawW = drawH * (fw / fh);

    ctx.save();
    if (boss.defeated) {
      const t = boss.defeatTimer;
      const s = Math.max(0, 1 - t * 0.4);
      ctx.translate(bx, by - drawH / 2);
      ctx.rotate(t * 8);
      ctx.scale(s, s);
    } else {
      ctx.translate(bx, by);
      // Boss charge sprite faces right; flip when boss faces left
      ctx.scale(boss.dir, 1);
    }

    // Shadow
    if (!boss.defeated) {
      ctx.fillStyle = "rgba(0,0,0,0.3)";
      ctx.beginPath();
      ctx.ellipse(0, 0, 22, 5, 0, 0, Math.PI*2);
      ctx.fill();
    }

    if (sheet) {
      ctx.drawImage(sheet,
        srcOffsetX + frame * fw, 0, fw, fh,
        -drawW / 2, -drawH, drawW, drawH
      );
    } else {
      // Fallback procedural gnome (if sprites not loaded)
      ctx.fillStyle = "#886644";
      ctx.beginPath();
      ctx.ellipse(0, -22, 18, 22, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#cc2222";
      ctx.beginPath();
      ctx.moveTo(-16, -34); ctx.lineTo(0, -62); ctx.lineTo(16, -34);
      ctx.closePath(); ctx.fill();
    }

    // Stunned stars overlay
    if (boss.phase === "stunned") {
      for (let i = 0; i < 3; i++) {
        const a = gt * 4 + i * (Math.PI * 2 / 3);
        const sx = Math.cos(a) * 20;
        const sy = -drawH - 6 + Math.sin(a) * 6;
        ctx.fillStyle = "#ffff00";
        ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill();
      }
    }

    // Health bar (below the boss)
    if (!boss.defeated) {
      const barW = 44;
      const barH = 5;
      const barY = 6;
      ctx.fillStyle = "#440000";
      ctx.fillRect(-barW/2, barY, barW, barH);
      ctx.fillStyle = boss.hp === 1 ? "#ff2222" : boss.hp === 2 ? "#ffaa22" : "#22ff22";
      ctx.fillRect(-barW/2, barY, barW * (boss.hp / boss.maxHp), barH);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 0.5;
      ctx.strokeRect(-barW/2, barY, barW, barH);
    }

    ctx.restore();
  }

  roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }
}

// --- HUD ---
class HUD {
  draw(ctx, player, gt, levelDef, levelTimer) {
    ctx.save();

    // Semi-transparent bar at top
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.fillRect(0, 0, CFG.W, 22);

    ctx.font = "bold 10px monospace";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";

    // LEFT SIDE: Lives (up to 3 filled hearts + xN)
    const heartsToShow = Math.min(player.lives, 3);
    for (let i = 0; i < heartsToShow; i++) {
      this.drawMiniHeart(ctx, 6 + i * 14, 5);
    }
    ctx.fillStyle = "#ffffff";
    ctx.fillText("x" + player.lives, 48, 6);

    // Stars count
    ctx.fillStyle = "#ffee44";
    ctx.fillText("\u2605" + player.stars, 75, 6);

    // Flowers count
    ctx.fillStyle = "#ff88cc";
    ctx.fillText("\u2740" + player.flowersRevived + "/" + CFG.FLOWERS_FOR_LIFE, 110, 6);

    // RIGHT SIDE: Power-up indicators (right-aligned, no overlap)
    ctx.textAlign = "right";
    let rx = CFG.W - 6;

    if (player.hasRainbow) {
      ctx.fillStyle = "#ff4488";
      ctx.fillText("\u2606RAINBOW", rx, 6);
      rx -= 62;
    }
    if (player.isMermaid) {
      ctx.fillStyle = "#44ddee";
      ctx.fillText("\u2728MERMAID", rx, 6);
      rx -= 60;
    }
    if (player.isKittycorn) {
      ctx.fillStyle = "#ff88cc";
      ctx.fillText("\u2728KITTY", rx, 6);
      rx -= 42;
    }
    if (player.isPixicorn) {
      ctx.fillStyle = "#cc88ff";
      ctx.fillText("\u2728PIXIE", rx, 6);
      rx -= 42;
    }
    if (player.isMouseicorn) {
      ctx.fillStyle = "#aa8866";
      ctx.fillText("\u2728MOUSE", rx, 6);
      rx -= 48;
    }

    // CENTER: Level name
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.textAlign = "center";
    const lvlName = levelDef ? levelDef.name + "  " + levelDef.title : "";
    ctx.fillText(lvlName, CFG.W / 2, 6);

    // Timer (right of center)
    const timeVal = Math.ceil(levelTimer || 0);
    if (timeVal <= CFG.TIME_WARNING) {
      // Flash red when low
      ctx.fillStyle = Math.floor(gt * 4) % 2 === 0 ? "#ff4444" : "#ff8888";
    } else {
      ctx.fillStyle = "#ffffff";
    }
    ctx.textAlign = "right";
    ctx.fillText(timeVal, CFG.W / 2 + 80, 6);
    ctx.textAlign = "left";

    ctx.restore();
  }
  drawMiniHeart(ctx, x, y) {
    ctx.fillStyle = "#ff4466";
    ctx.beginPath();
    ctx.moveTo(x + 5, y + 3);
    ctx.bezierCurveTo(x + 5, y, x, y, x, y + 3);
    ctx.bezierCurveTo(x, y + 6, x + 5, y + 9, x + 5, y + 9);
    ctx.bezierCurveTo(x + 5, y + 9, x + 10, y + 6, x + 10, y + 3);
    ctx.bezierCurveTo(x + 10, y, x + 5, y, x + 5, y + 3);
    ctx.fill();
  }
}

// ============================================================
//  SECTION 5: GAME LOGIC
// ============================================================

// --- Level ---
class Level {
  constructor(levelDef) {
    this.levelDef = levelDef || LEVEL_DEFS[0];
    this.cols = this.levelDef.cols;
    this.rows = CFG.ROWS;
    this.tiles = new Uint8Array(this.cols * this.rows);
    this.stars = [];
    this.flies = [];
    this.wingCrystals = [];
    this.gnomes = [];
    this.poops = [];
    this.deadFlowers = [];
    this.blackFlowers = [];
    this.hayBales = [];
    this.rainbowBolts = [];
    this.fish = [];
    this.jellyfish = [];
    this.narwhals = [];
    this.mermaidGems = [];
    this.birds = [];
    this.kittycornGems = [];
    this.pixicornGems = [];
    this.mousicornGems = [];
    this.fireballs = [];
    this.formGates = [];
    this.hoop = null;
    this.boss = null;
    this.spawnX = 3 * CFG.TILE;
    this.spawnY = (this.rows - 4) * CFG.TILE;
  }
  get width() { return this.cols * CFG.TILE; }
  get height() { return this.rows * CFG.TILE; }
  getZoneAtCol(col) {
    if (!this.levelDef.zones) return this.levelDef;
    const zones = this.levelDef.zones;
    for (let i = zones.length - 1; i >= 0; i--) {
      if (col >= zones[i].startCol) return zones[i];
    }
    return zones[0];
  }
  getZoneEndCol(zoneIndex) {
    const zones = this.levelDef.zones;
    if (!zones) return this.cols;
    if (zoneIndex < zones.length - 1) return zones[zoneIndex + 1].startCol;
    return this.cols;
  }
  get(c, r) {
    if (c < 0 || c >= this.cols || r < 0 || r >= this.rows) return TILE_EMPTY;
    return this.tiles[r * this.cols + c];
  }
  set(c, r, v) {
    if (c < 0 || c >= this.cols || r < 0 || r >= this.rows) return;
    this.tiles[r * this.cols + c] = v;
  }
  solidAt(px, py) {
    const c = Math.floor(px / CFG.TILE);
    const r = Math.floor(py / CFG.TILE);
    const t = this.get(c, r);
    return t === TILE_GRASS || t === TILE_DIRT;
  }
  generate() {
    const def = this.levelDef;
    const rng = new SeededRNG(def.seed);
    const T = CFG.TILE;
    const groundRow = this.rows - 1;
    const grassRow = this.rows - 2;
    const tw = def.terrain; // terrain weights (fallback for non-zoned levels)
    const hasZones = !!def.zones;

    // Fill bottom two rows as ground
    for (let c = 0; c < this.cols; c++) {
      this.set(c, groundRow, TILE_DIRT);
      this.set(c, grassRow, TILE_GRASS);
    }

    // Helper: does a bgTheme need ceiling?
    const needsCeiling = (theme) => theme === "cave" || theme === "pyramid_interior" || theme === "pyramid_boss";
    const isSewer = (theme) => theme === "sewer" || theme === "sewer_flood" || theme === "sewer_deep" || theme === "sewer_boss";

    // Cave/pyramid/sewer ceiling tiles (zone-aware)
    if (hasZones) {
      for (let c = 5; c < this.cols - 5; c++) {
        const zone = this.getZoneAtCol(c);
        const zt = zone.bgTheme;
        if (needsCeiling(zt)) {
          this.set(c, 0, TILE_DIRT);
          if (rng.next() < 0.65) this.set(c, 1, TILE_DIRT);
          if (rng.next() < 0.12) {
            this.set(c, 2, TILE_DIRT);
            if (rng.next() < 0.4) this.set(c, 3, TILE_DIRT);
          }
        } else if (isSewer(zt)) {
          this.set(c, 0, TILE_DIRT);
          if (rng.next() < 0.55) this.set(c, 1, TILE_DIRT);
          if (rng.next() < 0.08) this.set(c, 2, TILE_DIRT);
        } else {
          // consume the same random calls to keep RNG deterministic
          rng.next(); rng.next(); rng.next();
        }
      }
    } else {
      // Non-zoned: original cave/sewer ceiling logic
      if (def.bgTheme === "cave") {
        for (let c = 5; c < this.cols - 5; c++) {
          this.set(c, 0, TILE_DIRT);
          if (rng.next() < 0.65) this.set(c, 1, TILE_DIRT);
          if (rng.next() < 0.12) {
            this.set(c, 2, TILE_DIRT);
            if (rng.next() < 0.4) this.set(c, 3, TILE_DIRT);
          }
        }
      }
      const isSewerLevel = isSewer(def.bgTheme);
      if (isSewerLevel) {
        for (let c = 5; c < this.cols - 5; c++) {
          this.set(c, 0, TILE_DIRT);
          if (rng.next() < 0.55) this.set(c, 1, TILE_DIRT);
          if (rng.next() < 0.08) this.set(c, 2, TILE_DIRT);
        }
      }
    }

    // Boss arena: reserve last section for boss fight
    const bossArenaStart = def.isBoss ? this.cols - 45 : this.cols;

    // Generate terrain features
    let col = 10;
    const endCol = def.isBoss ? bossArenaStart - 5 : this.cols - 15;
    while (col < endCol) {
      // Zone-aware terrain weights
      const curTw = hasZones ? (this.getZoneAtCol(col).terrain || tw) : tw;
      const curTheme = hasZones ? this.getZoneAtCol(col).bgTheme : def.bgTheme;
      const roll = rng.next();
      if (roll < curTw.pit) {
        // Pit (gap in ground)
        const pitW = rng.nextInt(3, curTheme === "clouds" ? 7 : 5);
        for (let i = 0; i < pitW; i++) {
          this.set(col + i, groundRow, TILE_EMPTY);
          this.set(col + i, grassRow, TILE_EMPTY);
        }
        col += pitW + 2;
      } else if (roll < curTw.platform) {
        // Floating platform
        const platW = rng.nextInt(3, 7);
        const platRow = rng.nextInt(grassRow - 5, grassRow - 3);
        for (let i = 0; i < platW; i++) {
          this.set(col + i, platRow, TILE_GRASS);
        }
        if (rng.next() < 0.6) {
          this.stars.push(new Star(
            (col + Math.floor(platW/2)) * T + T/2 - 7,
            (platRow - 2) * T
          ));
        }
        col += platW + 2;
      } else if (roll < curTw.stairs) {
        // Stairs
        const steps = curTheme === "forest" ? 4 : 3;
        for (let s = 0; s < steps; s++) {
          const sw = rng.nextInt(2, 3);
          const sr = grassRow - 2 - s * 2;
          for (let i = 0; i < sw; i++) {
            this.set(col + s * 3 + i, sr, TILE_GRASS);
          }
        }
        col += steps * 3 + 2;
      } else if (roll < curTw.twotier) {
        // Two-tiered platform
        const lowW = rng.nextInt(3, 6);
        const lowRow = grassRow - 3;
        for (let i = 0; i < lowW; i++) {
          this.set(col + i, lowRow, TILE_GRASS);
        }
        const hiW = rng.nextInt(2, 4);
        const hiRow = lowRow - 3;
        for (let i = 0; i < hiW; i++) {
          this.set(col + 1 + i, hiRow, TILE_GRASS);
        }
        if (rng.next() < 0.5) {
          this.stars.push(new Star(
            (col + 1 + Math.floor(hiW/2)) * T + T/2 - 7,
            (hiRow - 2) * T
          ));
        }
        col += lowW + 3;
      } else {
        // Flat stretch with possible raised section
        const stretchW = rng.nextInt(5, 10);
        if (rng.next() < 0.4) {
          const raiseRow = grassRow - 1;
          for (let i = 0; i < stretchW; i++) {
            this.set(col + i, raiseRow, TILE_GRASS);
            this.set(col + i, grassRow, TILE_DIRT);
          }
        }
        col += stretchW + 1;
      }

      // Spawn fly enemies near platforms (not underwater — fish/narwhals handle that)
      const colIsUnderwater = hasZones ? !!this.getZoneAtCol(col).isUnderwater : def.isUnderwater;
      if (!colIsUnderwater && rng.next() < 0.35) {
        const flyX = (col - 3) * T;
        const flyRow = rng.nextInt(grassRow - 6, grassRow - 3);
        const flyY = flyRow * T;
        const patrol = rng.nextInt(40, 100);
        this.flies.push(new Fly(flyX, flyY, patrol));
      }

      col += rng.nextInt(1, 3);
    }

    // Zone wall entries — build a tall barrier the player climbs then jumps off into water
    if (hasZones) {
      for (let zi = 1; zi < def.zones.length; zi++) {
        const zone = def.zones[zi];
        if (!zone.wallEntry) continue;
        const wallW = 2;                     // 2 cols thick
        const wallH = 9;                     // 9 rows tall
        const wallCol = zone.startCol - wallW; // wall sits in the land zone, right before water

        // Build the wall — solid dirt with grass cap
        for (let c = wallCol; c < wallCol + wallW; c++) {
          for (let r = grassRow - wallH; r <= grassRow; r++) {
            this.set(c, r, TILE_DIRT);
          }
          this.set(c, grassRow - wallH, TILE_GRASS); // grass cap on top
        }

        // Stair-step platforms on the forest side (left) so player can climb up
        const steps = [
          { col: wallCol - 9, row: grassRow - 2, w: 3 },  // low step
          { col: wallCol - 7, row: grassRow - 4, w: 3 },  // mid-low step
          { col: wallCol - 5, row: grassRow - 6, w: 3 },  // mid-high step
          { col: wallCol - 3, row: grassRow - 8, w: 3 },  // high step (near wall top)
        ];
        for (const s of steps) {
          for (let i = 0; i < s.w; i++) {
            this.set(s.col + i, s.row, TILE_GRASS);
          }
        }

        // Clear ground on the water side so player drops straight into water
        for (let c = zone.startCol; c < zone.startCol + 6; c++) {
          this.set(c, grassRow, TILE_EMPTY);
          this.set(c, groundRow, TILE_EMPTY);
        }
      }
    }

    // === Boss arena (x-4 levels) ===
    if (def.isBoss) {
      // Flat platform for boss arena
      for (let c = bossArenaStart; c < this.cols; c++) {
        this.set(c, grassRow, TILE_GRASS);
        this.set(c, groundRow, TILE_DIRT);
        // Clear any ceiling for arena
        for (let r = 0; r < grassRow; r++) this.set(c, r, TILE_EMPTY);
      }
      // Walls at arena edges
      for (let r = grassRow - 6; r < grassRow; r++) {
        this.set(bossArenaStart, r, TILE_DIRT);
        this.set(this.cols - 1, r, TILE_DIRT);
      }
      this.set(bossArenaStart, grassRow - 6, TILE_GRASS);
      this.set(this.cols - 1, grassRow - 6, TILE_GRASS);
      // Small platform in arena for player to jump to
      const midArena = bossArenaStart + 20;
      for (let i = 0; i < 4; i++) {
        this.set(midArena + i, grassRow - 4, TILE_GRASS);
      }
      // Kittycorn alcoves for pharaoh cat boss (2-tile-high gaps only kittycorn fits)
      if (def.world === 6 && def.isBoss) {
        // Left alcove
        const alcove1 = bossArenaStart + 6;
        for (let i = 0; i < 3; i++) this.set(alcove1 + i, grassRow - 2, TILE_GRASS);
        this.set(alcove1, grassRow - 1, TILE_DIRT);
        this.set(alcove1 + 2, grassRow - 1, TILE_DIRT);
        // Right alcove
        const alcove2 = this.cols - 8;
        for (let i = 0; i < 3; i++) this.set(alcove2 + i, grassRow - 2, TILE_GRASS);
        this.set(alcove2, grassRow - 1, TILE_DIRT);
        this.set(alcove2 + 2, grassRow - 1, TILE_DIRT);
      }
      // Spawn boss
      const bossX = (bossArenaStart + 30) * T;
      const bossY = (grassRow - 4) * T;
      this.boss = new Boss(bossX, bossY);
      this.boss.bossType = def.world === 8 ? "shadow_queen" : (def.world === 7 ? "storm_dragon" : (def.world === 6 ? "pharaoh_cat" : (def.world === 5 ? "rat" : (def.isUnderwater ? "squid" : (def.world === 3 ? "hawk" : (def.world === 4 ? "flower" : "gnome"))))));
      this.boss.setArena((bossArenaStart + 2) * T, (this.cols - 2) * T);
    }

    // Ensure minimum star count
    while (this.stars.length < def.starCount) {
      const sc = rng.nextInt(15, endCol - 5);
      const sr = grassRow - 2;
      if (this.get(sc, grassRow) !== TILE_EMPTY) {
        this.stars.push(new Star(sc * T + T/2 - 7, sr * T));
      }
    }

    // Ensure minimum fly count
    while (this.flies.length < def.flyCount) {
      const fc = rng.nextInt(20, endCol - 10);
      const fr = rng.nextInt(grassRow - 6, grassRow - 2);
      const patrol = rng.nextInt(40, 80);
      this.flies.push(new Fly(fc * CFG.TILE, fr * CFG.TILE, patrol));
    }

    // Place wing crystals
    if (def.wingCrystals > 0) {
      const third = Math.floor(endCol / 3);
      for (let w = 0; w < def.wingCrystals; w++) {
        const minC = 20 + w * third;
        const maxC = minC + third - 10;
        const wc = rng.nextInt(minC, maxC);
        let placeRow = grassRow - 2;
        for (let r = grassRow - 6; r < grassRow - 1; r++) {
          if (this.get(wc, r) === TILE_GRASS) { placeRow = r - 2; break; }
        }
        if (this.get(wc, grassRow) !== TILE_EMPTY) {
          this.wingCrystals.push(new WingCrystal(wc * T + T/2 - 8, placeRow * T));
        }
      }
    }

    // Place gnomes (on actual ground surface — handles raised terrain sections)
    const gnomeSpacing = Math.max(15, Math.floor(endCol / (def.gnomeCount + 1)));
    for (let i = 0; i < def.gnomeCount; i++) {
      const gc = rng.nextInt(gnomeSpacing * (i + 1) - 10, gnomeSpacing * (i + 1) + 10);
      if (gc > 5 && gc < endCol) {
        const patrol = rng.nextInt(30, 60);
        const patrolCols = Math.ceil(patrol / T);
        // Find actual surface row at spawn column (scan upward from base grass)
        let surfaceRow = -1;
        for (let r = grassRow; r >= grassRow - 2; r--) {
          if (this.get(gc, r) === TILE_GRASS) { surfaceRow = r; break; }
        }
        if (surfaceRow < 0) continue;
        // Verify ground exists under entire patrol range at this surface height
        let hasGround = true;
        for (let cc = gc; cc <= Math.min(gc + patrolCols, this.cols - 1); cc++) {
          if (this.get(cc, surfaceRow) === TILE_EMPTY && this.get(cc, surfaceRow + 1) === TILE_EMPTY) {
            hasGround = false; break;
          }
        }
        if (hasGround) {
          const gy = surfaceRow * T - 28;  // gnome h=28, feet at top of surface tile
          this.gnomes.push(new Gnome(gc * T, gy, patrol));
        }
      }
    }

    // Helper: find surface row at a column with clearance above
    const findFlowerSpot = (col) => {
      for (let r = 0; r < this.rows; r++) {
        const tile = this.get(col, r);
        if (tile === TILE_GRASS || tile === TILE_DIRT) {
          let clearAbove = true;
          for (let cr = Math.max(0, r - 3); cr < r; cr++) {
            if (this.get(col, cr) === TILE_GRASS || this.get(col, cr) === TILE_DIRT) {
              clearAbove = false; break;
            }
          }
          if (clearAbove) return r;
        }
      }
      return -1;
    };

    // Place dead flowers
    const dfSpacing = Math.max(10, Math.floor(endCol / (def.deadFlowers + 1)));
    for (let i = 0; i < def.deadFlowers; i++) {
      const fc = rng.nextInt(dfSpacing * (i + 1) - 8, dfSpacing * (i + 1) + 8);
      if (fc > 5 && fc < endCol) {
        const surfaceRow = findFlowerSpot(fc);
        if (surfaceRow >= 0) {
          this.deadFlowers.push(new DeadFlower(fc * T + T/2 - 7, surfaceRow * T - 16));
        }
      }
    }

    // Place black flowers
    const bfSpacing = Math.max(15, Math.floor(endCol / (def.blackFlowers + 1)));
    for (let i = 0; i < def.blackFlowers; i++) {
      const fc = rng.nextInt(bfSpacing * (i + 1) - 10, bfSpacing * (i + 1) + 10);
      if (fc > 5 && fc < endCol) {
        const surfaceRow = findFlowerSpot(fc);
        if (surfaceRow >= 0) {
          this.blackFlowers.push(new BlackFlower(fc * T + T/2 - 7, surfaceRow * T - 16));
        }
      }
    }

    // Place fish (underwater levels + lakeside)
    const fishCount = def.fishCount || 0;
    if (fishCount > 0) {
      const fishSpacing = Math.max(12, Math.floor(endCol / (fishCount + 1)));
      for (let i = 0; i < fishCount; i++) {
        const fc = rng.nextInt(fishSpacing * (i + 1) - 8, fishSpacing * (i + 1) + 8);
        if (fc > 8 && fc < endCol) {
          const fr = rng.nextInt(grassRow - 7, grassRow - 2);
          const patrol = rng.nextInt(40, 100);
          this.fish.push(new Fish(fc * T, fr * T, patrol));
        }
      }
    }

    // Place jellyfish (deeper underwater levels)
    const jellyCount = def.jellyCount || 0;
    if (jellyCount > 0) {
      const jellySpacing = Math.max(15, Math.floor(endCol / (jellyCount + 1)));
      for (let i = 0; i < jellyCount; i++) {
        const jc = rng.nextInt(jellySpacing * (i + 1) - 10, jellySpacing * (i + 1) + 10);
        if (jc > 8 && jc < endCol) {
          const jr = rng.nextInt(grassRow - 8, grassRow - 3);
          this.jellyfish.push(new Jellyfish(jc * T, jr * T));
        }
      }
    }

    // Place narwhals (underwater levels)
    const narwhalCount = def.narwhalCount || 0;
    if (narwhalCount > 0) {
      const nwSpacing = Math.max(15, Math.floor(endCol / (narwhalCount + 1)));
      for (let i = 0; i < narwhalCount; i++) {
        const nc = rng.nextInt(nwSpacing * (i + 1) - 8, nwSpacing * (i + 1) + 8);
        if (nc > 8 && nc < endCol) {
          const nr = rng.nextInt(grassRow - 6, grassRow - 2);
          const patrol = rng.nextInt(50, 120);
          this.narwhals.push(new Narwhal(nc * T, nr * T, patrol));
        }
      }
    }

    // Place mermaid gems
    const mermaidCount = def.mermaidGems || 0;
    if (mermaidCount > 0) {
      const mermSpacing = Math.floor(endCol / (mermaidCount + 1));
      for (let i = 0; i < mermaidCount; i++) {
        const mc = rng.nextInt(mermSpacing * (i + 1) - 8, mermSpacing * (i + 1) + 8);
        if (mc > 10 && mc < endCol) {
          let placeRow = grassRow - 2;
          for (let r = grassRow - 6; r < grassRow - 1; r++) {
            if (this.get(mc, r) === TILE_GRASS) { placeRow = r - 2; break; }
          }
          if (this.get(mc, grassRow) !== TILE_EMPTY) {
            this.mermaidGems.push(new MermaidGem(mc * T + T/2 - 8, placeRow * T));
          }
        }
      }
    }

    // Place birds (treetop levels)
    const birdCount = def.birdCount || 0;
    if (birdCount > 0) {
      const birdSpacing = Math.max(15, Math.floor(endCol / (birdCount + 1)));
      for (let i = 0; i < birdCount; i++) {
        const bc = rng.nextInt(birdSpacing * (i + 1) - 8, birdSpacing * (i + 1) + 8);
        if (bc > 8 && bc < endCol) {
          const br = rng.nextInt(grassRow - 7, grassRow - 3);
          const patrol = rng.nextInt(60, 140);
          this.birds.push(new Bird(bc * T, br * T, patrol));
        }
      }
    }

    // Place kittycorn gems
    const kittycornCount = def.kittycornGems || 0;
    if (kittycornCount > 0) {
      const kittySpacing = Math.floor(endCol / (kittycornCount + 1));
      for (let i = 0; i < kittycornCount; i++) {
        const kc = rng.nextInt(kittySpacing * (i + 1) - 8, kittySpacing * (i + 1) + 8);
        if (kc > 10 && kc < endCol) {
          let placeRow = grassRow - 2;
          for (let r = grassRow - 6; r < grassRow - 1; r++) {
            if (this.get(kc, r) === TILE_GRASS) { placeRow = r - 2; break; }
          }
          if (this.get(kc, grassRow) !== TILE_EMPTY) {
            this.kittycornGems.push(new KittycornGem(kc * T + T/2 - 8, placeRow * T));
          }
        }
      }
    }

    // Place pixicorn gems
    const pixicornCount = def.pixicornGems || 0;
    if (pixicornCount > 0) {
      const pixieSpacing = Math.floor(endCol / (pixicornCount + 1));
      for (let i = 0; i < pixicornCount; i++) {
        const pc = rng.nextInt(pixieSpacing * (i + 1) - 8, pixieSpacing * (i + 1) + 8);
        if (pc > 10 && pc < endCol) {
          let placeRow = grassRow - 2;
          for (let r = grassRow - 6; r < grassRow - 1; r++) {
            if (this.get(pc, r) === TILE_GRASS) { placeRow = r - 2; break; }
          }
          if (this.get(pc, grassRow) !== TILE_EMPTY) {
            this.pixicornGems.push(new PixicornGem(pc * T + T/2 - 8, placeRow * T));
          }
        }
      }
    }

    // Place mousicorn gems (before any mousicorn gate so player gets gem first)
    const mousicornCount = def.mousicornGems || 0;
    if (mousicornCount > 0) {
      // If there's a mousicorn formGate, place gems before it
      let mouseEndCol = endCol;
      if (hasZones) {
        for (const z of def.zones) {
          if (z.formGate && z.formGate.form === "mousicorn") {
            mouseEndCol = Math.min(mouseEndCol, z.formGate.col - 5);
          }
        }
      }
      const mouseSpacing = Math.floor(mouseEndCol / (mousicornCount + 1));
      for (let i = 0; i < mousicornCount; i++) {
        const mc = rng.nextInt(mouseSpacing * (i + 1) - 8, mouseSpacing * (i + 1) + 8);
        if (mc > 10 && mc < mouseEndCol) {
          let placeRow = grassRow - 2;
          for (let r = grassRow - 6; r < grassRow - 1; r++) {
            if (this.get(mc, r) === TILE_GRASS) { placeRow = r - 2; break; }
          }
          if (this.get(mc, grassRow) !== TILE_EMPTY) {
            this.mousicornGems.push(new MousicornGem(mc * T + T/2 - 8, placeRow * T));
          }
        }
      }
    }

    // Zone-specific enemy placement (for zoned levels)
    if (hasZones) {
      for (let zi = 0; zi < def.zones.length; zi++) {
        const zone = def.zones[zi];
        const zoneStart = Math.max(10, zone.startCol);
        const zoneEnd = this.getZoneEndCol(zi);
        const zEndCol = Math.min(zoneEnd, endCol);

        // Gnomes in this zone
        const zGnomes = zone.gnomeCount || 0;
        if (zGnomes > 0) {
          const spacing = Math.max(10, Math.floor((zEndCol - zoneStart) / (zGnomes + 1)));
          for (let i = 0; i < zGnomes; i++) {
            const gc = rng.nextInt(zoneStart + spacing * (i + 1) - 5, zoneStart + spacing * (i + 1) + 5);
            if (gc > 5 && gc < zEndCol) {
              const patrol = rng.nextInt(30, 60);
              let surfaceRow = -1;
              for (let r = grassRow; r >= grassRow - 2; r--) {
                if (this.get(gc, r) === TILE_GRASS) { surfaceRow = r; break; }
              }
              if (surfaceRow >= 0 && this.get(gc, grassRow) !== TILE_EMPTY) {
                this.gnomes.push(new Gnome(gc * T, surfaceRow * T - 28, patrol));
              }
            }
          }
        }

        // Fish in this zone
        const zFish = zone.fishCount || 0;
        if (zFish > 0) {
          const spacing = Math.max(10, Math.floor((zEndCol - zoneStart) / (zFish + 1)));
          for (let i = 0; i < zFish; i++) {
            const fc = rng.nextInt(zoneStart + spacing * (i + 1) - 5, zoneStart + spacing * (i + 1) + 5);
            if (fc > 5 && fc < zEndCol) {
              const fr = rng.nextInt(grassRow - 7, grassRow - 2);
              const patrol = rng.nextInt(40, 100);
              this.fish.push(new Fish(fc * T, fr * T, patrol));
            }
          }
        }

        // Jellyfish in this zone
        const zJelly = zone.jellyCount || 0;
        if (zJelly > 0) {
          const spacing = Math.max(12, Math.floor((zEndCol - zoneStart) / (zJelly + 1)));
          for (let i = 0; i < zJelly; i++) {
            const jc = rng.nextInt(zoneStart + spacing * (i + 1) - 5, zoneStart + spacing * (i + 1) + 5);
            if (jc > 5 && jc < zEndCol) {
              const jr = rng.nextInt(grassRow - 8, grassRow - 3);
              this.jellyfish.push(new Jellyfish(jc * T, jr * T));
            }
          }
        }

        // Narwhals in this zone
        const zNarwhals = zone.narwhalCount || 0;
        if (zNarwhals > 0) {
          const spacing = Math.max(12, Math.floor((zEndCol - zoneStart) / (zNarwhals + 1)));
          for (let i = 0; i < zNarwhals; i++) {
            const nc = rng.nextInt(zoneStart + spacing * (i + 1) - 5, zoneStart + spacing * (i + 1) + 5);
            if (nc > 5 && nc < zEndCol) {
              const nr = rng.nextInt(grassRow - 6, grassRow - 2);
              const patrol = rng.nextInt(50, 120);
              this.narwhals.push(new Narwhal(nc * T, nr * T, patrol));
            }
          }
        }

        // Birds in this zone
        const zBirds = zone.birdCount || 0;
        if (zBirds > 0) {
          const spacing = Math.max(12, Math.floor((zEndCol - zoneStart) / (zBirds + 1)));
          for (let i = 0; i < zBirds; i++) {
            const bc = rng.nextInt(zoneStart + spacing * (i + 1) - 5, zoneStart + spacing * (i + 1) + 5);
            if (bc > 5 && bc < zEndCol) {
              const br = rng.nextInt(grassRow - 7, grassRow - 3);
              const patrol = rng.nextInt(60, 140);
              this.birds.push(new Bird(bc * T, br * T, patrol));
            }
          }
        }
      }
    }

    // Place form gates (zone-defined barriers)
    if (hasZones) {
      for (const zone of def.zones) {
        if (zone.formGate) {
          const fg = zone.formGate;
          const gateCol = fg.col;
          const gateH = fg.height || 80;
          const gateRows = Math.ceil(gateH / T);
          // Build a wall for the gate (fill from top down through ground rows)
          for (let r = grassRow - gateRows; r <= groundRow; r++) {
            this.set(gateCol, r, TILE_DIRT);
            this.set(gateCol + 1, r, TILE_DIRT);
          }
          this.set(gateCol, grassRow - gateRows, TILE_GRASS);
          this.set(gateCol + 1, grassRow - gateRows, TILE_GRASS);
          // Create gate entity (covers full height including ground)
          const gateX = gateCol * T;
          const gateY = (grassRow - gateRows) * T;
          const gateFullH = (groundRow - (grassRow - gateRows) + 1) * T;
          this.formGates.push(new FormGate(gateX, gateY, fg.form, gateFullH));
        }
      }
    }

    // Place hoop (non-boss levels only)
    if (!def.isBoss) {
      const hoopCol = this.cols - 8;
      this.hoop = new Hoop(hoopCol * T + T/2 - 10, (grassRow - 4) * T);
    }

    // Ensure ground under spawn and end
    for (let c = 0; c < 10; c++) {
      this.set(c, grassRow, TILE_GRASS);
      this.set(c, groundRow, TILE_DIRT);
    }
    if (!def.isBoss) {
      for (let c = this.cols - 12; c < this.cols; c++) {
        this.set(c, grassRow, TILE_GRASS);
        this.set(c, groundRow, TILE_DIRT);
      }
    }
  }
}

// --- Game State Machine ---
class GameStateMachine {
  constructor(game) {
    this.game = game;
    this.state = STATE_TITLE;
    this.stateTimer = 0;
    this.titlePhase = 0;
    this.deathTimer = 0;
  }
  setState(s) {
    const prev = this.state;
    this.state = s;
    this.stateTimer = 0;
    this.onStateEnter(s, prev);
  }
  onStateEnter(state, prev) {
    const g = this.game;
    const audio = g.audio;
    switch (state) {
      case STATE_TITLE:
        audio.stopMusic(0.8);
        audio.playMusic("title_screen", true);
        break;
      case STATE_LEVEL_INTRO: {
        const def = LEVEL_DEFS[g.currentLevelIndex];
        const track = audio.getMusicForLevel(def);
        audio.playMusic(track, true);
        break;
      }
      case STATE_PLAYING:
        // Restart level music when respawning from death
        if (prev === STATE_DYING) {
          const def = LEVEL_DEFS[g.currentLevelIndex];
          const track = audio.getMusicForLevel(def);
          audio.playMusic(track, true);
        }
        break;
      case STATE_DYING:
        audio.stopMusic(0.3);
        if (g.player._deathType === "fall") {
          audio.fallDeathSound();
        } else {
          audio.deathSound();
        }
        break;
      case STATE_COMPLETE: {
        audio.stopMusic(0.5);
        const nextIdx = g.currentLevelIndex + 1;
        const isGameComplete = nextIdx >= LEVEL_DEFS.length;
        setTimeout(() => {
          audio.levelCompleteSound();
          if (isGameComplete) {
            setTimeout(() => audio.playMusic("game_complete", false), 1500);
          }
        }, 500);
        break;
      }
    }
  }
  update(dt) {
    this.stateTimer += dt;
    this.titlePhase += dt;

    switch (this.state) {
      case STATE_TITLE:
        this.updateTitle(dt);
        break;
      case STATE_LEVEL_INTRO:
        this.updateLevelIntro(dt);
        break;
      case STATE_PLAYING:
        this.updatePlaying(dt);
        break;
      case STATE_PAUSED:
        this.updatePaused(dt);
        break;
      case STATE_DYING:
        this.updateDying(dt);
        break;
      case STATE_COMPLETE:
        this.updateComplete(dt);
        break;
      case STATE_CODE_ENTRY:
        this.updateCodeEntry(dt);
        break;
    }
  }
  updateTitle(dt) {
    // Only Start/Enter starts the game (not A/Space — that's needed for konami code)
    if (this.game.input.pressed("Enter") && this.stateTimer > 0.5) {
      this.game.audio.menuSelect();
      this.game.startLevel(true);
      this.setState(STATE_LEVEL_INTRO);
    }
    // Press C or Select to enter code
    if (this.game.input.pressed("KeyC") && this.stateTimer > 0.5) {
      this.game.audio.menuSelect();
      this.codeInput = "";
      this.codeMessage = "";
      this.codeMessageTimer = 0;
      this.codeLetterIdx = 0;       // D-pad letter selector (0=A, 25=Z)
      this.codeRepeatTimer = 0;     // auto-repeat timer for held D-pad
      this.codeRepeatDir = 0;       // -1=down, +1=up, 0=none
      this.game.input.consumeLetter(); // eat the "C" so it doesn't auto-fill
      this.setState(STATE_CODE_ENTRY);
    }
  }
  updateCodeEntry(dt) {
    const input = this.game.input;
    if (this.codeMessageTimer > 0) {
      this.codeMessageTimer -= dt;
      if (this.codeMessageTimer <= 0) {
        if (this.codeSuccess) {
          // Code was valid — start that world
          this.game.startLevel(true); // resets everything
          this.game.currentLevelIndex = this.codeTargetIndex;
          const def = LEVEL_DEFS[this.codeTargetIndex];
          this.game.level = new Level(def);
          this.game.level.generate();
          this.game.parallax = new ParallaxBackground(def);
          this.game.camera.setBounds(this.game.level.width, this.game.level.height);
          this.game.player.reset(this.game.level.spawnX, this.game.level.spawnY);
          this.game.player.isUnderwater = !!def.isUnderwater;
          this.setState(STATE_LEVEL_INTRO);
        } else {
          this.codeMessage = "";
        }
      }
      return;
    }

    // --- Keyboard input (type letters directly) ---
    const letter = input.consumeLetter();
    if (letter === "ESCAPE") {
      this.setState(STATE_TITLE);
      return;
    }
    if (letter === "BACKSPACE") {
      this.codeInput = this.codeInput.slice(0, -1);
      return;
    }
    if (letter && letter.length === 1 && this.codeInput.length < 4) {
      this.codeInput += letter;
      this.codeLetterIdx = letter.charCodeAt(0) - 65; // sync selector
      this.game.audio.menuSelect();
    }

    // --- Gamepad D-pad input (cycle through letters) ---
    if (this.codeInput.length < 4) {
      const upP = input.pressed("ArrowUp");
      const downP = input.pressed("ArrowDown");
      const upH = input.held("ArrowUp");
      const downH = input.held("ArrowDown");

      if (upP) {
        this.codeLetterIdx = (this.codeLetterIdx + 1) % 26;
        this.codeRepeatTimer = 0.35;
        this.codeRepeatDir = 1;
        this.game.audio.menuSelect();
      } else if (downP) {
        this.codeLetterIdx = (this.codeLetterIdx + 25) % 26;
        this.codeRepeatTimer = 0.35;
        this.codeRepeatDir = -1;
        this.game.audio.menuSelect();
      }

      // Auto-repeat when D-pad held
      if ((this.codeRepeatDir === 1 && upH) || (this.codeRepeatDir === -1 && downH)) {
        this.codeRepeatTimer -= dt;
        if (this.codeRepeatTimer <= 0) {
          this.codeLetterIdx = (this.codeLetterIdx + (this.codeRepeatDir === 1 ? 1 : 25)) % 26;
          this.codeRepeatTimer = 0.1;
          this.game.audio.menuSelect();
        }
      } else if (!upP && !downP) {
        this.codeRepeatDir = 0;
      }
    }

    // Gamepad A button or D-pad Right → confirm current letter
    if ((input.pressed("_gpA") || input.pressed("ArrowRight")) && this.codeInput.length < 4) {
      this.codeInput += String.fromCharCode(65 + this.codeLetterIdx);
      this.game.audio.menuSelect();
    }

    // Gamepad B button or D-pad Left → delete last letter
    if ((input.pressed("_gpB") || input.pressed("ArrowLeft")) && this.codeInput.length > 0 && !input.pressed("ArrowUp") && !input.pressed("ArrowDown")) {
      this.codeInput = this.codeInput.slice(0, -1);
      // Sync letter selector to previous letter
      if (this.codeInput.length > 0) {
        this.codeLetterIdx = this.codeInput.charCodeAt(this.codeInput.length - 1) - 65;
      } else {
        this.codeLetterIdx = 0;
      }
    }

    // Gamepad Select → back to title
    if (input.pressed("KeyC")) {
      this.setState(STATE_TITLE);
      return;
    }

    // Start/Enter → submit code
    if (input.pressed("Enter") && this.codeInput.length > 0) {
      const info = WORLD_CODES[this.codeInput];
      if (info) {
        this.codeMessage = "CODE ACCEPTED! " + info.label;
        this.codeSuccess = true;
        this.codeTargetIndex = info.levelIndex;
        this.codeMessageTimer = 1.5;
        this.game.audio.collectSound();
      } else {
        this.codeMessage = "INVALID CODE";
        this.codeSuccess = false;
        this.codeMessageTimer = 1.5;
        this.game.audio.hurtSound();
        this.codeInput = "";
      }
    }
  }
  updateLevelIntro(dt) {
    // Show level name for 2 seconds, then start playing
    if (this.stateTimer > 2.0 || (this.game.input.enter && this.stateTimer > 0.5)) {
      this.setState(STATE_PLAYING);
    }
  }
  updatePaused(dt) {
    // Unpause on Start/Enter
    if (this.game.input.pressed("Enter") && this.stateTimer > 0.3) {
      this.game.audio.menuSelect();
      this.setState(STATE_PLAYING);
    }
  }
  updatePlaying(dt) {
    const g = this.game;

    // Pause on Start/Enter
    if (g.input.pressed("Enter")) {
      g.audio.menuSelect();
      this.setState(STATE_PAUSED);
      return;
    }

    g.gameTime += dt;

    // Level timer countdown
    if (g.levelTimer > 0 && g.player.alive) {
      g.levelTimer -= dt * CFG.TIME_TICK_SPEED;
      if (g.levelTimer <= 0) {
        g.levelTimer = 0;
        g.player.lives--;
        g.player._deathType = "contact";
        g.player.die();
        g.particles.floatingText(g.player.cx, g.player.cy - 20, "TIME UP!", "#ff4444");
      }
    }

    // Zone-aware dynamic isUnderwater
    if (g.level.levelDef.zones) {
      const playerCol = Math.floor(g.player.cx / CFG.TILE);
      const zone = g.level.getZoneAtCol(playerCol);
      const wasUnderwater = g.player.isUnderwater;
      g.player.isUnderwater = !!zone.isUnderwater;
      // Auto-clear incompatible transforms on zone transition
      if (wasUnderwater !== g.player.isUnderwater) {
        if (!g.player.isUnderwater && g.player.isMermaid) g.player.isMermaid = false;
        if (g.player.isUnderwater) {
          g.player.isMouseicorn = false;
          g.player.isKittycorn = false;
          g.player.isPixicorn = false;
        }
      }
    }

    // Update player
    g.player.update(dt, g.level, g.input, g.audio, g.particles, g.camera);

    // Update entities
    for (const star of g.level.stars) {
      if (star.alive) star.update(dt, g.gameTime);
    }
    for (const fly of g.level.flies) {
      if (fly.alive) fly.update(dt, g.gameTime);
    }
    for (const gnome of g.level.gnomes) {
      if (gnome.alive) gnome.update(dt, g.gameTime);
    }
    if (g.level.hoop) g.level.hoop.update(dt, g.gameTime);
    for (const wc of g.level.wingCrystals) {
      if (wc.alive && !wc.collected) wc.update(dt, g.gameTime);
    }
    for (const df of g.level.deadFlowers) {
      if (df.alive) df.update(dt, g.gameTime);
    }
    for (const bf of g.level.blackFlowers) {
      if (bf.alive && !bf.used) bf.update(dt, g.gameTime);
    }
    for (const hb of g.level.hayBales) {
      if (hb.alive) hb.update(dt, g.level);
    }
    for (const gate of g.level.formGates) {
      gate.update(dt);
    }
    for (const f of g.level.fish) {
      if (f.alive) f.update(dt, g.gameTime);
    }
    for (const j of g.level.jellyfish) {
      if (j.alive) j.update(dt, g.gameTime);
    }
    for (const nw of g.level.narwhals) {
      if (nw.alive) nw.update(dt, g.gameTime);
    }
    for (const bird of g.level.birds) {
      if (bird.alive) bird.update(dt, g.gameTime);
    }
    for (const mg of g.level.mermaidGems) {
      if (mg.alive && !mg.collected) mg.update(dt, g.gameTime);
    }
    for (const kg of g.level.kittycornGems) {
      if (kg.alive && !kg.collected) kg.update(dt, g.gameTime);
    }
    for (const pg of g.level.pixicornGems) {
      if (pg.alive && !pg.collected) pg.update(dt, g.gameTime);
    }
    for (const mg of g.level.mousicornGems) {
      if (mg.alive && !mg.collected) mg.update(dt, g.gameTime);
    }
    // Update fireballs
    for (let i = g.level.fireballs.length - 1; i >= 0; i--) {
      const fb = g.level.fireballs[i];
      if (fb.alive) {
        fb.update(dt);
      } else {
        g.level.fireballs.splice(i, 1);
      }
    }

    // Update boss
    if (g.level.boss && g.level.boss.alive) {
      g.level.boss.update(dt, g.level, g.player.cx, g.player.cy);
      // Boss defeated check
      if (g.level.boss.defeated && g.level.boss.defeatTimer > 2.0) {
        g.audio.hoopSound();
        g.particles.sparkleBurst(g.level.boss.cx, g.level.boss.cy, 30);
        g.player.animState = "hoopClear";
        g.player.animFrame = 0;
        g.player.animTimer = 0;
        g.player.speedX = 0;
        g.player.vx = 0;
        g.level.boss.alive = false;
        this.setState(STATE_COMPLETE);
      }
      // Boss fireball spawning (flower/pharaoh_cat/storm_dragon/shadow_queen)
      if (g.level.boss.wantsToShoot) {
        g.level.boss.wantsToShoot = false;
        const bx = g.level.boss.cx;
        const by = g.level.boss.cy;
        const px = g.player.cx;
        const py = g.player.cy;
        const dx = px - bx;
        const dy = py - by;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        if (g.level.boss.bossType === "storm_dragon") {
          // Dragon breath: 5 fireballs in a wide cone downward
          for (let s = -2; s <= 2; s++) {
            const angle = Math.atan2(dy, dx) + s * 0.2;
            const fbvx = Math.cos(angle) * 2.8;
            const fbvy = Math.sin(angle) * 2.8;
            g.level.fireballs.push(new Fireball(bx + g.level.boss.dir * 16, by + 10, fbvx, fbvy));
          }
          g.audio.playSFX("sawtooth", 120, 0.25, 60, 0.2);
        } else if (g.level.boss.bossType === "shadow_queen") {
          // Nova burst: 8 fireballs in a radial pattern
          for (let s = 0; s < 8; s++) {
            const angle = (s / 8) * Math.PI * 2 + g.level.boss.queenGlow;
            const fbvx = Math.cos(angle) * 2.2;
            const fbvy = Math.sin(angle) * 2.2;
            g.level.fireballs.push(new Fireball(bx, by, fbvx, fbvy));
          }
          g.audio.playSFX("sawtooth", 100, 0.2, 50, 0.25);
        } else if (g.level.boss.bossType === "pharaoh_cat") {
          // Pharaoh cat: horizontal sound-wave arcs
          for (let s = -1; s <= 1; s++) {
            const angle = Math.atan2(dy, dx) + s * 0.35;
            const fbvx = Math.cos(angle) * 2.5;
            const fbvy = Math.sin(angle) * 1.5;
            g.level.fireballs.push(new Fireball(bx + g.level.boss.dir * 20, by - 10, fbvx, fbvy));
          }
          g.audio.playSFX("sawtooth", 200, 0.15, 100, 0.15);
        } else {
          // 3 fireballs in a spread pattern (flower boss)
          for (let s = -1; s <= 1; s++) {
            const spreadAngle = Math.atan2(dy, dx) + s * 0.25;
            const fbvx = Math.cos(spreadAngle) * CFG.FLOWER_FIREBALL_SPEED;
            const fbvy = Math.sin(spreadAngle) * CFG.FLOWER_FIREBALL_SPEED;
            g.level.fireballs.push(new Fireball(bx, by, fbvx, fbvy));
          }
          g.audio.playSFX("sawtooth", 150, 0.2, 80, 0.2);
        }
      }
    }

    // Spawn standing poop pile behind unicorn
    if (g.player._spawnStandPoop) {
      g.player._spawnStandPoop = false;
      const spawnX = g.player.cx - g.player.facing * 20;
      const spawnY = g.player.bottom - 20;
      const poop = new Poop(spawnX, spawnY, 0, 0);
      poop.fadeTime = 8.0;
      g.level.poops.push(poop);
      g.audio.formPoopSound(g.player);
    }

    // Spawn poop if player flagged it
    if (g.player._spawnPoop) {
      g.player._spawnPoop = false;
      // Poop launches backwards (opposite of facing) and arcs up
      const pvx = -g.player.facing * 1.5;
      const pvy = -2.5;
      const spawnX = g.player.cx - g.player.facing * 20;
      const spawnY = g.player.bottom - 14;
      const poop = new Poop(spawnX, spawnY, pvx, pvy);
      g.level.poops.push(poop);
      g.audio.formPoopSound(g.player);
      g.particles.emit(PARTICLE_DUST, spawnX, spawnY, {
        vx: -g.player.facing * 0.8, vy: -1, life: 0.3, size: 3, color: "#cc88ff", gravity: 0.02, friction: 0.9
      });
    }

    // Update poops
    for (let i = g.level.poops.length - 1; i >= 0; i--) {
      const p = g.level.poops[i];
      if (p.alive) {
        p.update(dt, g.level);
      } else {
        g.level.poops.splice(i, 1);
      }
    }

    // Spawn rainbow bolt if player flagged it
    if (g.player._spawnRainbow) {
      g.player._spawnRainbow = false;
      // Adjust spawn position for small forms
      const isKittySmall = (g.player.isKittycorn && !g.player.isUnderwater);
      const isSmallUni = !g.player.isBig && !g.player.isMermaid && !g.player.isKittycorn && !g.player.isPixicorn && !g.player.isMouseicorn;
      const hornOffsetX = isKittySmall ? 8 : (isSmallUni ? 12 : 16);
      const hornOffsetY = isKittySmall ? (g.player.h * 0.3) : (isSmallUni ? 3 : 4);
      const hornX = g.player.cx + g.player.facing * hornOffsetX;
      const hornY = g.player.top + hornOffsetY;
      const bolt = new RainbowBolt(hornX, hornY, g.player.facing);
      g.level.rainbowBolts.push(bolt);
      g.audio.rainbowShotSound();
      g.particles.sparkleBurst(hornX, hornY, 5);
    }

    // Update rainbow bolts
    for (let i = g.level.rainbowBolts.length - 1; i >= 0; i--) {
      const rb = g.level.rainbowBolts[i];
      if (rb.alive) {
        rb.update(dt, g.level);
      } else {
        g.level.rainbowBolts.splice(i, 1);
      }
    }

    // Collision: rainbow bolts vs flies
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const fly of g.level.flies) {
        if (!fly.alive) continue;
        if (rb.overlaps(fly)) {
          fly.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(fly.cx, fly.cy, 12);
          g.particles.floatingText(fly.cx, fly.cy - 10, "ZAP!", "#ff4488");
          break;
        }
      }
    }

    // Collision: rainbow bolts vs gnomes
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const gnome of g.level.gnomes) {
        if (!gnome.alive) continue;
        if (rb.overlaps(gnome)) {
          gnome.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(gnome.cx, gnome.cy, 12);
          g.particles.floatingText(gnome.cx, gnome.cy - 10, "ZAP!", "#ff4488");
          break;
        }
      }
    }

    // Collision: rainbow bolts vs fish
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const fish of g.level.fish) {
        if (!fish.alive) continue;
        if (rb.overlaps(fish)) {
          fish.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(fish.cx, fish.cy, 12);
          g.particles.floatingText(fish.cx, fish.cy - 10, "ZAP!", "#ff4488");
          break;
        }
      }
    }

    // Collision: rainbow bolts vs jellyfish
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const jelly of g.level.jellyfish) {
        if (!jelly.alive) continue;
        if (rb.overlaps(jelly)) {
          jelly.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(jelly.cx, jelly.cy, 12);
          g.particles.floatingText(jelly.cx, jelly.cy - 10, "ZAP!", "#ff4488");
          break;
        }
      }
    }

    // Collision: rainbow bolts vs narwhals
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const nw of g.level.narwhals) {
        if (!nw.alive) continue;
        if (rb.overlaps(nw)) {
          nw.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(nw.cx, nw.cy, 12);
          g.particles.floatingText(nw.cx, nw.cy - 10, "ZAP!", "#44ccff");
          break;
        }
      }
    }

    // Collision: rainbow bolts vs birds
    for (const rb of g.level.rainbowBolts) {
      if (!rb.alive) continue;
      for (const bird of g.level.birds) {
        if (!bird.alive) continue;
        if (rb.overlaps(bird)) {
          bird.alive = false;
          rb.alive = false;
          g.audio.collectSound();
          g.particles.sparkleBurst(bird.cx, bird.cy, 12);
          g.particles.floatingText(bird.cx, bird.cy - 10, "ZAP!", "#ff8844");
          break;
        }
      }
    }

    // Collision: poop vs flies
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const fly of g.level.flies) {
        if (!fly.alive) continue;
        if (poop.overlaps(fly)) {
          fly.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(fly.cx, fly.cy, 10, "#cc88ff");
          g.particles.floatingText(fly.cx, fly.cy - 10, "SPLAT!", "#cc88ff");
          break;
        }
      }
    }

    // Collision: player vs wing crystals
    for (const wc of g.level.wingCrystals) {
      if (!wc.alive || wc.collected) continue;
      if (g.player.overlapsPad(wc, -4, -4)) {
        wc.collected = true;
        wc.alive = false;
        if (!g.player.hasWings) {
          g.player.collectWings(g.audio, g.particles);
        } else {
          g.audio.collectSound();
          g.particles.sparkleBurst(wc.cx, wc.cy, 6);
        }
      }
    }

    // Collision: player vs stars
    for (const star of g.level.stars) {
      if (!star.alive || star.collected) continue;
      if (g.player.overlapsPad(star, -4, -4)) {
        star.collect();
        g.player.stars++;
        g.audio.collectSound();
        g.particles.sparkleBurst(star.cx, star.cy, 12);
        g.particles.floatingText(star.cx, star.cy - 10, "+1", "#ffff44");
        // Every 5 stars = rainbow shooter
        if (g.player.stars % 5 === 0 && !g.player.hasRainbow) {
          g.player.hasRainbow = true;
          g.particles.sparkleBurst(g.player.cx, g.player.cy, 20);
          g.particles.floatingText(g.player.cx, g.player.cy - 20, "RAINBOW POWER!", "#ff4488");
        }
      }
    }

    // Collision: player vs flies
    for (const fly of g.level.flies) {
      if (!fly.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(fly, -8, 2)) {
        // Check if player is stomping (falling onto fly) — wide hooves
        if (g.player.vy > 0 && g.player.bottom - 8 < fly.cy) {
          fly.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.6;
          g.audio.collectSound();
          g.particles.impactBurst(fly.cx, fly.cy, 8, "#8888ff");
          g.particles.floatingText(fly.cx, fly.cy - 10, "SQUISH!", "#88aaff");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs gnomes
    for (const gnome of g.level.gnomes) {
      if (!gnome.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(gnome, -8, 2)) {
        if (g.player.vy > 0 && g.player.bottom - 8 < gnome.cy) {
          gnome.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.6;
          g.audio.collectSound();
          g.particles.impactBurst(gnome.cx, gnome.cy, 8, "#cc4444");
          g.particles.floatingText(gnome.cx, gnome.cy - 10, "BONK!", "#ff4444");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs fish
    for (const fish of g.level.fish) {
      if (!fish.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(fish, -6, 2)) {
        if (g.player.vy > 0 && g.player.bottom - 6 < fish.cy) {
          fish.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.5;
          g.audio.collectSound();
          g.particles.impactBurst(fish.cx, fish.cy, 8, "#44aaff");
          g.particles.floatingText(fish.cx, fish.cy - 10, "SPLASH!", "#44ccff");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs jellyfish
    for (const jelly of g.level.jellyfish) {
      if (!jelly.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(jelly, -4, 2)) {
        if (g.player.vy > 0 && g.player.bottom - 6 < jelly.cy) {
          jelly.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.5;
          g.audio.collectSound();
          g.particles.impactBurst(jelly.cx, jelly.cy, 10, "#cc88ff");
          g.particles.floatingText(jelly.cx, jelly.cy - 10, "ZAP!", "#ff88cc");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs narwhals
    for (const nw of g.level.narwhals) {
      if (!nw.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(nw, -4, 2)) {
        if (g.player.vy > 0 && g.player.bottom - 6 < nw.cy) {
          nw.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.5;
          g.audio.collectSound();
          g.particles.impactBurst(nw.cx, nw.cy, 8, "#44ccff");
          g.particles.floatingText(nw.cx, nw.cy - 10, "BONK!", "#44ccff");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs birds
    for (const bird of g.level.birds) {
      if (!bird.alive || !g.player.alive) continue;
      if (g.player.overlapsPad(bird, -4, 2)) {
        if (g.player.vy > 0 && g.player.bottom - 6 < bird.cy) {
          bird.alive = false;
          g.player.vy = CFG.JUMP_FORCE * 0.5;
          g.audio.collectSound();
          g.particles.impactBurst(bird.cx, bird.cy, 8, "#ff8844");
          g.particles.floatingText(bird.cx, bird.cy - 10, "SQUAWK!", "#ff8844");
        } else {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs mermaid gems
    for (const mg of g.level.mermaidGems) {
      if (!mg.alive || mg.collected || !g.player.alive) continue;
      if (g.player.overlaps(mg)) {
        mg.collected = true;
        if (!g.player.isMermaid) {
          g.player.collectMermaid(g.particles, g.audio);
        } else {
          g.audio.collectSound();
          g.particles.sparkleBurst(mg.cx, mg.cy, 6);
        }
      }
    }

    // Collision: player vs kittycorn gems
    for (const kg of g.level.kittycornGems) {
      if (!kg.alive || kg.collected || !g.player.alive) continue;
      if (g.player.overlaps(kg)) {
        kg.collected = true;
        if (!g.player.isKittycorn) {
          g.player.collectKittycorn(g.particles, g.audio);
        } else {
          g.audio.collectSound();
          g.particles.sparkleBurst(kg.cx, kg.cy, 6);
        }
      }
    }

    // Collision: player vs pixicorn gems
    for (const pg of g.level.pixicornGems) {
      if (!pg.alive || pg.collected || !g.player.alive) continue;
      if (g.player.overlaps(pg)) {
        pg.collected = true;
        if (!g.player.isPixicorn) {
          g.player.collectPixicorn(g.particles, g.audio);
        } else {
          g.audio.collectSound();
          g.particles.sparkleBurst(pg.cx, pg.cy, 6);
        }
      }
    }

    // Collision: player vs mousicorn gems
    for (const mg of g.level.mousicornGems) {
      if (!mg.alive || mg.collected || !g.player.alive) continue;
      if (g.player.overlaps(mg)) {
        mg.collected = true;
        if (!g.player.isMouseicorn) {
          g.player.collectMouseicorn(g.particles, g.audio);
        } else {
          g.audio.collectSound();
          g.particles.sparkleBurst(mg.cx, mg.cy, 6);
        }
      }
    }

    // Collision: player vs form gates (proximity-based "recognition")
    for (const gate of g.level.formGates) {
      if (gate.isOpen()) continue;
      if (gate.opened) continue; // already opening
      // Sense range: open when player is within 2 tiles horizontally
      const senseRange = CFG.TILE * 2;
      const dx = Math.abs(g.player.cx - gate.cx);
      const dy = Math.abs(g.player.cy - gate.cy);
      const inRange = dx < senseRange && dy < gate.h;
      const touching = g.player.overlaps(gate);
      const hasForm =
        gate.requiredForm === "mousicorn" ? g.player.isMouseicorn :
        gate.requiredForm === "kittycorn" ? g.player.isKittycorn :
        gate.requiredForm === "pixicorn" ? g.player.isPixicorn :
        gate.requiredForm === "mermaid" ? g.player.isMermaid : false;
      if ((inRange || touching) && hasForm) {
        gate.opened = true;
        g.audio.collectSound();
        g.particles.sparkleBurst(gate.cx, gate.cy, 30);
        // Clear the wall tiles for the gate
        const T = CFG.TILE;
        const gateCol = Math.floor(gate.x / T);
        const gateTopRow = Math.floor(gate.y / T);
        const gateRows = Math.ceil(gate.h / T);
        for (let r = gateTopRow; r < gateTopRow + gateRows; r++) {
          g.level.set(gateCol, r, TILE_EMPTY);
          g.level.set(gateCol + 1, r, TILE_EMPTY);
        }
      } else if (touching && !hasForm) {
        // Block player (push back)
        g.player.x = gate.x - g.player.w - 1;
        g.player.vx = 0;
        // Show hint text (throttle to avoid spam)
        if (!gate._hintTimer || gate._hintTimer <= 0) {
          g.particles.floatingText(gate.cx, gate.y - 10,
            "Need " + gate.requiredForm.toUpperCase() + "!", "#ffaa00");
          gate._hintTimer = 1.5;
        } else {
          gate._hintTimer -= dt;
        }
      }
    }

    // Collision: player vs fireballs
    for (const fb of g.level.fireballs) {
      if (!fb.alive || !g.player.alive) continue;
      if (g.player.overlaps(fb)) {
        g.player.hurt(g.particles, g.audio);
        fb.alive = false;
      }
    }

    // Collision: poop vs fireballs
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const fb of g.level.fireballs) {
        if (!fb.alive) continue;
        if (poop.overlaps(fb)) {
          fb.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(fb.cx, fb.cy, 6, "#ff8844");
          break;
        }
      }
    }

    // Collision: poop vs fish
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const fish of g.level.fish) {
        if (!fish.alive) continue;
        if (poop.overlaps(fish)) {
          fish.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(fish.cx, fish.cy, 8, "#44aaff");
          g.particles.floatingText(fish.cx, fish.cy - 10, "SPLAT!", "#44ccff");
          break;
        }
      }
    }

    // Collision: poop vs jellyfish
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const jelly of g.level.jellyfish) {
        if (!jelly.alive) continue;
        if (poop.overlaps(jelly)) {
          jelly.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(jelly.cx, jelly.cy, 8, "#cc88ff");
          g.particles.floatingText(jelly.cx, jelly.cy - 10, "SPLAT!", "#cc88ff");
          break;
        }
      }
    }

    // Collision: poop vs narwhals
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const nw of g.level.narwhals) {
        if (!nw.alive) continue;
        if (poop.overlaps(nw)) {
          nw.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(nw.cx, nw.cy, 8, "#44ccff");
          g.particles.floatingText(nw.cx, nw.cy - 10, "SPLAT!", "#44ccff");
          break;
        }
      }
    }

    // Collision: poop vs birds
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const bird of g.level.birds) {
        if (!bird.alive) continue;
        if (poop.overlaps(bird)) {
          bird.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(bird.cx, bird.cy, 8, "#ff8844");
          g.particles.floatingText(bird.cx, bird.cy - 10, "SPLAT!", "#ff8844");
          break;
        }
      }
    }

    // Collision: poop vs gnomes
    for (const poop of g.level.poops) {
      if (!poop.alive || poop.landed) continue;
      for (const gnome of g.level.gnomes) {
        if (!gnome.alive) continue;
        if (poop.overlaps(gnome)) {
          gnome.alive = false;
          poop.alive = false;
          g.audio.collectSound();
          g.particles.impactBurst(gnome.cx, gnome.cy, 10, "#cc88ff");
          g.particles.floatingText(gnome.cx, gnome.cy - 10, "SPLAT!", "#cc88ff");
          break;
        }
      }
    }

    // Collision: poop vs dead flowers (revive them)
    for (const poop of g.level.poops) {
      if (!poop.alive) continue;
      for (const df of g.level.deadFlowers) {
        if (!df.alive || df.revived) continue;
        if (poop.overlaps(df)) {
          df.revived = true;
          df.reviveTimer = 0;
          poop.alive = false;
          g.player.flowersRevived++;
          g.player.flowersForRainbow++;
          g.audio.flowerBloomSound();
          g.particles.sparkleBurst(df.cx, df.cy, 10);
          g.particles.floatingText(df.cx, df.cy - 12, "BLOOM!", "#ff88cc");
          // Check for rainbow power
          if (g.player.flowersForRainbow >= CFG.FLOWERS_FOR_RAINBOW && !g.player.hasRainbow) {
            g.player.hasRainbow = true;
            g.particles.sparkleBurst(g.player.cx, g.player.cy, 20);
            g.particles.floatingText(g.player.cx, g.player.cy - 20, "RAINBOW POWER!", "#ff4488");
          }
          // Check for extra life at 20 flowers
          if (g.player.flowersRevived >= CFG.FLOWERS_FOR_LIFE) {
            g.player.lives++;
            g.player.flowersRevived = 0;
            g.player.flowersForRainbow = 0;
            g.audio.extraLifeSound();
            g.particles.sparkleBurst(g.player.cx, g.player.cy, 30);
            g.particles.floatingText(g.player.cx, g.player.cy - 20, "1UP!", "#44ff44");
          }
          break;
        }
      }
    }

    // Collision: poop vs black flowers (spawn hay bale, or free life if already big)
    for (const poop of g.level.poops) {
      if (!poop.alive) continue;
      for (const bf of g.level.blackFlowers) {
        if (!bf.alive || bf.used) continue;
        if (poop.overlaps(bf)) {
          bf.used = true;
          poop.alive = false;
          g.audio.flowerBloomSound();
          if (g.player.isBig) {
            // Already big — free life with rainbow effect!
            g.player.lives++;
            g.audio.extraLifeSound();
            g.particles.sparkleBurst(bf.cx, bf.cy, 20);
            g.particles.floatingText(bf.cx, bf.cy - 12, "1UP!", "#00ff88");
            // Rainbow burst
            const colors = ["#ff0000","#ff8800","#ffff00","#00ff00","#0088ff","#8800ff"];
            for (const clr of colors) {
              g.particles.impactBurst(bf.cx, bf.cy, 4, clr);
            }
          } else {
            // Not big yet — spawn hay bale
            g.particles.impactBurst(bf.cx, bf.cy, 8, "#8800aa");
            const hb = new HayBale(bf.cx - 8, bf.cy - 20);
            g.level.hayBales.push(hb);
          }
          break;
        }
      }
    }

    // Collision: player vs hay bales (grow big, or 1-UP if already big)
    for (const hb of g.level.hayBales) {
      if (!hb.alive) continue;
      if (g.player.overlaps(hb)) {
        hb.alive = false;
        if (!g.player.isBig) {
          g.player.isBig = true;
          g.audio.growBigSound();
          g.particles.sparkleBurst(g.player.cx, g.player.cy, 15);
          g.particles.floatingText(g.player.cx, g.player.cy - 20, "BIG!", "#daa520");
        } else {
          // Already big — 1-UP!
          g.player.lives++;
          g.audio.extraLifeSound();
          g.particles.sparkleBurst(g.player.cx, g.player.cy, 20);
          g.particles.floatingText(g.player.cx, g.player.cy - 20, "1UP!", "#00ff88");
          const colors = ["#ff0000","#ff8800","#ffff00","#00ff00","#0088ff","#8800ff"];
          for (const clr of colors) {
            g.particles.impactBurst(g.player.cx, g.player.cy, 4, clr);
          }
        }
      }
    }

    // Collision: poop vs boss
    if (g.level.boss && g.level.boss.alive && !g.level.boss.defeated) {
      for (const poop of g.level.poops) {
        if (!poop.alive || poop.landed) continue;
        if (poop.overlaps(g.level.boss)) {
          g.level.boss.hit(g.particles, g.audio);
          poop.alive = false;
          break;
        }
      }
    }

    // Collision: rainbow bolts vs boss
    if (g.level.boss && g.level.boss.alive && !g.level.boss.defeated) {
      for (const rb of g.level.rainbowBolts) {
        if (!rb.alive) continue;
        if (rb.overlaps(g.level.boss)) {
          g.level.boss.hit(g.particles, g.audio);
          rb.alive = false;
          break;
        }
      }
    }

    // Collision: player vs boss
    if (g.level.boss && g.level.boss.alive && !g.level.boss.defeated && g.player.alive) {
      if (g.player.overlapsPad(g.level.boss, -4, 2)) {
        // Stomping boss?
        if (g.player.vy > 0 && g.player.bottom - 8 < g.level.boss.cy) {
          g.level.boss.hit(g.particles, g.audio);
          g.player.vy = CFG.JUMP_FORCE * 0.7;
        } else if (g.level.boss.invTimer <= 0) {
          g.player.hurt(g.particles, g.audio);
        }
      }
    }

    // Collision: player vs hoop
    if (g.level.hoop && g.level.hoop.alive && g.player.overlaps(g.level.hoop)) {
      g.audio.hoopSound();
      g.particles.sparkleBurst(g.level.hoop.cx, g.level.hoop.cy, 20);
      g.player.animState = "hoopClear";
      g.player.animFrame = 0;
      g.player.animTimer = 0;
      g.player.speedX = 0;
      g.player.vx = 0;
      this.setState(STATE_COMPLETE);
    }

    // Player died
    if (!g.player.alive) {
      this.deathTimer = 0;
      this.setState(STATE_DYING);
    }

    // Camera
    g.camera.follow(g.player.cx, g.player.cy, g.player.facing, dt);

    // Particles
    g.particles.update(dt);
  }
  updateDying(dt) {
    this.deathTimer += dt;
    this.game.particles.update(dt);
    if (this.deathTimer > 1.5) {
      if (this.game.player.lives > 0) {
        // Restart current level from beginning (keep power-ups and lives)
        this.game.startLevel(false);
        this.setState(STATE_PLAYING);
      } else {
        // Game over - back to title
        this.game.currentLevelIndex = 0;
        this.setState(STATE_TITLE);
      }
    }
  }
  updateComplete(dt) {
    const g = this.game;
    g.particles.update(dt);

    // Animate hoop clear sprite: play frames 0-5, then cycle 4-5 for sparkle
    const p = g.player;
    if (p.animState === "hoopClear") {
      p.animTimer += dt;
      if (p.animTimer > 0.15) {
        p.animTimer = 0;
        if (p.animFrame < 5) {
          p.animFrame++;
        } else {
          p.animFrame = p.animFrame === 5 ? 4 : 5;
        }
      }
    }

    const def = g.level.levelDef;
    const isBossLevel = def.isBoss;
    const nextIdx = g.currentLevelIndex + 1;
    const isGameComplete = nextIdx >= LEVEL_DEFS.length;

    // Auto-advance after world boss (5s to read save code), or Enter to skip
    const autoAdvance = isBossLevel && !isGameComplete && this.stateTimer > 5.0;
    const manualAdvance = g.input.enter && this.stateTimer > 1.0;

    if (autoAdvance || manualAdvance) {
      g.audio.menuSelect();
      if (!isGameComplete) {
        g.currentLevelIndex = nextIdx;
        g.startLevel(false); // keep power-ups
        this.setState(STATE_LEVEL_INTRO);
      } else {
        // All worlds complete! Back to title
        this.setState(STATE_TITLE);
      }
    }
  }
}

// --- Main Game Class ---
class Game {
  constructor() {
    const canvas = document.getElementById("c");
    this.renderer = new Renderer(canvas);
    this.input = new InputManager();
    this.audio = new AudioManager();
    this.camera = new Camera();
    this.particles = new ParticleSystem(300);
    this.parallax = new ParallaxBackground(LEVEL_DEFS[0]);
    this.tileRenderer = new TileRenderer();
    this.spriteDrawer = new SpriteDrawer();
    this.hud = new HUD();
    this.stateMachine = new GameStateMachine(this);

    this.currentLevelIndex = 0;
    this.level = null;
    this.player = new Player(0, 0);
    this.gameTime = 0;
    this.levelTimer = 0;

    this.lastTime = 0;
    this.accumulator = 0;
    this.fixedDT = 1 / 60;
    this.konamiFlashTimer = 0;
    this.konamiActivated = false;
  }
  startLevel(freshGame) {
    const def = LEVEL_DEFS[this.currentLevelIndex];
    this.level = new Level(def);
    this.level.generate();
    // Rebuild parallax for new theme (multi-parallax for zoned levels)
    if (def.zones) {
      this.parallaxMap = {};
      for (const zone of def.zones) {
        if (!this.parallaxMap[zone.bgTheme]) {
          this.parallaxMap[zone.bgTheme] = new ParallaxBackground(zone);
        }
      }
      this.parallaxZones = def.zones;
      this.parallax = this.parallaxMap[def.zones[0].bgTheme];
    } else {
      this.parallax = new ParallaxBackground(def);
      this.parallaxMap = null;
      this.parallaxZones = null;
    }
    this.camera.setBounds(this.level.width, this.level.height);
    this.player.reset(this.level.spawnX, this.level.spawnY);
    this.player.stars = 0;
    this.player.isUnderwater = def.zones ? !!def.zones[0].isUnderwater : !!def.isUnderwater;
    this.gameTime = 0;
    this.levelTimer = def.isBoss ? CFG.BOSS_LEVEL_TIME : CFG.LEVEL_TIME;
    if (freshGame) {
      // Brand new game — reset everything
      this.currentLevelIndex = 0;
      const freshDef = LEVEL_DEFS[0];
      this.level = new Level(freshDef);
      this.level.generate();
      this.parallax = new ParallaxBackground(freshDef);
      this.camera.setBounds(this.level.width, this.level.height);
      this.player.reset(this.level.spawnX, this.level.spawnY);
      this.player.lives = CFG.LIVES;
      this.player.isBig = false;
      this.player.hasWings = false;
      this.player.hasRainbow = false;
      this.player.isMermaid = false;
      this.player.isKittycorn = false;
      this.player.isPixicorn = false;
      this.player.isMouseicorn = false;
      this.player.isUnderwater = !!freshDef.isUnderwater;
      this.player.flowersRevived = 0;
      this.player.flowersForRainbow = 0;
      this.player.canTripleJump = false;
      this.player.canDoubleJump = false;
      this.player.growWingsTimer = 0;
      this.player.mermaidTransformTimer = 0;
      this.player.kittycornTransformTimer = 0;
      this.player.pixicornTransformTimer = 0;
      this.player.mousicornTransformTimer = 0;
      // Restore konami lives after fresh-game reset
      if (this.konamiActivated) this.player.lives = 10;
    }
    // Power-ups (isBig, hasWings, hasRainbow, lives) carry over between levels
    // Clear incompatible transformations for the new environment:
    // Mermaid can't be on land — revert to normal unicorn
    if (!this.player.isUnderwater && this.player.isMermaid) {
      this.player.isMermaid = false;
    }
    // Land forms (mousicorn, kittycorn, pixicorn) can't display underwater — revert
    if (this.player.isUnderwater) {
      if (this.player.isMouseicorn) this.player.isMouseicorn = false;
      if (this.player.isKittycorn) this.player.isKittycorn = false;
      if (this.player.isPixicorn) this.player.isPixicorn = false;
    }
    // Snap camera to player
    this.camera.x = this.player.cx - CFG.W * 0.4;
    this.camera.targetX = this.camera.x;
    // Lock Y to show ground
    this.camera.y = this.level.height - CFG.H;
    this.camera.targetY = this.camera.y;
  }
  respawnPlayer() {
    this.player.reset(this.level.spawnX, this.level.spawnY);
    this.camera.x = this.player.cx - CFG.W * 0.4;
    this.camera.targetX = this.camera.x;
    this.camera.y = this.level.height - CFG.H;
    this.camera.targetY = this.camera.y;
  }
  run(timestamp) {
    if (!this.lastTime) this.lastTime = timestamp;
    let dt = (timestamp - this.lastTime) / 1000;
    this.lastTime = timestamp;

    // Clamp large dt (tab switch, etc.)
    if (dt > 0.1) dt = 0.1;

    // Init audio on first interaction (keyboard or gamepad)
    if (!this.audio.initialized) {
      if (Object.keys(this.input.keys).length > 0 || this.input.anyGamepadPressed) {
        this.audio.init();
        // Start title music if on title screen
        if (this.stateMachine.state === STATE_TITLE) {
          this.audio.playMusic("title_screen", true);
        }
      }
    }

    // Check for deferred music that finished loading
    if (this.audio.initialized) {
      this.audio.checkPendingMusic();
    }

    this.input.update();

    // Konami Code reward — flag persists so lives survive startLevel reset
    if (this.input.konamiJustCompleted) {
      this.konamiActivated = true;
      this.player.lives = 10;
      this.audio.hoopSound();
      this.konamiFlashTimer = 2.0;
    }
    if (this.konamiFlashTimer > 0) this.konamiFlashTimer -= dt;

    // Fixed timestep for physics
    this.accumulator += dt;
    while (this.accumulator >= this.fixedDT) {
      this.stateMachine.update(this.fixedDT);
      this.accumulator -= this.fixedDT;
    }

    // Render
    this.render(dt);

    requestAnimationFrame(t => this.run(t));
  }
  render(dt) {
    const c = this.renderer.c;
    this.renderer.begin();

    switch (this.stateMachine.state) {
      case STATE_TITLE:
        this.renderTitle(c);
        break;
      case STATE_CODE_ENTRY:
        this.renderCodeEntry(c);
        break;
      case STATE_LEVEL_INTRO:
        this.renderGame(c);
        this.renderLevelIntro(c);
        break;
      case STATE_PLAYING:
      case STATE_DYING:
        this.renderGame(c);
        break;
      case STATE_PAUSED:
        this.renderGame(c);
        this.renderPaused(c);
        break;
      case STATE_COMPLETE:
        this.renderGame(c);
        this.renderComplete(c);
        break;
    }

    // Konami Code flash (visible on any screen)
    if (this.konamiFlashTimer > 0) {
      c.save();
      const a = Math.min(1, this.konamiFlashTimer);
      c.fillStyle = `rgba(255,215,0,${a * 0.25})`;
      c.fillRect(0, 0, CFG.W, CFG.H);
      c.textAlign = "center";
      c.textBaseline = "middle";
      c.font = "bold 18px monospace";
      c.fillStyle = `rgba(255,255,100,${a})`;
      c.fillText("\u2764 10 LIVES! \u2764", CFG.W / 2, CFG.H / 2);
      c.restore();
    }

    this.renderer.end();
  }
  renderTitle(c) {
    const gt = this.stateMachine.titlePhase;

    // Animated background
    const grd = c.createLinearGradient(0, 0, 0, CFG.H);
    const hue1 = (gt * 20) % 360;
    const hue2 = (hue1 + 60) % 360;
    const hue3 = (hue1 + 120) % 360;
    grd.addColorStop(0, `hsl(${hue1},70%,15%)`);
    grd.addColorStop(0.5, `hsl(${hue2},60%,20%)`);
    grd.addColorStop(1, `hsl(${hue3},70%,15%)`);
    c.fillStyle = grd;
    c.fillRect(0, 0, CFG.W, CFG.H);

    // Stars in background
    const rng = new SeededRNG(42);
    for (let i = 0; i < 50; i++) {
      const sx = rng.next() * CFG.W;
      const sy = rng.next() * CFG.H * 0.7;
      const twinkle = Math.sin(gt * 3 + i * 1.5) * 0.4 + 0.6;
      c.fillStyle = `rgba(255,255,255,${twinkle})`;
      c.beginPath();
      c.arc(sx, sy, 1 + rng.next(), 0, Math.PI*2);
      c.fill();
    }

    // Title text with rainbow gradient
    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";

    // Title shadow
    c.font = "bold 28px monospace";
    c.fillStyle = "rgba(0,0,0,0.5)";
    c.fillText("RAINBOW UNICORN QUEST", CFG.W/2 + 2, 72);

    // Title with rainbow
    const titleGrd = c.createLinearGradient(CFG.W/2 - 160, 0, CFG.W/2 + 160, 0);
    const offset = (gt * 0.5) % 1;
    const rainbowColors = ["#ff4444","#ff8800","#ffff00","#44ff44","#4488ff","#8844ff","#ff44ff"];
    for (let i = 0; i < rainbowColors.length; i++) {
      titleGrd.addColorStop(((i / rainbowColors.length) + offset) % 1, rainbowColors[i]);
    }
    c.fillStyle = titleGrd;
    c.fillText("RAINBOW UNICORN QUEST", CFG.W/2, 70);

    // Subtitle
    c.font = "bold 14px monospace";
    c.fillStyle = "#cc88ff";
    c.fillText("NEXT  GEN", CFG.W/2, 95);

    // Animated unicorn on title screen
    const bobY = Math.sin(gt * 2) * 5;
    c.save();
    c.translate(CFG.W/2, 155 + bobY);
    if (SPRITES.run) {
      // Use real sprite - animated running in place
      const frame = Math.floor(gt * 10) % CFG.SPRITE_RUN_FRAMES;
      const srcX = frame * CFG.SPRITE_RUN_FW;
      const drawH = 80;
      const drawW = CFG.SPRITE_RUN_FW * (drawH / CFG.SPRITE_RUN_FH);
      c.drawImage(SPRITES.run,
        srcX, 0, CFG.SPRITE_RUN_FW, CFG.SPRITE_RUN_FH,
        -drawW/2, -drawH/2, drawW, drawH
      );
    } else {
      // Fallback circle
      c.fillStyle = "#ffffff";
      c.beginPath();
      c.ellipse(0, 0, 20, 14, 0, 0, Math.PI*2);
      c.fill();
    }
    c.restore();

    // Instructions
    const blink = Math.sin(gt * 4) > 0;
    if (blink) {
      c.font = "bold 11px monospace";
      c.fillStyle = "#ffffff";
      c.fillText("PRESS  ENTER  TO  START", CFG.W/2, 210);
    }

    c.font = "9px monospace";
    c.fillStyle = "#8866aa";
    c.fillText("ARROWS / WASD = Move    SPACE = Jump    Double Jump in midair!", CFG.W/2, 235);

    // Code entry hint
    c.font = "bold 9px monospace";
    c.fillStyle = "#44aaaa";
    c.fillText("PRESS  C / SELECT  TO  ENTER  SAVE  CODE", CFG.W/2, 252);

    c.restore();
  }
  renderCodeEntry(c) {
    const gt = this.stateMachine.titlePhase;

    // Dark background
    c.fillStyle = "#0a0a1a";
    c.fillRect(0, 0, CFG.W, CFG.H);

    // Starfield
    const rng = new SeededRNG(42);
    for (let i = 0; i < 50; i++) {
      const sx = rng.next() * CFG.W;
      const sy = rng.next() * CFG.H * 0.8;
      const twinkle = Math.sin(gt * 3 + i * 1.5) * 0.3 + 0.5;
      c.fillStyle = `rgba(255,255,255,${twinkle})`;
      c.beginPath();
      c.arc(sx, sy, 1, 0, Math.PI*2);
      c.fill();
    }

    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";

    // Title
    c.font = "bold 20px monospace";
    c.fillStyle = "#ffcc44";
    c.fillText("ENTER  SAVE  CODE", CFG.W/2, 60);

    // Code display boxes
    const boxW = 32, boxH = 38, gap = 8;
    const totalW = 4 * boxW + 3 * gap;
    const startX = CFG.W/2 - totalW/2;
    const boxY = CFG.H/2 - 25;
    const code = this.stateMachine.codeInput || "";

    const letterIdx = this.stateMachine.codeLetterIdx || 0;
    const curLetter = String.fromCharCode(65 + letterIdx);

    for (let i = 0; i < 4; i++) {
      const bx = startX + i * (boxW + gap);
      // Box background
      c.fillStyle = i < code.length ? "rgba(50,200,220,0.15)" : "rgba(255,255,255,0.05)";
      c.fillRect(bx, boxY, boxW, boxH);
      // Box border
      c.strokeStyle = i === code.length ? "#44ddee" : "rgba(255,255,255,0.3)";
      c.lineWidth = i === code.length ? 2 : 1;
      c.strokeRect(bx, boxY, boxW, boxH);

      // Letter (confirmed)
      if (i < code.length) {
        c.font = "bold 22px monospace";
        c.fillStyle = "#ffffff";
        c.fillText(code[i], bx + boxW/2, boxY + boxH/2 + 1);
      }

      // Active box — show cycling letter with up/down arrows
      if (i === code.length && code.length < 4) {
        // Current selected letter
        c.font = "bold 22px monospace";
        c.fillStyle = "#44ddee";
        c.fillText(curLetter, bx + boxW/2, boxY + boxH/2 + 1);
        // Up arrow hint
        c.font = "10px monospace";
        c.fillStyle = "rgba(68,221,238,0.6)";
        c.fillText("\u25B2", bx + boxW/2, boxY - 8);
        // Down arrow hint
        c.fillText("\u25BC", bx + boxW/2, boxY + boxH + 12);
      }
    }

    // Message (accepted / invalid)
    const msg = this.stateMachine.codeMessage;
    if (msg) {
      c.font = "bold 14px monospace";
      c.fillStyle = this.stateMachine.codeSuccess ? "#44ff88" : "#ff4444";
      c.fillText(msg, CFG.W/2, boxY + boxH + 30);
    }

    // Instructions — show both keyboard and gamepad
    c.font = "9px monospace";
    c.fillStyle = "rgba(255,255,255,0.5)";
    c.fillText("KEYBOARD: TYPE + ENTER    BACKSPACE    ESC", CFG.W/2, CFG.H - 38);
    c.fillText("GAMEPAD:  \u25B2\u25BC PICK LETTER   A CONFIRM   B DELETE   START SUBMIT", CFG.W/2, CFG.H - 24);

    c.restore();
  }
  renderLevelIntro(c) {
    const gt = this.stateMachine.stateTimer;
    const def = LEVEL_DEFS[this.currentLevelIndex];

    // Dark overlay
    const alpha = Math.max(0.3, 0.8 - gt * 0.3);
    c.fillStyle = `rgba(0,0,20,${alpha})`;
    c.fillRect(0, 0, CFG.W, CFG.H);

    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";

    // World / Level name
    c.font = "bold 16px monospace";
    c.fillStyle = "#ffcc44";
    c.fillText("WORLD " + def.world + " - " + def.level, CFG.W/2, CFG.H/2 - 25);

    c.font = "bold 24px monospace";
    const tGrd = c.createLinearGradient(CFG.W/2 - 120, 0, CFG.W/2 + 120, 0);
    const rainbowC = ["#ff4444","#ff8800","#ffff00","#44ff44","#4488ff","#8844ff","#ff44ff"];
    for (let i = 0; i < rainbowC.length; i++) {
      tGrd.addColorStop(i / (rainbowC.length - 1), rainbowC[i]);
    }
    c.fillStyle = tGrd;
    c.fillText(def.title, CFG.W/2, CFG.H/2 + 10);

    // Lives display
    c.font = "bold 11px monospace";
    c.fillStyle = "#ffffff";
    c.fillText("\u2764 x " + this.player.lives, CFG.W/2, CFG.H/2 + 40);

    c.restore();
  }
  renderGame(c) {
    const camX = this.camera.scrollX;
    const camY = this.camera.scrollY;

    // Parallax background (multi-parallax with crossfade for zoned levels)
    if (this.parallaxMap) {
      const camCol = Math.floor(camX / CFG.TILE);
      const currentZone = this.level.getZoneAtCol(camCol);
      const screenEndCol = camCol + Math.ceil(CFG.W / CFG.TILE);
      const nextZone = this.level.getZoneAtCol(screenEndCol);

      const currentBg = this.parallaxMap[currentZone.bgTheme];
      if (currentBg) currentBg.draw(c, camX);

      // Crossfade if next zone has different theme
      if (nextZone.bgTheme !== currentZone.bgTheme) {
        const transitionWidth = 15; // tiles
        const distToZone = nextZone.startCol - camCol;
        if (distToZone < transitionWidth && distToZone > -5) {
          const alpha = Math.max(0, Math.min(1, 1 - distToZone / transitionWidth));
          c.globalAlpha = alpha;
          const nextBg = this.parallaxMap[nextZone.bgTheme];
          if (nextBg) nextBg.draw(c, camX);
          c.globalAlpha = 1;
        }
      }
    } else {
      this.parallax.draw(c, camX);
    }

    c.save();
    // Don't translate - we pass camX/camY to each draw call for precision

    // Tiles
    this.tileRenderer.drawTiles(c, this.level, camX, camY);

    // Dead flowers
    for (const df of this.level.deadFlowers) {
      if (df.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawDeadFlower(c, df, this.gameTime);
        c.restore();
      }
    }

    // Black flowers
    for (const bf of this.level.blackFlowers) {
      if (bf.alive && !bf.used) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawBlackFlower(c, bf, this.gameTime);
        c.restore();
      }
    }

    // Hay bales
    for (const hb of this.level.hayBales) {
      if (hb.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawHayBale(c, hb, this.gameTime);
        c.restore();
      }
    }

    // Wing crystals
    for (const wc of this.level.wingCrystals) {
      if (wc.alive && !wc.collected) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawWingCrystal(c, wc, this.gameTime);
        c.restore();
      }
    }

    // Form gates
    for (const gate of this.level.formGates) {
      if (!gate.isOpen()) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawFormGate(c, gate, this.gameTime);
        c.restore();
      }
    }

    // Stars (behind player)
    for (const star of this.level.stars) {
      if (star.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawStar(c, star, this.gameTime);
        c.restore();
      }
    }

    // Hoop
    if (this.level.hoop && this.level.hoop.alive) {
      c.save();
      c.translate(-camX, -camY);
      this.spriteDrawer.drawHoop(c, this.level.hoop, this.gameTime);
      c.restore();
    }

    // Flies
    for (const fly of this.level.flies) {
      if (fly.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawFly(c, fly, this.gameTime);
        c.restore();
      }
    }

    // Gnomes
    for (const gnome of this.level.gnomes) {
      if (gnome.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawGnome(c, gnome, this.gameTime);
        c.restore();
      }
    }

    // Fish
    for (const fish of this.level.fish) {
      if (fish.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawFish(c, fish, this.gameTime);
        c.restore();
      }
    }

    // Jellyfish
    for (const jelly of this.level.jellyfish) {
      if (jelly.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawJellyfish(c, jelly, this.gameTime);
        c.restore();
      }
    }

    // Narwhals
    for (const nw of this.level.narwhals) {
      if (nw.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawNarwhal(c, nw, this.gameTime);
        c.restore();
      }
    }

    // Birds
    for (const bird of this.level.birds) {
      if (bird.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawBird(c, bird, this.gameTime);
        c.restore();
      }
    }

    // Mermaid Gems
    for (const mg of this.level.mermaidGems) {
      if (mg.alive && !mg.collected) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawMermaidGem(c, mg, this.gameTime);
        c.restore();
      }
    }

    // Kittycorn Gems
    for (const kg of this.level.kittycornGems) {
      if (kg.alive && !kg.collected) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawKittycornGem(c, kg, this.gameTime);
        c.restore();
      }
    }

    // Pixicorn Gems
    for (const pg of this.level.pixicornGems) {
      if (pg.alive && !pg.collected) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawPixicornGem(c, pg, this.gameTime);
        c.restore();
      }
    }

    // Mousicorn Gems
    for (const mg of this.level.mousicornGems) {
      if (mg.alive && !mg.collected) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawMousicornGem(c, mg, this.gameTime);
        c.restore();
      }
    }

    // Fireballs
    for (const fb of this.level.fireballs) {
      if (fb.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawFireball(c, fb, this.gameTime);
        c.restore();
      }
    }

    // Boss
    if (this.level.boss && this.level.boss.alive) {
      c.save();
      c.translate(-camX, -camY);
      this.spriteDrawer.drawBoss(c, this.level.boss, this.gameTime);
      c.restore();
    }

    // Poops
    for (const poop of this.level.poops) {
      if (poop.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawPoop(c, poop, this.gameTime);
        c.restore();
      }
    }

    // Rainbow bolts
    for (const rb of this.level.rainbowBolts) {
      if (rb.alive) {
        c.save();
        c.translate(-camX, -camY);
        this.spriteDrawer.drawRainbowBolt(c, rb, this.gameTime);
        c.restore();
      }
    }

    // Player
    if (this.player.alive || this.stateMachine.state === STATE_DYING) {
      c.save();
      c.translate(-camX, -camY);
      this.spriteDrawer.drawPlayer(c, this.player, this.gameTime);
      c.restore();
    }

    // Particles (world space)
    this.particles.draw(c, camX, camY);

    c.restore();

    // Underwater tint overlay (zone-aware)
    let showUnderwaterTint = false;
    if (this.level.levelDef.zones) {
      const camCol = Math.floor(this.camera.scrollX / CFG.TILE);
      const zone = this.level.getZoneAtCol(camCol);
      showUnderwaterTint = !!zone.isUnderwater;
    } else {
      showUnderwaterTint = !!this.level.levelDef.isUnderwater;
    }
    if (showUnderwaterTint) {
      c.fillStyle = "rgba(10,40,80,0.15)";
      c.fillRect(0, 0, CFG.W, CFG.H);
      // Animated bubble columns
      const gt = this.gameTime;
      for (let i = 0; i < 6; i++) {
        const bx = (i * 83 + 40) % CFG.W;
        const by = CFG.H - ((gt * 30 + i * 50) % (CFG.H + 20));
        const br = 1.5 + Math.sin(gt * 3 + i) * 0.5;
        c.fillStyle = "rgba(150,200,255,0.15)";
        c.beginPath();
        c.arc(bx + Math.sin(gt * 2 + i * 1.3) * 5, by, br, 0, Math.PI*2);
        c.fill();
      }
    }

    // HUD
    this.hud.draw(c, this.player, this.gameTime, this.level.levelDef, this.levelTimer);

    // Death overlay
    if (this.stateMachine.state === STATE_DYING) {
      const alpha = Math.min(0.6, this.stateMachine.deathTimer * 0.5);
      c.fillStyle = `rgba(80,0,0,${alpha})`;
      c.fillRect(0, 0, CFG.W, CFG.H);

      if (this.stateMachine.deathTimer > 0.5) {
        c.save();
        c.textAlign = "center";
        c.textBaseline = "middle";
        c.font = "bold 20px monospace";
        c.fillStyle = "#ff4444";
        c.fillText(this.player.lives > 0 ? "OUCH!" : "GAME OVER", CFG.W/2, CFG.H/2);
        c.restore();
      }
    }
  }
  renderPaused(c) {
    // Dark overlay
    c.fillStyle = "rgba(0,0,20,0.6)";
    c.fillRect(0, 0, CFG.W, CFG.H);
    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";
    c.font = "bold 28px monospace";
    c.fillStyle = "#ffffff";
    c.fillText("PAUSED", CFG.W/2, CFG.H/2 - 10);
    const gt = this.stateMachine.stateTimer;
    if (Math.sin(gt * 4) > 0) {
      c.font = "bold 11px monospace";
      c.fillStyle = "#aaaaff";
      c.fillText("PRESS  START  TO  RESUME", CFG.W/2, CFG.H/2 + 20);
    }
    c.restore();
  }
  renderComplete(c) {
    // Overlay
    const alpha = Math.min(0.7, this.stateMachine.stateTimer * 0.8);
    c.fillStyle = `rgba(0,0,40,${alpha})`;
    c.fillRect(0, 0, CFG.W, CFG.H);

    const gt = this.stateMachine.stateTimer;
    const def = this.level.levelDef;
    const isBossLevel = def.isBoss;
    const isWorldComplete = isBossLevel;
    const nextIdx = this.currentLevelIndex + 1;
    const isGameComplete = nextIdx >= LEVEL_DEFS.length;

    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";

    // Big text
    c.font = "bold 26px monospace";
    const tGrd = c.createLinearGradient(CFG.W/2 - 120, 0, CFG.W/2 + 120, 0);
    const rainbowC = ["#ff4444","#ff8800","#ffff00","#44ff44","#4488ff","#8844ff","#ff44ff"];
    for (let i = 0; i < rainbowC.length; i++) {
      tGrd.addColorStop(i / (rainbowC.length - 1), rainbowC[i]);
    }
    c.fillStyle = tGrd;
    if (isGameComplete) {
      c.fillText("YOU  WIN!", CFG.W/2, CFG.H/2 - 40);
      c.font = "bold 16px monospace";
      c.fillStyle = "#ffcc44";
      c.fillText("ALL WORLDS COMPLETE!", CFG.W/2, CFG.H/2 - 10);
    } else if (isWorldComplete) {
      c.fillText("WORLD " + def.world + " CLEAR!", CFG.W/2, CFG.H/2 - 40);
      c.font = "bold 14px monospace";
      c.fillStyle = "#ffcc44";
      c.fillText("BOSS DEFEATED!", CFG.W/2, CFG.H/2 - 10);
    } else {
      c.fillText("LEVEL  COMPLETE!", CFG.W/2, CFG.H/2 - 30);
    }

    // Stats
    c.font = "bold 13px monospace";
    c.fillStyle = "#ffee44";
    c.fillText("Stars: " + this.player.stars + " / " + this.level.stars.length, CFG.W/2, CFG.H/2 + 15);

    // Level name
    c.font = "bold 10px monospace";
    c.fillStyle = "#aaaacc";
    c.fillText(def.name + " " + def.title, CFG.W/2, CFG.H/2 + 32);

    // Show save code when completing a world (boss defeated)
    if (isWorldComplete && !isGameComplete) {
      const nextWorld = def.world + 1;
      const nextCode = WORLD_CODE_BY_NUM[nextWorld];
      if (nextCode) {
        c.font = "bold 10px monospace";
        c.fillStyle = "#44ddee";
        c.fillText("SAVE CODE FOR WORLD " + nextWorld + ":", CFG.W/2, CFG.H/2 + 48);
        c.font = "bold 18px monospace";
        c.fillStyle = "#ffffff";
        c.fillText(nextCode, CFG.W/2, CFG.H/2 + 66);
        c.font = "8px monospace";
        c.fillStyle = "rgba(255,255,255,0.4)";
        c.fillText("WRITE THIS DOWN!", CFG.W/2, CFG.H/2 + 80);
      }
    }

    // Next level prompt
    if (gt > 2.5 && Math.sin(gt * 4) > 0) {
      c.font = "bold 11px monospace";
      c.fillStyle = "#aaaaff";
      const promptY = isWorldComplete && !isGameComplete ? CFG.H/2 + 96 : CFG.H/2 + 55;
      if (isGameComplete) {
        c.fillText("PRESS  ENTER  FOR  TITLE", CFG.W/2, promptY);
      } else if (isWorldComplete) {
        const secsLeft = Math.max(0, Math.ceil(5.0 - gt));
        const nextDef = LEVEL_DEFS[nextIdx];
        c.fillText("CONTINUING TO " + nextDef.name + " IN " + secsLeft + "...", CFG.W/2, promptY);
      } else {
        const nextDef = LEVEL_DEFS[nextIdx];
        c.fillText("PRESS ENTER FOR " + nextDef.name + " " + nextDef.title, CFG.W/2, promptY);
      }
    }

    c.restore();

    // Continuous sparkle effect
    if (Math.random() < 0.3) {
      this.particles.sparkleBurst(
        Math.random() * CFG.W + this.camera.scrollX,
        Math.random() * CFG.H + this.camera.scrollY,
        2
      );
    }
  }
  start() {
    requestAnimationFrame(t => this.run(t));
  }
}

// ============================================================
//  INITIALIZATION
// ============================================================

const game = new Game();
game.start();

</script>
</body>
</html>
